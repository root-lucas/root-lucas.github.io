<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript版 · 剑指offer</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/0.readme/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>由于内容太多，所以划分成了 10 个专题，分别是：位运算、哈希表、堆、字符串、数组、查找、栈和队列、树、递归与循环、链表。</strong></p>
<p>网上已经有很多 js 版本，这版也没什么特别的地方，但是题目收录完整、专题划分明确、代码和文章风格统一，是花了蛮多心血和业余时间在里面，所以自荐一下。</p>
<p>希望这对于你之后的学习和面试稍有帮助，文章源码开放，食用请来<a href="https://root-lucas.github.io/passages/2019-06-23-algorithm-offer/">伯乐博客</a>。</p>
<p><strong>如果您觉得还有点意思，欢迎鼓励一个 Star</strong>：<a href="https://github.com/root-lucas/Blog">https://github.com/root-lucas/Blog</a></p>
<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p><a href="https://book.douban.com/subject/6966465/">《剑指 Offer》</a>，除了“手动实现 atoi”采用的是 Leetcode 版，其余题目均来自此书。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-str-replace-empty/">01-替换空格</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-str-perm/">02-字符串的全排列</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-str-reverse-sentence/">03-翻转单词顺序</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-str-atoi/">04-实现 atoi</a></li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-find-min-num/">01-旋转数组最小的数字</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-find-times-in-sorted/">02-数字在排序数组中出现的次数</a></li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-print/">01-从尾到头打印链表</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-delete-node/">02-快速删除链表节点</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-last-kth-node/">03-链表倒数第 k 节点</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-reverse/">04-反转链表</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-merge/">05-合并两个有序链表</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-clone/">06-复杂链表的复制</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-list-first-same-node/">07-两个链表中的第一个公共节点</a></li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-array-find/">01-二维数组中的查找</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-array-change-location/">02-数组顺序调整</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-array-min-numbers/">03-把数组排成最小的数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-array-inverse-pair/">04-数组中的逆序对</a></li>
</ul>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-stack-queue-exchange/">01-用两个栈实现队列</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-stack-queue-min-stack/">02-包含 min 函数的栈</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-stack-queue-push-pop-order/">03-栈的压入弹出序列</a></li>
</ul>
<h2 id="递归和循环"><a href="#递归和循环" class="headerlink" title="递归和循环"></a>递归和循环</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-fibonacci/">01-青蛙跳台阶</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-pow/">02-数值的整次方</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-from-one-to-one/">03-打印从 1 到最大的 n 位数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-print-matrix/">04-顺时针打印矩阵</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-times-more-than-half/">05-数组中出现次数超过一半的数字</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-min-kth/">06-最小的 k 个数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-and-number-is-s/">07-和为 s 的两个数字</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-s-sequence/">08-和为 s 的连续正数序列</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-n-probability/">09-n 个骰子的点数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-playing-cards/">10-扑克牌的顺子</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-recursive-loop-joseph-ring/">11-圆圈中最后剩下的数字</a></li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-rebuild/">01-重建二叉树</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-subtree/">02-判断是否子树</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-mirror/">03-二叉树的镜像</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-tail-order/">04-二叉搜索树的后序遍历序列</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-path-with-number/">05-二叉树中和为某一值的路径</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-level-travel/">06-二叉树层序遍历</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-convert-to-list/">07-二叉树转双向链表</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-tree-is-balance/">08-判断是否是平衡二叉树</a></li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-bit-number-of-one/">01-二进制中 1 的个数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-bit-number-of-one-more/">02-二进制中 1 的个数进阶版</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-bit-first-one/">03-数组中只出现一次的数字</a></li>
</ul>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-hash-ugly/">01-丑数</a></li>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-hash-first-no-repeat-char/">02-第一次只出现一次的字符</a></li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>  <a href="https://root-lucas.github.io/passages/2019-06-23-heap-kth-numbers/">01-最小的 k 个数</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全与防护</title>
    <url>/2018/11/24/wang-luo-an-quan/web-an-quan-yu-fang-hu/</url>
    <content><![CDATA[<h2 id="1-SQL-注入"><a href="#1-SQL-注入" class="headerlink" title="1. SQL 注入"></a>1. SQL 注入</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。</p>
<p>比如后端拼接的 SQL 字符串是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;user&#x27;</span> <span class="keyword">AND</span> <span class="keyword">password</span> = <span class="string">&#x27;pwd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果不做任何防护，直接拼接前端的字符，就会出现问题。比如前端传来的<code>user</code>字段是以<code>&#39;#</code>结尾，<code>password</code>随意：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;user&#x27;</span><span class="comment">#&#x27;AND password = &#x27;pwd&#x27;;</span></span><br></pre></td></tr></table></figure>

<p><strong>密码验证部分直接被注释掉了</strong>。</p>
<h3 id="1-2-防范"><a href="#1-2-防范" class="headerlink" title="1.2 防范"></a>1.2 防范</h3><p>后端应该对于字符串有转义，可以借助成熟的库的 API 来拼接命令，而不是自己手动拼接。</p>
<h2 id="2-XSS：跨站脚本攻击"><a href="#2-XSS：跨站脚本攻击" class="headerlink" title="2. XSS：跨站脚本攻击"></a>2. XSS：跨站脚本攻击</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。<strong>JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限</strong>，例如可以获取 server 端数据、可以获取 cookie 等。</p>
<p>比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。</p>
<h3 id="2-2-防范"><a href="#2-2-防范" class="headerlink" title="2.2 防范"></a>2.2 防范</h3><p>前端对用户输入内容进行验证，如果有风险，就进行替换。例如：<code>&amp;</code> 替换为 <code>&amp;amp;</code></p>
<h2 id="3-CSRF-跨站请求伪造"><a href="#3-CSRF-跨站请求伪造" class="headerlink" title="3. CSRF: 跨站请求伪造"></a>3. CSRF: 跨站请求伪造</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。比如获取<code>cookie</code>、破解<code>token</code>加密等等。</p>
<h3 id="3-2-防范"><a href="#3-2-防范" class="headerlink" title="3.2 防范"></a>3.2 防范</h3><ul>
<li>敏感数据不使用<code>GET</code></li>
<li>前后端约定加密方式和密钥，<strong>并且经常更新密钥</strong></li>
<li>对 IP 限制一定时间内的访问次数</li>
<li>设置网站白名单</li>
</ul>
<h2 id="4-中间人攻击"><a href="#4-中间人攻击" class="headerlink" title="4. 中间人攻击"></a>4. 中间人攻击</h2><h3 id="4-1-原理和防范"><a href="#4-1-原理和防范" class="headerlink" title="4.1 原理和防范"></a>4.1 原理和防范</h3><p>它也被称为浏览器劫持、web 劫持。可以往 web 中添加一些第三方厂商的 dom 元素，或者重定向到另外的钓鱼站。</p>
<p>常用手段有 2 种：</p>
<ol>
<li>网络报文传输过程中对其截获、篡改（过程中）</li>
<li>客户端发起 http 请求之前或者得到 response 之后对数据篡改（开头、结尾）</li>
</ol>
<p>防范方式就是使用 <code>https</code> 协议，一套在传输层 TCP 和应用层 HTTP 之间的 TLS 协议。</p>
<h3 id="4-2-https-交互细节"><a href="#4-2-https-交互细节" class="headerlink" title="4.2 https 交互细节"></a>4.2 https 交互细节</h3><p>以下内容摘自：<a href="https://toutiao.io/posts/ju2uhb/preview">《深入理解 Web 安全：中间人攻击》</a></p>
<p>简单地说，一次 https 网络请求在建立开始阶段具有以下的一个“握手”流程：</p>
<p>首先，客户端向服务端发起一个基于 https 协议的网络请求，这相当于告诉它：“我希望得到一个安全加密的网页，你可别直接把明文扔过来！”</p>
<p>服务端接收到这个网络请求后，了解到客户端的提出的这种加密的诉求，于是先把一个<em>公钥</em>和网站的 https 证书发送给客户端。</p>
<p>客户端随后要做两件事，一是验证证书的合法性与时效性，如果颁发证书的机构客户端这边不承认或者证书中标明的过期时间已经过了，这都会导致客户端浏览器报出那个红叉子，chrome 浏览器还会直接拦截掉这个请求，除非用户点详情-&gt;继续，否则不会与该网站的服务器进行后续沟通，这相当于一个强交互的提醒，告诉用户“我拿到的证书有问题，这网站可能是个冒牌货，你要看仔细了！”</p>
<p>如果以上两步验证无误，那么客户端会先生成一个<em>随机秘钥</em>，利用刚刚拿到的<em>公钥</em>给自己要访问的 url+这个<em>随机秘钥</em>进行加密，把密文再次发往服务端。</p>
<p>当服务端收到客户端传过来的密文之后，会通过自己手里持有的一个<em>私钥</em>对密文进行解密。<em>注意，这里提到的私钥和刚刚的公钥是一对儿秘钥，这是一个典型的非对称加密，加密和解密分别使用两把不同的钥匙，这也保证了在此场景下的安全性。</em></p>
<p>此时，服务端要将真正的 html 网页文本发给你了，它会利用解密得到的<em>随机秘钥</em>对网页文本内容进行加密，将密文发给客户端。</p>
<p>客户端拿到真正的 html 报文之后，就用自己刚才生成的那个<em>随机秘钥</em>进行解密，然后就得到了跟普通 http 请求时一样的一个网页文本了，在这之后就像往常那样解析、渲染、加载更多资源……</p>
<p>对于真正要传输的 html 文本，实际上是使用刚刚提到的这个<em>随机秘钥</em>进行了一次对称加密，因为上锁和开锁的钥匙实际上是一模一样的。</p>
<h2 id="5-DDoS"><a href="#5-DDoS" class="headerlink" title="5. DDoS"></a>5. DDoS</h2><p>攻击者在短时间内发起大量请求，利用协议的缺点，耗尽服务器的资源，导致网站无法响应正常的访问。</p>
<p>我之前也经历过！</p>
<p>防范的措施，或者称之为补救措施更合适，有以下建议：</p>
<ol>
<li>借助云厂商 CDN：静态流量的资源还得自己掏钱</li>
<li>IP 黑/白名单：<code>nginx</code> 和 <code>apache</code> 都可以设置</li>
<li>HTTP 请求信息：根据 UserAgent 等字段的信息</li>
<li>静态化：博客网站直接挂在 github 等平台上</li>
<li>备份网站：阮一峰老师的网站被 ddos 的时候就有个备份页面</li>
<li>其他：弹性 ip、免费的 DNSpod、国内外分流、高防 ip 等等</li>
</ol>
<h2 id="6-点击劫持"><a href="#6-点击劫持" class="headerlink" title="6. 点击劫持"></a>6. 点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者通过 <code>iframe</code> 嵌套嵌入被攻击网页，诱导用户点击。如果用户之前登陆过被攻击网页，那么浏览器可能保存了信息，因此可以以用户的身份实现操作。</p>
<p>js 防范手段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">&quot;click-jack&quot;</span>&gt;</span></span><br><span class="line">    html &#123;</span><br><span class="line">      display: none !important;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 判断当前页面是否是iframe加载</span></span></span><br><span class="line">    if (self === top) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> style = <span class="built_in">document</span>.getElementById(<span class="string">&quot;click-jack&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.removeChild(style);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">      top.location = self.location;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击实战</title>
    <url>/2018/09/24/wang-luo-an-quan/xss-gong-ji-shi-zhan/</url>
    <content><![CDATA[<h2 id="什么是XSS？"><a href="#什么是XSS？" class="headerlink" title="什么是XSS？"></a>什么是XSS？</h2><p>为了与层叠样式表css区分，将跨站脚本简写为XSS。</p>
<h2 id="XSS攻击原理"><a href="#XSS攻击原理" class="headerlink" title="XSS攻击原理"></a>XSS攻击原理</h2><p>XSS（Cross Site Scripting）攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。</p>
<p>XSS，两个层次是服务器端和浏览器端。协议就是HTML/CSS/JavaScript。对于服务器端来说，html是数据（字符串）；对于浏览器端来说，html是指令。XSS的原理，就是破坏html/css/js的构造。</p>
<p><strong>主要危害</strong></p>
<p>　　1、盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号<br>　　2、控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力<br>　　3、盗窃企业重要的具有商业价值的资料<br>　　4、非法转账<br>　　5、强制发送电子邮件<br>　　6、网站挂马<br>　　7、控制受害者机器向其它网站发起攻击</p>
<p>XSS根据效果不同可以分为三类</p>
<ol>
<li>反射型XSS(reflected)</li>
<li>存储型XSS(stored)  </li>
<li>DOM Based XSS</li>
</ol>
<blockquote>
<p>黑客更喜欢“存储型”，或者说“存储型”的“危害”更大</p>
</blockquote>
<h4 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="1.反射型XSS"></a>1.反射型XSS</h4><p>反射型XSS，也叫非持久型XSS，是指发生请求时，<strong>XSS代码出现在请求URL中</strong>，作为参数提交到服务器，服务器解析并响应。响应结果中包含危险XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。</p>
<p>这类通常使用URL，具体流程：</p>
<p>　　1、Alice给Bob发送一个恶意构造了Web的URL。<br>　　2、Bob点击并查看了这个URL。<br>　　3、恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。<br>　　4、具有漏洞的HTML页面包含了在Bob电脑本地域执行的JavaScript。<br>　　5、Alice的恶意脚本可以在Bob的电脑上执行Bob所持有的权限下的命令。</p>
<p>举个列子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8080/helloController/search?name=&lt;script&gt;alert(&quot;hey!&quot;)&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//localhost:8080/helloController/search?name=&lt;img src=&#x27;w.123&#x27; onerror=&#x27;alert(&quot;hey!&quot;)&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//localhost:8080/helloController/search?name=&lt;a onclick=&#x27;alert(&quot;hey!&quot;)&#x27;&gt;点我&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// 有时攻击者会伪造一个图片，让你点击后链接跳转URL</span></span><br></pre></td></tr></table></figure>

<p>服务端代码片段，只做了一个简单的字符串连接就返回给客户端。</p>
<blockquote>
<p>Chrome是有做处理的相对比较安全，但是Firefox就没有。</p>
</blockquote>
<h4 id="2-存储型XSS"><a href="#2-存储型XSS" class="headerlink" title="2.存储型XSS"></a>2.存储型XSS</h4><p>存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。</p>
<p>例如:该网页有一个发表评论的功能，该评论会写入后台数据库，其他用户访问留言板的时候，会从数据库中加载出所有的评论并执行了相应的 js 代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 留言解析攻击</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://bundle.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://bundle.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 诱导到钓鱼网站</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onclick</span>=<span class="string">&quot;window.location.href=&#x27;http://www.baidu.com&#x27;&quot;</span> <span class="attr">width</span>=<span class="string">&#x27;300&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;img/webwxgetmsgimg.jpg&#x27;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 劫持流量实现恶意跳转</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.location.href=<span class="string">&quot;http://www.baidu.com&quot;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-DOM型XSS"><a href="#3-DOM型XSS" class="headerlink" title="3.DOM型XSS"></a>3.DOM型XSS</h4><p>与前两者完全不同，<strong>DOM型XSS</strong>是纯前端的XSS漏洞，XSS直接通过浏览器进行解析，就完成攻击。</p>
<p>基于DOM的XSS有时也称为type0XSS。如果服务端对DOM中的数据没有经过严格确认，当用户能够通过交互动态地检查和修改浏览器页面中DOM(DocumentObjectModel)并显示在浏览器上时，就有可能产生这种漏洞，从效果上来说它也是反射型XSS。</p>
<p><img src="http://hiphotos.baidu.com/gongyanlei123/pic/item/74b0e44ec079f0b6d62afc75.jpg" alt="img"></p>
<p>实例1：包括<code>\\</code>符号也要复制进去</p>
<p>这种攻击方式是因为其操作处于双引号之内，系统转义了双引号导致变量无法“escape”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;ggg&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(/xss/)&quot;</span> \\&#x27;&gt;</span>示范2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value;    </span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;div&quot;</span>).innerHTML = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们在文本输入框输入下面：（注意含有空格）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; οnclick=alert(/xss/) //</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="string">&#x27;</span> οnclick=alert(<span class="regexp">/xss/</span>)  \\</span><br><span class="line">或者</span><br><span class="line"><span class="string">&#x27; οnclick=alert(/xss/)  /\</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/09/lWBLg1.png" alt="图片"></p>
<p>输入后，页面代码就变成了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">onclick</span>=<span class="string">alert(/xss/)//</span>&#x27; &gt;</span>生成的link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/09/lWBWj0.png" alt="图片2"></p>
<p>首先用一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后再用注释符”//“注释掉第二个单引号。</p>
<p>点击这个新生成的连接，脚本将被执行：</p>
<p><img src="https://s2.ax1x.com/2020/01/09/lWDFgI.png" alt="图片3"></p>
<p>你可以拿下面的img图片用上面的实例测试也可以有类似效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">onerror</span>=<span class="string">alert(</span>&quot;/<span class="attr">xss</span>/&quot;);&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>).value; </span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;div&quot;</span>).innerHTML = <span class="string">&quot;&lt;img src=&quot;</span>+<span class="string">&#x27;gggg &#x27;</span>+str+<span class="string">&quot; /&gt;&quot;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// 注意src的值gggg后面附带空格的</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意src的值gggg后面附带空格的，若是忘写空格，则必须要文本输入框中首个字符是空格</p>
</blockquote>
<p>我们在文本输入框输入下面：：  （注意含有空格）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; onerror=alert(/我是xss/) </span></span><br></pre></td></tr></table></figure>

<p><img src="http://chuantu.xyz/t6/710/1578559757x992245926.png" alt="图片4"></p>
<p>反射型XSS效果与存储型XSS和DOM型XSS唯一的差别是反射型XSS直接把GET中的参数显示在网页上，没有经过数据库，而存储型XSS是先存储到服务器上，再回显到网页的。则DOM型XSS是单纯的前端漏洞</p>
<p>(2016.3.16修改,domxss取决于输出位置,并不取决于输出环境,因此domxss既有可能是反射型的,也有可能是存储型的)</p>
<h2 id="XSS攻击的注入点"><a href="#XSS攻击的注入点" class="headerlink" title="XSS攻击的注入点"></a>XSS攻击的注入点</h2><ul>
<li>HTML节点内容</li>
<li>HTML属性</li>
<li>JavaScript代码 （字符串提前关闭）</li>
<li>富文本</li>
</ul>
<p><strong>1、HTML节点内容</strong><br>这个其实就是我之前演示的，HTML节点中暗藏攻击脚本。</p>
<p><img src="https://segmentfault.com/img/bV31QU?w=380&h=63" alt="HTML节点内容**"></p>
<p><strong>2、HTML属性</strong><br>这里img的src属性是由用户传递过来的值，当用户把图片地址写成错误的：1”%20onerror=”alert(%27哈哈被攻击%27)</p>
<p><img src="https://segmentfault.com/img/bV31RO?w=410&h=60" alt="clipboard.png"></p>
<p><img src="https://segmentfault.com/img/bV31RM?w=909&h=165" alt="clipboard.png"></p>
<p><strong>3、JavaScript代码 （字符串提前关闭）</strong><br>当JavaScript代码中有一个变量是由用户提供的数据，这个数据也有可能之前被写入了数据库。如下图，当用户输入的内容为：<br>小柚子”;alert(%27哈哈你被攻击了！%27);”</p>
<p><img src="https://segmentfault.com/img/bV31Vh?w=532&h=49/view" alt="preview"></p>
<p><img src="https://segmentfault.com/img/bV31Vd?w=1019&h=163/view" alt="preview"></p>
<p>**4、富文本 **<br>大家都知道，富文本其实就是一段HTML。既然它是一段HTML，那么就存在XSS攻击。而且富文本攻击的防御相对比较麻烦。</p>
<h2 id="XSS防御措施"><a href="#XSS防御措施" class="headerlink" title="XSS防御措施"></a>XSS防御措施</h2><p>chrome浏览器自带防御,可拦截<strong>反射性XSS</strong>（HTML内容和属性），js和富文本的无法拦截，所以我们必须得自己做一些防御手段。</p>
<p><strong>反射性XSS的</strong>url处理，采用插值或过滤</p>
<ol>
<li>推荐使用插值</li>
<li>encodeURI</li>
</ol>
<p><strong>1、HTML节点内容的防御</strong></p>
<p>将用户输入的内容进行转义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端代码</span></span><br><span class="line"><span class="keyword">var</span> escapeHtml = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>,<span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">&#x27;&amp;gt;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.render(<span class="string">&#x27;index&#x27;</span>, &#123;comments, <span class="attr">from</span>: escapeHtml(ctx.query.from || <span class="string">&#x27;&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bV310b?w=574&h=81/view" alt="preview"></p>
<p><strong>2、HTML属性的防御</strong> </p>
<p>对空格，单引号，双引号进行转义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端代码</span></span><br><span class="line"><span class="keyword">var</span> escapeHtmlProperty = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;&amp;quto;&#x27;</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&#x27;/g</span>,<span class="string">&#x27;&amp;#39;&#x27;</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/ /g</span>,<span class="string">&#x27;&amp;#32;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx.render(<span class="string">&#x27;index&#x27;</span>, &#123;posts, comments,</span><br><span class="line">    <span class="keyword">from</span>:ctx.query.from || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    avatarId:escapeHtmlProperty(ctx.query.avatarId || <span class="string">&#x27;&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bV311b?w=572&h=52/view" alt="preview"></p>
<p><strong>3、JavaScript的防御</strong>  </p>
<p>对引号进行转义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> escapeForJS = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        str = str.replace(<span class="regexp">/\\/g</span>,<span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">        str = str.replace(<span class="regexp">/&quot;/g</span>,<span class="string">&#x27;\\&quot;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bV311y?w=484&h=34/view" alt="preview"></p>
<p><strong>4、富文本的防御</strong>   </p>
<p>富文本的情况非常的复杂，js可以藏在标签里，超链接url里，何种属性里。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以我们不能过用上面富文本的方法做简单的转义。因为情况实在太多了。</p>
<p>现在我们换个思路，<br>提供两种过滤的办法：比较复杂，需要用白名单过滤，不在白名单中的都转义</p>
<p>1）黑名单<br>我们可以把<code>&lt;script/&gt; onerror </code>这种危险标签或者属性纳入黑名单，过滤掉它。但是我们想，这种方式你要考虑很多情况，你也有可能漏掉一些情况等。</p>
<p>2）白名单<br>这种方式只允许部分标签和属性。不在这个白名单中的，一律过滤掉它。但是这种方式编码有点麻烦，我们需要去解析html树状结构，然后进行过滤，把过滤后安全的html在输出。<br>这里提供一个包，帮助我们去解析html树状结构，它使用起来和jquery非常的类似。</p>
<p><code>npm install cheerio --save</code>    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xssFilter = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!html) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(html);</span><br><span class="line">    <span class="comment">//白名单</span></span><br><span class="line">    <span class="keyword">var</span> whiteList = &#123;</span><br><span class="line">        <span class="string">&#x27;html&#x27;</span> : [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span> : [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;head&#x27;</span> : [<span class="string">&#x27;&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;div&#x27;</span> : [<span class="string">&#x27;class&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;img&#x27;</span> : [<span class="string">&#x27;src&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span> : [<span class="string">&#x27;href&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;font&#x27;</span>:[<span class="string">&#x27;size&#x27;</span>,<span class="string">&#x27;color&#x27;</span>]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&#x27;*&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,elem</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">!whiteList[elem.name]</span>)</span> &#123;</span><br><span class="line">            $(elem).remove();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> attr <span class="keyword">in</span> elem.attribs</span>)</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(<span class="params">whiteList[elem.name].indexOf(attr) === -<span class="number">1</span></span>)</span> &#123;</span><br><span class="line">                $(elem).attr(attr,<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $.html();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(xssFilter(<span class="string">&#x27;&lt;div&gt;&lt;font color=&quot;red&quot;&gt;你好&lt;/font&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;script&gt;alert(&quot;哈哈你被攻击了&quot;)&lt;/script&gt;&lt;/div&gt;&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>大家可以看到：</p>
<p><img src="https://segmentfault.com/img/bV314w?w=650&h=42" alt="clipboard.png"></p>
<p><code>&lt;script&gt;</code>不在白名单中，所以被过滤掉了。</p>
<p><strong>5、CSP(Content Security Policy)</strong></p>
<p>内容安全策略（Content Security Policy，简称CSP）是一种以可信白名单作机制，来限制网站中是否可以包含某来源内容。默认配置下不允许执行内联代码（<script>块内容，内联事件，内联样式），以及禁止执行eval() , newFunction() , setTimeout([string], ...) 和setInterval([string], ...) 。</p>
<blockquote>
<p>CSP 的主要目标是减少和报告 XSS 攻击 </p>
</blockquote>
<p><strong>CSP的使用示例：</strong></p>
<ol>
<li>在HTTP Header上使用（首选）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.只允许本站资源</span></span><br><span class="line">Content-Security-Policy： <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.允许本站的资源以及任意位置的图片以及 [https://segmentfault.com]下的脚本。</span></span><br><span class="line">Content-Security-Policy： <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span>; img-src *;script-src: https:<span class="comment">//segmentfault.com</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在HTML上使用</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-security-policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;策略&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-security-policy-report-only&quot;</span> <span class="attr">content</span>=<span class="string">&quot;策略&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Meta 标签与 HTTP 头只是方式不同但作用是一致的，如果 HTTP 头与 Meta 定义同时存在，则优先采用 HTTP 中的定义。</p>
</blockquote>
<p><strong>6、设置cookie httponly为true</strong></p>
<p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。</p>
<p><code>response.setHeader(&quot;Set-Cookie&quot;, &quot;cookiename=httponlyTest;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;);</code></p>
<p>HttpOnly的设置样例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line">response.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;uid=112; Path=/; HttpOnly&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置多个cookie</span></span><br><span class="line">response.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;uid=112; Path=/; HttpOnly&quot;</span>);</span><br><span class="line">response.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;timeout=30; Path=/test; HttpOnly&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置https的cookie</span></span><br><span class="line">response.addHeader(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;uid=112; Path=/; Secure; HttpOnly&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>具体参数的含义再次不做阐述，设置完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取。</p>
<p>Cookie cookies[]=request.getCookies(); </p>
<p><a href="https://www.cnblogs.com/mao2080/p/9460397.html">参考1</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">参考2</a></p>
<p><a href="https://segmentfault.com/a/1190000020155549?utm_source=tag-newest">参考3</a></p>
<p><a href="https://www.cnblogs.com/ziyoublog/p/11389695.html">参考4</a></p>
<p><a href="https://blog.csdn.net/weixin_40270125/article/details/86549497">参考5</a></p>
</script></p>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>README.md</title>
    <url>/2018/11/06/she-ji-mo-shi-shou-ce/readme/</url>
    <content><![CDATA[<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>1、创建型模式：创建对象的模式，抽象了实例化的过程。</p>
<p>2、结构型模式：解决怎样组装现有对象，设计交互方式，从而达到实现一定的功能目的。例如，以封装为目的的适配器和桥接，以扩展性为目的的代理、装饰器。</p>
<p>3、行为型模式：描述多个类或对象怎样交互以及怎样分配职责。</p>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue问题</title>
    <url>/2018/07/15/mian-shi-bao-dian/03.vue-wen-ti/</url>
    <content><![CDATA[<h3 id="什么是单向数据绑定？"><a href="#什么是单向数据绑定？" class="headerlink" title="什么是单向数据绑定？"></a>什么是单向数据绑定？</h3><p>单向数据绑定即一方面只受另一方面影响，却无法影响另一方面。前端常说的单向数据绑定一般都指数据影响页面，而页面不影响数据。</p>
<h3 id="什么是双向数据绑定？"><a href="#什么是双向数据绑定？" class="headerlink" title="什么是双向数据绑定？"></a>什么是双向数据绑定？</h3><p>双向的意思即两个方面相互影响，前端来说，即数据影响页面，页面同时影响数据。例如，在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的，在它们之间存在着 ViewModel 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model(数据) 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。</p>
<h3 id="什么是单页面？什么是双页面"><a href="#什么是单页面？什么是双页面" class="headerlink" title="什么是单页面？什么是双页面"></a>什么是单页面？什么是双页面</h3><h4 id="单页面"><a href="#单页面" class="headerlink" title="单页面"></a>单页面</h4><p>即 第一次进入页面的时候会请求一个html文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容也变化了。（多用于移动端）</p>
<p>原理是：JS会感知到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求html文件了。</p>
<h4 id="多页面"><a href="#多页面" class="headerlink" title="多页面"></a>多页面</h4><p>即 每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。（常用于PC端）<br>原理是：传统的页面应用，是用一些超链接来实现页面切换和跳转的</p>
<p>其实刚才单页面应用跳转原理即 vue-router实现原理</p>
<h3 id="vue-router原理"><a href="#vue-router原理" class="headerlink" title="vue-router原理"></a>vue-router原理</h3><p>vue-router通过<strong>hash</strong>与<strong>History interfac</strong>e两种方式实现前端路由，更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式</p>
<p>所以vue-router原理核心就是 更新视图但不重新请求页面。</p>
<p>vue-router实现单页面路由跳转，提供了三种方式：hash模式、history模式、abstract模式，根据mode参数来决定采用哪一种方式。</p>
<p>vue-router 提供了三种运行模式：<br>● hash: 使用 URL hash 值来作路由。默认模式。<br>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。<br>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端</p>
<p>使用:在路由<code>index.js</code>对象中加上<code>mode:&#39;history&#39;</code>表示启用history模式(默认不写就是hash模式)</p>
<h3 id="vuex原理是什么？"><a href="#vuex原理是什么？" class="headerlink" title="vuex原理是什么？"></a>vuex原理是什么？</h3><p>Vuex采用MVC模式中的Model层，规定所有的数据必须通过action—&gt;mutaion—&gt;state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。统一页面状态管理，可以让复杂的组件交互变的简单清晰，同时在调试时也可以通过DEVtools去查看状态。</p>
<h3 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<blockquote>
<p>具体步骤：</p>
</blockquote>
<p><strong>第一步：</strong>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p>
<p><strong>第二步：</strong>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p><strong>第三步：</strong>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p><strong>第四步：</strong>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<p><strong>js实现简单的双向绑定</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;txt&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;show&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;txt&#x27;</span>, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).value = newValue</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        obj.txt = e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="vue-比-jquery-好在哪里"><a href="#vue-比-jquery-好在哪里" class="headerlink" title="vue 比 jquery 好在哪里"></a>vue 比 jquery 好在哪里</h3><ol>
<li>Vue 比 JQuery 减少了 DOM 操作</li>
<li>Vue 支持双向数据绑定</li>
<li>Vue 支持组件化(如我要实现下拉菜单功能，那在下拉菜单这个组件中，就把下拉菜单所需要的所有功能全部实现。)</li>
</ol>
<p>组件化的优点<br>1.提高开发效率 2.方便重复使用 3.简化调试步骤 4.提升整个项目的可维护性 5.便于协同开发 6.低耦合度 7.高内聚性</p>
<h3 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h3><p>组件本质上是 Vue 实例，它们封装模板、逻辑和可选的本地响应性数据属性，能够提供可重新使用的自定义构建元素。可重用性是构建组件的核心。</p>
<p>使用单文件组件构建应用程序时，组件在扩展名为 .vue 的文件中定义。单文件组件包含三个部分：模板部分定义了该组件的 HTML 布局；脚本部分定义了数据、属性和逻辑单元（如方法）并将内容导出为 Vue 组件；还有一个样式部分，用于定义组件的样式表。单文件组件使用 Webpack 等模块捆绑器进行编译。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>非技术面试问答</title>
    <url>/2018/07/25/mian-shi-bao-dian/04.fei-ji-zhu-mian-shi-wen-da/</url>
    <content><![CDATA[<h3 id="面试三大黄金法"><a href="#面试三大黄金法" class="headerlink" title="面试三大黄金法"></a>面试三大黄金法</h3><p>总的来说，回答问题时遵循这三大黄金法则准没错：</p>
<pre><code>1.你要承担起80%的谈话，留给面试官20%。
2.不要表现得不自信，也不要说空话、说大话。
3.凡事要结合自身，举例子+列数字会让你更接地气、更加分哦！</code></pre>
<p>面试是求职过程中至关重要的一环，无论你简历多么优秀、笔试成绩多高，面试没过，就无法进入心仪的企业。面试题花样虽多，但万变不离其宗，如何把“送命题”变成“送分题”，这就要看你的自我修炼了。</p>
<h3 id="请你自我介绍一下你自已"><a href="#请你自我介绍一下你自已" class="headerlink" title="请你自我介绍一下你自已"></a>请你自我介绍一下你自已</h3><p>你可能会疑惑：“简历上明明写得很清楚，为什么还要我介绍自己？是 HR 没看简历吗？”</p>
<p>其实，企业最希望知道的是求职者能否胜任工作，而不是学校那点流水账，可以按照下面这两步去阐述，而且用时不超过 3 分钟。</p>
<p>① 简单开场：教育经历、基本信息，一到两句就可以了。<br>② 进入这个行业的原因：做过什么实习，参加过什么比赛，有过什么相关实习经历。</p>
<p><strong>回答提示：</strong>大家好，我是 xxx 我是一名 xxx 开发工程师，我毕业于哪所学校，学的是什么专业，在校期间获得了哪些奖项。假期曾在哪家公司的何种岗位实习，帮助公司在 2 个月内取得了什么成果。通过实习发现，这是最适合我的岗位，我也想迎接新的挑战，所以一直在寻找这方面的工作。了解到贵公司在某领域表现颇佳，想要加入进来，和大家一起努力，做出成绩。</p>
<h3 id="五年内的职业生涯规划"><a href="#五年内的职业生涯规划" class="headerlink" title="五年内的职业生涯规划"></a>五年内的职业生涯规划</h3><p>第一阶段，我希望在 1 年之内能够在我目前申请的这个职位上沉淀下来，在熟悉公司的情况的基础上，积累最起码的工作经验，把基础打牢。</p>
<p>在 1-3 年内，在该领域中技术能力和业务能力上不断提高的过程中，能够出色地业绩将上级分派给的项目完成,胜任这份工作能将的更好。</p>
<p>在 3-5 年内，并为未来的雇主提升看得到的业绩,并逐渐向 xxx 组主管迈进，无论是技术上还是业务能力中都能带领团队中其他的成员一起共同进步,做出能为公司体现自我价值的 150%。努力的向一名某 X 领域专业化的专家前进。</p>
<p>为了达到我的规划</p>
<ol>
<li>解决自我盘点中的劣势和缺点并改进</li>
<li>时间安排：</li>
<li>付出行动：计划落实到行动上来</li>
</ol>
<p>假如一直没有达到我的规划目标，那么我将按实际情况作出改变，或另制定计划和目标 。</p>
<h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><pre><code>热爱编程技术,热衷于钻研新型计算机技术，自学能力较强。
逻辑条理性强，具备良好的沟通能力。
有较强的业务理解能力，有良好的接口设计风格和编程习惯，对代码及性能优化有自己的理解。
工作认真且负责，责任心强，抗压能力强，如工作需要会配合工作进行长时间加班</code></pre>
<h3 id="说说你对该岗位职责的描述"><a href="#说说你对该岗位职责的描述" class="headerlink" title="说说你对该岗位职责的描述"></a>说说你对该岗位职责的描述</h3><ol>
<li>根据产品需求对各种不同的客户端页面进行设计、开发和维护</li>
<li>与项目相关人员配合共同完成软件的开发设计工作</li>
<li>按照项目工作计划，在保证质量的前提下，按时完成开发任务</li>
<li>协助测试人员进行相关的调试</li>
</ol>
<h3 id="说说你的优点和缺点"><a href="#说说你的优点和缺点" class="headerlink" title="说说你的优点和缺点"></a>说说你的优点和缺点</h3><p>优点回答提示：沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。</p>
<p>要例举具体的优点，如：做事认真、抗压能力强、乐于助人、学习能力强等，然后要举实例证明这也是最重要的一点。</p>
<p>缺点回答提示：企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。<br>回答样本：我平时比较爱忘事，然后我通过写便条来提醒我自己什么时候该做什么事。</p>
<h3 id="你担任该职位的优势和劣势在那"><a href="#你担任该职位的优势和劣势在那" class="headerlink" title="你担任该职位的优势和劣势在那"></a>你担任该职位的优势和劣势在那</h3><p>优势：</p>
<pre><code>1.有前端领域有三年开发经验，能够熟练处理日常事务和应对紧急事务
2.单身，并且年富力强，能够专注为公司服务
3.能够独立的完成各个组件的开发</code></pre>
<p>在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。</p>
<p>劣势：</p>
<pre><code>1、上班路程相对远些，但会尽快解决这个问题；
2、其他相关部门需要加深沟通和了解；
3、需要熟悉公司各项规章制度和工作流程，因为每家公司的规定和工作流程都是不一样的；
综上，请给我一点时间来适应和融入公司。</code></pre>
<h3 id="当你遇到无法回答的问题时"><a href="#当你遇到无法回答的问题时" class="headerlink" title="当你遇到无法回答的问题时"></a>当你遇到无法回答的问题时</h3><p>思路：</p>
<pre><code>1、不要着急回答，低头沉思片刻，以示自己的认真态度与这个问题的难度。
2、抬头注视着对方，面带愧疚，表明自己在这个问题上只知道皮毛，不知道深意。
3、适时将问题抛给对方，表示出愿意聆听教导的诚意。
同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在于应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</code></pre>
<h3 id="如果我录用你，你将怎样开展工作"><a href="#如果我录用你，你将怎样开展工作" class="headerlink" title="如果我录用你，你将怎样开展工作"></a>如果我录用你，你将怎样开展工作</h3><p>首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。</p>
<h3 id="你对加班如何看待？"><a href="#你对加班如何看待？" class="headerlink" title="你对加班如何看待？"></a>你对加班如何看待？</h3><p>但是你也不能表现出来愿意加班到“天荒地老”，这样可能会让 HR 认为你的工作效率会很低。那么究竟要如何回答才能给你加分呢？</p>
<p><strong>回答提示:</strong> 如果工作需要，我会义不容辞的加班，我现在单身，没有家庭负担，可以全身心的投入工作。但同时,我也会提高工作效率，尽量减少不必要的加班，这个回答是本人见过最完美的答案了。也确实符合，哈哈哈！</p>
<h3 id="你最大的优点是什么？"><a href="#你最大的优点是什么？" class="headerlink" title="你最大的优点是什么？"></a>你最大的优点是什么？</h3><p>沉着冷静、条理清楚、乐于助人、适应能力、乐观？能用的好词都用上就 OK 了？</p>
<p>看准君想说，回答这道题时你千万别飘，不要越夸自己越起劲，其实这些虚词并没什么用，要与实际结合在一起举出例子才能让人信服。</p>
<p><strong>回答提示：</strong> 我的优点是细心、善于总结。在学校帮忙组织过某某活动，过程中确实出现了问题，这些问题都用了什么手段得到及时的修正，活动结束后做出总结。在下次活动中，我提前做了准备，并拟好了应急方案，数据结果比上次有了怎样的增长。</p>
<h3 id="说说你最大的缺点？"><a href="#说说你最大的缺点？" class="headerlink" title="说说你最大的缺点？"></a>说说你最大的缺点？</h3><p>请注意以下几点：<br>① 避免谈致命弱点：如拖延症、脾气大、懒、工作效率低。<br>② 避免谈非职业缺点：如感情洁癖、挑食、不会做饭。<br>③ 避免狂妄自大：如“我的缺点就是没有缺点”“过于追求完美”。</p>
<p><strong>回答提示：</strong> 我公开演讲能力比较差，会特别紧张，不过当谈论到我熟悉的领域时会慢慢放松下来。我也正在锻炼自己这方面的能力，会在公开演讲前会做好充分的准备，并提前演练。</p>
<p>或是：我的缺点是话太多，经常遭到同学的吐槽，我也注意到自己确实太爱急于表达，这样会忽略掉别人的意见，所以我也正在积极改正，试着让自己多去聆听，这样才会让沟通效率得到提高。</p>
<h3 id="你对薪资的要求？"><a href="#你对薪资的要求？" class="headerlink" title="你对薪资的要求？"></a>你对薪资的要求？</h3><p>这是 HR 的一个套路：表面上问工资，实际上问定位。有很多时候，HR 不一定真想知道你的理想工资，只是想了解你对自己的定位，从而得知你的真实水平。</p>
<p><strong>回答提示：</strong> 我对工资没有硬性要求，也觉得能够胜任这份工作，看到贵公司该岗位的薪资标准为 8-10k，也确实在我的考虑范围内。如果非要说一个数字的话，是 9k。</p>
<p>我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我不会计较太多。</p>
<p><strong>看准君小贴士：</strong> 谈薪资时最好别说区间。因为 HR 一定会给到你报价的最低位。若觉得自己没什么竞争优势，建议报成最低价，若觉得还 ok 就取个中间值，若有相关经验、学历背景好，且能够超越其他面试者，可以报成最高价，并说明原因，让公司觉得录用你很超值。</p>
<h3 id="五年内你的职业规划是什么？"><a href="#五年内你的职业规划是什么？" class="headerlink" title="五年内你的职业规划是什么？"></a>五年内你的职业规划是什么？</h3><p>你千万不要说“目前没有什么想法”“不知道”“我也没有想清楚”，HR 喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。</p>
<p><strong>回答提示：</strong> 我在实习过程中发现对某一领域很感兴趣，我思维逻辑能力比较强（结合自身说明），也很适合做何种岗位，目前找工作也都是朝着这个方向去选择，想要在未来的五年时间内能够在这个领域有所作为。</p>
<h3 id="如果我们录用了你，但一段时间后发现你不适合这个职位，怎么办？"><a href="#如果我们录用了你，但一段时间后发现你不适合这个职位，怎么办？" class="headerlink" title="如果我们录用了你，但一段时间后发现你不适合这个职位，怎么办？"></a>如果我们录用了你，但一段时间后发现你不适合这个职位，怎么办？</h3><p>面试官为什么要问这道题呢？他是想知道你是否有责任心、有韧性，从你的回答中同样也能看出，你是否是真心想要应聘这个职位，而不是盲目投递简历：“今天面试销售，明天面试运营，后天面试产品、技术”。</p>
<p><strong>回答提示：</strong> 我会分析是哪里出现了问题，如果是自身能力不足，我会不断向前辈学习、讨教经验，同时自己也会在工作之余，在线上听一些其他大厂大佬们的讲课，尽快调整状态、力争减少差距。</p>
<p>如果面试官深究下去，就接着回答：若是工作了一年多都没有起色，或是发现我更适合某些相关岗位，我会向公司申请内部调岗。</p>
<h3 id="你学的专业不同，为什么不做本行呢？"><a href="#你学的专业不同，为什么不做本行呢？" class="headerlink" title="你学的专业不同，为什么不做本行呢？"></a>你学的专业不同，为什么不做本行呢？</h3><p>思路： 1.最好不要回答自己学习不好</p>
<p>答:当初报考的时候不是很了解这个专业,进了大学之后感觉自己兴趣不在这里,我志不在此。我认为我更擅长这个领域,做起来也会更快乐更有动力,非常希望在这个领域有一番作为。在大学期间我经常去该领域的课程去蹭课。</p>
<h3 id="为什么选择我们公司？"><a href="#为什么选择我们公司？" class="headerlink" title="为什么选择我们公司？"></a>为什么选择我们公司？</h3><p>我十分看好贵公司所在的行业,我认为贵公司十分重视人才,而且这项工作很适合我,相信自己一定能做好。</p>
<h3 id="与上级意见不一致怎么办？"><a href="#与上级意见不一致怎么办？" class="headerlink" title="与上级意见不一致怎么办？"></a>与上级意见不一致怎么办？</h3><p>1.我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。 2.对于非原则性的问题，我会服从上级的意见，对于涉及公司利益的重大问题,我希望能向更高领导反映</p>
<h3 id="我们为什么要录用你？"><a href="#我们为什么要录用你？" class="headerlink" title="我们为什么要录用你？"></a>我们为什么要录用你？</h3><p>我符合贵公司的招聘条件，凭我目前掌握的技能、高度的责任感和良好的适应能力及学习能力 ，完全能胜任这份工作。我十分希望能为贵 公司服务，如果贵公司给我这个机会，我一定能成为贵公司的栋梁！</p>
<h3 id="您在前一家公司的离职原因是什么？"><a href="#您在前一家公司的离职原因是什么？" class="headerlink" title="您在前一家公司的离职原因是什么？"></a>您在前一家公司的离职原因是什么？</h3><p>我离职是因为这家公司倒闭。我在公司工作了三年多，有较深的感情。从去年始，由于市场形势突变，公司的局面急转直下。到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台</p>
<h3 id="你是应届毕业生，缺乏经验，如何能胜任这项工作？"><a href="#你是应届毕业生，缺乏经验，如何能胜任这项工作？" class="headerlink" title="你是应届毕业生，缺乏经验，如何能胜任这项工作？"></a>你是应届毕业生，缺乏经验，如何能胜任这项工作？</h3><p>作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex使用</title>
    <url>/2018/11/02/qian-duan-kuang-jia/01.vue/01.vuex-shi-yong/</url>
    <content><![CDATA[<p>待写….</p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件通信解决方案</title>
    <url>/2019/04/08/qian-duan-kuang-jia/02.reactjs/01.react-zu-jian-tong-xin-jie-jue-fang-an/</url>
    <content><![CDATA[<h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>最近在做 react 开发的时候，需要在多级组件之间进行有效通信。这里所说的多级组件，可能是父子组件、兄弟组件，还可能是两个完全不相关的组件。</p>
<p><strong>那么问题是：有没有一种方法可以统一实现组件之间的通信？不借助 redux 等第三方库，降低依赖性，保证代码简洁，还要保证通用性</strong>。</p>
<h3 id="解决方案：订阅-发布模式"><a href="#解决方案：订阅-发布模式" class="headerlink" title="解决方案：订阅-发布模式"></a>解决方案：订阅-发布模式</h3><p>这里利用“订阅-发布模式”实现一个事件类：Event。它与 <code>window.addEventListener</code>  、 <code>window.removeEventListener</code>  类似。<strong>为了方便演示，Event 的实现放在文章最后，下面将展示在具体场景中的应用。</strong></p>
<p>假设现在有 2 个 react 组件（A 与 B）需要进行通信，组件 A 用户点击后，组件 B 能接收到消息。</p>
<p>组件 A 的大致业务逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Event <span class="keyword">from</span> <span class="string">&#x27;event-proxy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentA &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  	<span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">      	&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">        	被点击的时候, 触发 click-event 事件</span></span><br><span class="line"><span class="comment">          注意: 被触发事件的名称, 需要由两个组件进行约定</span></span><br><span class="line"><span class="comment">        */</span>&#125;</span><br><span class="line">      	&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> Event.trigger(<span class="string">&#x27;click-event&#x27;</span>)&#125;&gt;&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件 B 的大致业务逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Event <span class="keyword">from</span> <span class="string">&#x27;event-proxy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentB &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 监听click-event事件, 并且指定 handleClick 为其处理函数</span></span><br><span class="line">  	Event.on(<span class="string">&#x27;click-event&#x27;</span>, <span class="built_in">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在组件即将卸载的时候, 移除事件监听</span></span><br><span class="line">  	Event.remove(<span class="string">&#x27;click-event&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="string">&#x27;组件A被点击了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贴代码实现"><a href="#贴代码实现" class="headerlink" title="贴代码实现"></a>贴代码实现</h3><p>最后附上<code>event-proxy.js</code>代码的基本实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="built_in">Symbol</span>(<span class="string">&quot;cache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventProxy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[cache] = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定事件key以及它的回调函数fn</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>[cache][key])) &#123;</span><br><span class="line">      <span class="built_in">this</span>[cache][key] = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fns = <span class="built_in">this</span>[cache][key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span> &amp;&amp; !fns.includes(fn)) &#123;</span><br><span class="line">      fns.push(fn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件key的回调函数</span></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="built_in">this</span>[cache][key] || [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">      fn(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件key的回调函数fn</span></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="built_in">this</span>[cache][key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fns) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>[cache][key] = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fns[i] === fn) &#123;</span><br><span class="line">        fns.splice(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[cache] = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>[cache] = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventProxy();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> event;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://godbmw.com/passages/2018-11-18-publish-subscribe-pattern/">设计模式手册之订阅-发布模式</a></li>
<li>淘宝前端团队：<a href="http://taobaofed.org/blog/2016/11/17/react-components-communication/">《React 组件通信》</a></li>
</ul>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React Router 进阶技巧</title>
    <url>/2019/09/11/qian-duan-kuang-jia/02.reactjs/02.reactrouter-jin-jie-ji-qiao/</url>
    <content><![CDATA[<h2 id="在-TypeScript-中使用"><a href="#在-TypeScript-中使用" class="headerlink" title="在 TypeScript 中使用"></a>在 TypeScript 中使用</h2><p>有时候会需要使用编程式导航，比如上方导航栏里面选项，响应按钮事件，进行路由跳转。react 的做法是通过高阶函数，函数体内部向组件的 props 注册一些路由的方法，最后返回一个新的组件。</p>
<p>下面是一个结合 TypeScript 使用 withRouter 的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NavigationState &#123;</span><br><span class="line">  routes: <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">    path: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    key: <span class="built_in">string</span>;</span><br><span class="line">  &#125;&gt;;</span><br><span class="line">  selectedKey: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> NavigationProps &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Navigation</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;</span></span><br><span class="line"><span class="class">  <span class="title">RouteComponentProps</span> &amp; <span class="title">NavigationProps</span>, // 使用「交叉类型」来处理<span class="title">Props</span>的关系</span></span><br><span class="line"><span class="class">  <span class="title">NavigationState</span></span></span><br><span class="line"><span class="class">&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    routes: [],</span><br><span class="line">    selectedKey: <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  toggleRoute = <span class="function">(<span class="params">event: ClickParam</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.history.push(path); <span class="comment">// route的方法已经被注册到了Props上</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Navigation);</span><br></pre></td></tr></table></figure>

<h2 id="严格匹配-exact-和-strict"><a href="#严格匹配-exact-和-strict" class="headerlink" title="严格匹配: exact 和 strict"></a>严格匹配: exact 和 strict</h2><p><code>exact</code>已经关闭了模糊匹配。那么<code>strict</code>设置为<code>true</code>（默认是<code>false</code>），会有什么区别呢。例如 path 为 <code>/a</code>的时候：</p>
<ul>
<li>两个 prop 均为<code>true</code>：不匹配<code>/a/</code>，只匹配<code>/a</code></li>
<li>strict 为 false：<code>/a/</code>和<code>/a</code>均匹配</li>
</ul>
<h2 id="路由配置化"><a href="#路由配置化" class="headerlink" title="路由配置化"></a>路由配置化</h2><p>可以直接使用 react-router-config 组件，实现原理：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch, SwitchProps, RouteProps &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRoutes</span>(<span class="params">params: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  routes: RouteProps[];</span></span></span><br><span class="line"><span class="function"><span class="params">  switchProps?: SwitchProps;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; switchProps, routes &#125; = params;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Switch &#123;...switchProps&#125;&gt;</span><br><span class="line">      &#123;routes.map(<span class="function">(<span class="params">route, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;Route</span><br><span class="line">          key=&#123;index&#125;</span><br><span class="line">          path=&#123;route.path&#125;</span><br><span class="line">          component=&#123;route.component&#125;</span><br><span class="line">          exact=&#123;route.exact || <span class="literal">true</span>&#125;</span><br><span class="line">          strict=&#123;route.strict || <span class="literal">false</span>&#125;</span><br><span class="line">        &gt;&lt;/Route&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们的路由如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouteProps &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config: RouteProps[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    component: HomePage</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    component: UserPage</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="路由变化响应"><a href="#路由变化响应" class="headerlink" title="路由变化响应"></a>路由变化响应</h2><p>在 VueJS 技术栈中，vue-router 是提供路由响应的钩子函数，例如：<code>beforeEach</code>、<code>afterEach</code>等等。</p>
<p>但是在 React 中，react-router 并不提供相关的钩子函数。<strong>那么如果有顶部导航栏，不同页面切换时，高亮不同的标签，那么应该怎么实现响应路由变化呢</strong>？</p>
<p>首先即使是路由，在 React 中，它也是一个组件对象。因此，如果要更新试图，必须触发组件的 render。而触发组件的关键在于，props 发生改变。</p>
<p>第一步：需要使用<code>withRouter</code>来包装对应的组件，将路由的信息作为 props 注入组件，比如顶部导航栏。</p>
<p>第二步：下面是 React17 前后的简单例子。</p>
<p>React17 之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter, RouteComponentProps &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Navigation</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">RouteComponentProps</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    selectedPath: <span class="string">&quot;/&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在componentWillReceiveProps中接受新的props</span></span><br><span class="line">  <span class="comment">// 决定是否更新state</span></span><br><span class="line">  <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps: RouteComponentProps</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.location.pathname === <span class="built_in">this</span>.props.location.pathname) &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123; <span class="attr">selectedPath</span>: nextProps.location.pathname &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的render渲染，取决于state是否更新</span></span><br><span class="line">    <span class="keyword">const</span> &#123; selectedPath &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>导航栏选中信息：&#123;selectedPath&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Navigation);</span><br></pre></td></tr></table></figure>

<p>在 React17 之后，不推荐使用<code>componentWillReceiveProps</code>等不确定的生命周期。处理的思路是：render 函数返回的视图中，变量的变化依赖 props 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter, RouteComponentProps &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Navigation</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">RouteComponentProps</span>, <span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    paths: [<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/a&quot;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = <span class="built_in">this</span>.props.location;</span><br><span class="line">    <span class="keyword">const</span> &#123; paths &#125; = <span class="built_in">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> selectedPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    paths.some(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (path === pathname) &#123;</span><br><span class="line">        selectedPath = path;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>导航栏选中信息：&#123;selectedPath&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Navigation);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>一文彻底搞懂react hooks的原理和实现</title>
    <url>/2019/10/21/qian-duan-kuang-jia/02.reactjs/03.yi-wen-che-di-gao-dong-reacthooks-de-yuan-li-he-shi-xian/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>当使用 Hook 特性编写组件的时候时候，总能感觉到它的简洁和方便。当然，「天下没有免费的午餐」，它牺牲了可读性并且存在内存泄漏风险（最后有提到）。但这并不妨碍探索它的魔力。</p>
<p>在正式开始前，希望您读过 Hook 的文档或者在项目使用过它。但如果只对函数编程感兴趣，也可能有所收获。</p>
<p>为了让行文更流畅，我打算先抛出几个问题，这些问题会在源码实现的过程中，逐步解决：</p>
<ul>
<li>🤔️ useState 的实现原理</li>
<li>🤔️ 为什么不能在循环、判断内部使用 Hook</li>
<li>🤔️ useEffect 的实现原理</li>
<li>🤔️ useEffect 的应用场景</li>
<li>🤔️ <code>Class</code> vs <code>Hooks</code></li>
</ul>
<p>⚠️ 代码均由<code>TypeScript</code>来实现，文中全部 demos 均在 <a href="https://gist.github.com/dongyuanxin/4281ee21eafdc0197d6ddea27bfbdbfd">gist.github.com/dongyuanxin/</a></p>
<h2 id="useState-的实现原理"><a href="#useState-的实现原理" class="headerlink" title="useState 的实现原理"></a>useState 的实现原理</h2><p>当调用 useState 的时候，会返回形如 <code>(变量, 函数)</code> 的一个元祖。并且 state 的初始值就是外部调用 useState 的时候，传入的参数。</p>
<p>理清楚了传参和返回值，再来看下 useState 还做了些什么。正如下面代码所示，当点击按钮的时候，执行<code>setNum</code>，状态 num 被更新，<strong>并且 UI 视图更新</strong>。显然，useState 返回的用于更改状态的函数，自动调用了<code>render</code>方法来触发视图更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num + <span class="number">1</span>)&#125;&gt;加 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的探索，借助闭包，封装一个 <code>setState</code> 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> state: any;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialState: T</span>): [<span class="title">T</span>, (<span class="params">newState: T</span>) =&gt; <span class="title">void</span>] </span>&#123;</span><br><span class="line">  state = state || initialState;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState: T</span>) </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(); <span class="comment">// 首次渲染</span></span><br></pre></td></tr></table></figure>

<p>这是一个简易能用的<code>useState</code>雏形了。它也解决了文章开始提到的「🤔️ useState 的实现原理」这个问题。但如果在函数内声明多个 state，在当前代码中，只有第一个 state 是生效的(请看<code>state = state || initialState;</code>))。</p>
<h2 id="为什么不能在循环、判断内部使用-Hook"><a href="#为什么不能在循环、判断内部使用-Hook" class="headerlink" title="为什么不能在循环、判断内部使用 Hook"></a>为什么不能在循环、判断内部使用 Hook</h2><p>先不要考虑题目提及的问题。思路还是回到如何让 useState 支持多个 state。<a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">《React hooks: not magic, just arrays》</a>中提及，React Hook 看起来非常 Magic 的实现，本质上还是通过 Array 来实现的。</p>
<p>前面 useState 的简单实现里，初始的状态是保存在一个全局变量中的。以此类推，多个状态，应该是保存在一个专门的全局容器中。这个容器，就是一个朴实无华的 Array 对象。具体过程如下：</p>
<ul>
<li>第一次渲染时候，根据 useState 顺序，逐个声明 state 并且将其放入全局 Array 中。每次声明 state，都要将 cursor 增加 1。</li>
<li>更新 state，触发再次渲染的时候。<strong>cursor 被重置为 0</strong>。按照 useState 的声明顺序，依次拿出最新的 state 的值，视图更新。</li>
</ul>
<p>请看下面这张图，每次使用 useState，都会向 STATE 容器中添加新的状态。</p>
<p><img src="https://miro.medium.com/max/1260/1*8TpWnrL-Jqh7PymLWKXbWg.png"></p>
<p>实现的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> states: any[] = [];</span><br><span class="line"><span class="keyword">let</span> cursor: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialState: T</span>): [<span class="title">T</span>, (<span class="params">newState: T</span>) =&gt; <span class="title">void</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> currenCursor = cursor;</span><br><span class="line">  states[currenCursor] = states[currenCursor] || initialState; <span class="comment">// 检查是否渲染过</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState: T</span>) </span>&#123;</span><br><span class="line">    states[currenCursor] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++cursor; <span class="comment">// update: cursor</span></span><br><span class="line">  <span class="keyword">return</span> [states[currenCursor], setState];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> [num2, setNum2] = useState &lt; number &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num + <span class="number">1</span>)&#125;&gt;加 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num - <span class="number">1</span>)&#125;&gt;减 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;div&gt;num2: &#123;num2&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum2(num2 * <span class="number">2</span>)&#125;&gt;扩大一倍&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum2(num2 / <span class="number">2</span>)&#125;&gt;缩小一倍&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">  cursor = <span class="number">0</span>; <span class="comment">// 重置cursor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(); <span class="comment">// 首次渲染</span></span><br></pre></td></tr></table></figure>

<p>此时，如果想在循环、判断等不在函数组件顶部的地方使用 Hook，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有初次渲染，才执行</span></span><br><span class="line">  <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">const</span> [unusedNum] = useState &lt; number &gt; <span class="number">1</span>;</span><br><span class="line">    tag = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [num2, setNum2] = useState &lt; number &gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num + <span class="number">1</span>)&#125;&gt;加 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num - <span class="number">1</span>)&#125;&gt;减 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;div&gt;num2: &#123;num2&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum2(num2 * <span class="number">2</span>)&#125;&gt;扩大一倍&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum2(num2 / <span class="number">2</span>)&#125;&gt;缩小一倍&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在条件判断的逻辑中，重置了<code>tag=false</code>，因此此后的渲染不会再进入条件判断语句。看起来好像没有问题？但是，由于 useState 是基于 Array+Cursor 来实现的，第一次渲染时候，state 和 cursor 的对应关系如下表：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>cursor</th>
</tr>
</thead>
<tbody><tr>
<td>num</td>
<td>0</td>
</tr>
<tr>
<td>unusedNum</td>
<td>1</td>
</tr>
<tr>
<td>num2</td>
<td>2</td>
</tr>
</tbody></table>
<p>当点击事件触发再次渲染，并不会进入条件判断中的 useState。所以，cursor=2 的时候对应的变量是 num2。而其实 num2 对应的 cursor 应该是 3。就会导致<code>setNum2</code>并不起作用。</p>
<p>到此，解决了文章开头提出的「🤔️ 为什么不能在循环、判断内部使用 Hook」。在使用 Hook 的时候，请在函数组件顶部使用！</p>
<h2 id="useEffect-的实现原理"><a href="#useEffect-的实现原理" class="headerlink" title="useEffect 的实现原理"></a>useEffect 的实现原理</h2><p>在探索 useEffect 原理的时候，一直被一个问题困扰：useEffect 作用和用途是什么？当然，用于函数的副作用这句话谁都会讲。举个例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求后端数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setNum(num + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;!num ? &quot;请求后端数据...&quot; : `后端数据是 $&#123;num&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。<strong>但这并不是必要的</strong>。完全可以不使用<code>useEffect</code>，直接使用<code>setTimeout</code>，并且它的回调函数中更新函数组件的 state。</p>
<p>在阅读<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">A Complete Guide to useEffect</a>和<a href="http://react.html.cn/docs/hooks-custom.html">构建你自己的 Hooks</a>之后，我才理解 useEffect 的存在的必要性和意义。</p>
<p>在 useEffect 的第二个参数中，我们可以指定一个数组，如果下次渲染时，数组中的元素没变，那么就不会触发这个副作用（可以类比 Class 类的关于 nextprops 和 prevProps 的生命周期）。好处显然易见，<strong>相比于直接裸写在函数组件顶层，useEffect 能根据需要，避免多余的 render</strong>。</p>
<p>下面是一个不包括销毁副作用功能的 useEffect 的 TypeScript 实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还是利用 Array + Cursor的思路</span></span><br><span class="line"><span class="keyword">const</span> allDeps: any[][] = [];</span><br><span class="line"><span class="keyword">let</span> effectCursor: number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback: () =&gt; <span class="keyword">void</span>, deps: any[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!allDeps[effectCursor]) &#123;</span><br><span class="line">    <span class="comment">// 初次渲染：赋值 + 调用回调函数</span></span><br><span class="line">    allDeps[effectCursor] = deps;</span><br><span class="line">    ++effectCursor;</span><br><span class="line">    callback();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currenEffectCursor = effectCursor;</span><br><span class="line">  <span class="keyword">const</span> rawDeps = allDeps[currenEffectCursor];</span><br><span class="line">  <span class="comment">// 检测依赖项是否发生变化，发生变化需要重新render</span></span><br><span class="line">  <span class="keyword">const</span> isChanged = rawDeps.some(</span><br><span class="line">    (dep: any, <span class="attr">index</span>: number) =&gt; dep !== deps[index]</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (isChanged) &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">  ++effectCursor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">  effectCursor = <span class="number">0</span>; <span class="comment">// 注意将 effectCursor 重置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 useEffect 的实现，配合下面案例的使用会更容易理解。当然，你也可以在这个 useEffect 中发起异步请求，并在接受数据后，调用 state 的更新函数，不会发生爆栈的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> [num2] = useState &lt; number &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 多次触发</span></span><br><span class="line">  <span class="comment">// 每次点击按钮，都会触发 setNum 函数</span></span><br><span class="line">  <span class="comment">// 副作用检测到 num 变化，会自动调用回调函数</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;num update: &quot;</span>, num);</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅第一次触发</span></span><br><span class="line">  <span class="comment">// 只会在compoentDidMount时，触发一次</span></span><br><span class="line">  <span class="comment">// 副作用函数不会多次执行</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;num2 update: &quot;</span>, num2);</span><br><span class="line">  &#125;, [num2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num + <span class="number">1</span>)&#125;&gt;加 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> setNum(num - <span class="number">1</span>)&#125;&gt;减 <span class="number">1</span>&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ useEffect 第一个回调函数可以返回一个用于销毁副作用的函数，相当于 Class 组件的 unmount 生命周期。这里为了方便说明，没有进行实现。</p>
<p>在这一小节中，尝试解答了 「🤔️ useEffect 的实现原理」和 「🤔️ useEffect 的应用场景」这两个问题。</p>
<h2 id="Class-VS-Hooks"><a href="#Class-VS-Hooks" class="headerlink" title="Class VS Hooks"></a>Class VS Hooks</h2><p>虽然 Hooks 看起来更酷炫，更简洁。但是在实际开发中我更倾向于使用 Class 来声明组件。两种方法的对比如下：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Hooks</th>
</tr>
</thead>
<tbody><tr>
<td>代码逻辑清晰（构造函数、componentDidMount 等）</td>
<td>需要配合变量名和注释</td>
</tr>
<tr>
<td>不容易内存泄漏</td>
<td>容易发生内存泄漏</td>
</tr>
</tbody></table>
<p>总的来说，Hooks 对代码编写的要求较高，在没有有效机制保证代码可读性、规避风险的情况下，Class 依然是我的首选。关于内存泄漏，下面是一个例子（目前还没找到方法规避这种向全局传递状态更新函数的做法）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func: any;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">typeof</span> func === <span class="string">&quot;function&quot;</span> &amp;&amp; func(<span class="built_in">Date</span>.now());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;interval&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    func = setNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a></li>
<li><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">A Complete Guide to useEffect</a></li>
<li><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></li>
<li><a href="https://github.com/brickspert/blog/issues/26">React Hooks 原理</a>: <code>useEffect</code>实现有问题，回调函数调用 state 的更新函数，会爆栈</li>
</ul>
<p>文章中多有见解不到当之处，欢迎讨论和指正。</p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>一文说清「VirtualDOM」的含义与实现</title>
    <url>/2019/11/11/qian-duan-kuang-jia/02.reactjs/04.yi-wen-shuo-qing-virtualdom-de-han-yi-yu-shi-xian/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>随着 React 的兴起，Virtual DOM 的原理和实现也开始出现在各大厂面试和社区的文章中。其实这种做法早在 <code>d3.js</code> 中就有实现，是 react 生态的快速建立让它正式进入了广大开发者的视角。</p>
<p>在正式开始前，抛出几个问题来引导思路，这些问题也会在不同的小节中，逐步解决：</p>
<ul>
<li>🤔️ 怎么理解 VDom？</li>
<li>🤔️ 如何表示 VDom？</li>
<li>🤔️ 如何比较 VDom 树，并且进行高效更新？</li>
</ul>
<p>⚠️ 整理后的代码和效果图均存放在<a href="https://github.com/dongyuanxin/pure-virtual-dom">github.com/dongyuanxin</a>。</p>
<h2 id="如何理解-VDom？"><a href="#如何理解-VDom？" class="headerlink" title="如何理解 VDom？"></a>如何理解 VDom？</h2><p>曾经，前端常做的事情就是根据数据状态的更新，来更新界面视图。大家逐渐意识到，对于复杂视图的界面，<strong>频繁地更新 DOM</strong>，会造成回流或者重绘，引发性能下降，页面卡顿。</p>
<p><strong>因此，我们需要方法避免频繁地更新 DOM 树</strong>。思路也很简单，即：对比 DOM 的差距，只更新需要部分节点，而不是更新一棵树。而实现这个算法的基础，就需要遍历 DOM 树的节点，来进行比较更新。</p>
<p>为了处理更快，不使用 DOM 对象，而是用 JS 对象来表示，<strong>它就像是 JS 和 DOM 之间的一层缓存</strong>。</p>
<h2 id="如何表示-VDom？"><a href="#如何表示-VDom？" class="headerlink" title="如何表示 VDom？"></a>如何表示 VDom？</h2><p>借助 ES6 的 class，表示 VDom 语义化更强。一个基础的 VDom 需要有标签名、标签属性以及子节点，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">tagName, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tagName = tagName;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">    <span class="built_in">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更方便调用（不用每次都写<code>new</code>），将其封装返回实例的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">el</span>(<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果想表达下面的 DOM 结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用 VDom 就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子节点数组的元素可以是文本，也可以是VDom实例</span></span><br><span class="line"><span class="keyword">const</span> span = el(<span class="string">&quot;span&quot;</span>, &#123;&#125;, [<span class="string">&quot;span1&quot;</span>]);</span><br><span class="line"><span class="keyword">const</span> div = el(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;test&quot;</span> &#125;, [span]);</span><br></pre></td></tr></table></figure>

<p>之后在对比和更新两棵 VDom 树的时候，会涉及到将 VDom 渲染成真正的 Dom 节点。因此，为<code>class Element</code>增加<code>render</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">tagName, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.tagName = tagName;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">    <span class="built_in">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName);</span><br><span class="line">    <span class="comment">// 设置标签属性值</span></span><br><span class="line">    <span class="built_in">Reflect</span>.ownKeys(<span class="built_in">this</span>.props).forEach(<span class="function"><span class="params">name</span> =&gt;</span></span><br><span class="line">      dom.setAttribute(name, <span class="built_in">this</span>.props[name])</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归更新子节点</span></span><br><span class="line">    <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> childDom =</span><br><span class="line">        child <span class="keyword">instanceof</span> Element</span><br><span class="line">          ? child.render()</span><br><span class="line">          : <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">      dom.appendChild(childDom);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dom;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何比较-VDom-树，并且进行高效更新？"><a href="#如何比较-VDom-树，并且进行高效更新？" class="headerlink" title="如何比较 VDom 树，并且进行高效更新？"></a>如何比较 VDom 树，并且进行高效更新？</h2><p>前面已经说明了 VDom 的用法与含义，多个 VDom 就会组成一棵虚拟的 DOM 树。剩下需要做的就是：<strong>根据不同的情况，来进行树上节点的增删改的操作</strong>。这个过程是分为<code>diff</code>和<code>patch</code>：</p>
<ul>
<li>diff：递归对比两棵 VDom 树的、对应位置的节点差异</li>
<li>patch：根据不同的差异，进行节点的更新</li>
</ul>
<p>目前有两种思路，一种是先 diff 一遍，记录所有的差异，再统一进行 patch；<strong>另外一种是 diff 的同时，进行 patch</strong>。相较而言，第二种方法少了一次递归查询，以及不需要构造过多的对象，下面采取的是第二种思路。</p>
<h3 id="变量的含义"><a href="#变量的含义" class="headerlink" title="变量的含义"></a>变量的含义</h3><p>将 diff 和 patch 的过程，放入<code>updateEl</code>方法中，这个方法的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;HTMLElement&#125;</span> <span class="variable">$parent</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Element&#125;</span> <span class="variable">newNode</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Element&#125;</span> <span class="variable">oldNode</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">$parent, newNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有以<code>$</code>开头的变量，代表着<strong>真实的 DOM</strong>。</p>
<p>参数<code>index</code>表示<code>oldNode</code>在<code>$parent</code>的所有子节点构成的数组的下标位置。</p>
<h3 id="情况-1：新增节点"><a href="#情况-1：新增节点" class="headerlink" title="情况 1：新增节点"></a>情况 1：新增节点</h3><p>如果 oldNode 为 undefined，说明 newNode 是一个新增的 DOM 节点。直接将其追加到 DOM 节点中即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">$parent, newNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    $parent.appendChild(newNode.render());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况-2：删除节点"><a href="#情况-2：删除节点" class="headerlink" title="情况 2：删除节点"></a>情况 2：删除节点</h3><p>如果 newNode 为 undefined，说明新的 VDom 树中，当前位置没有节点，因此需要将其从实际的 DOM 中删除。删除就调用<code>$parent.removeChild()</code>，通过<code>index</code>参数，可以拿到被删除元素的引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">$parent, newNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    $parent.appendChild(newNode.render());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    $parent.removeChild($parent.childNodes[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况-3：变化节点"><a href="#情况-3：变化节点" class="headerlink" title="情况 3：变化节点"></a>情况 3：变化节点</h3><p>对比 oldNode 和 newNode，有 3 种情况，均可视为改变：</p>
<ol>
<li>节点类型发生变化：文本变成 vdom；vdom 变成文本</li>
<li>新旧节点都是文本，内容发生改变</li>
<li>节点的属性值发生变化</li>
</ol>
<p>首先，借助<code>Symbol</code>更好地语义化声明这三种变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CHANGE_TYPE_TEXT = <span class="built_in">Symbol</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CHANGE_TYPE_PROP = <span class="built_in">Symbol</span>(<span class="string">&quot;props&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CHANGE_TYPE_REPLACE = <span class="built_in">Symbol</span>(<span class="string">&quot;replace&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>针对节点属性发生改变，没有现成的 api 供我们批量更新。因此封装<code>replaceAttribute</code>，将新 vdom 的属性直接映射到 dom 结构上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceAttribute</span>(<span class="params">$node, removedAttrs, newAttrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!$node) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(removedAttrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> $node.removeAttribute(attr));</span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newAttrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span></span><br><span class="line">    $node.setAttribute(attr, newAttrs[attr])</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写<code>checkChangeType</code>函数判断变化的类型；如果没有变化，则返回空：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkChangeType</span>(<span class="params">newNode, oldNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> newNode !== <span class="keyword">typeof</span> oldNode ||</span><br><span class="line">    newNode.tagName !== oldNode.tagName</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> CHANGE_TYPE_REPLACE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newNode === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode !== oldNode) &#123;</span><br><span class="line">      <span class="keyword">return</span> CHANGE_TYPE_TEXT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> propsChanged = <span class="built_in">Reflect</span>.ownKeys(newNode.props).reduce(</span><br><span class="line">    (prev, name) =&gt; prev || oldNode.props[name] !== newNode.props[name],</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (propsChanged) &#123;</span><br><span class="line">    <span class="keyword">return</span> CHANGE_TYPE_PROP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>updateEl</code>中，根据<code>checkChangeType</code>返回的变化类型，做对应的处理。如果类型为空，则不进行处理。具体逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">$parent, newNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changeType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    $parent.appendChild(newNode.render());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    $parent.removeChild($parent.childNodes[index]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((changeType = checkChangeType(newNode, oldNode))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changeType === CHANGE_TYPE_TEXT) &#123;</span><br><span class="line">      $parent.replaceChild(</span><br><span class="line">        <span class="built_in">document</span>.createTextNode(newNode),</span><br><span class="line">        $parent.childNodes[index]</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changeType === CHANGE_TYPE_REPLACE) &#123;</span><br><span class="line">      $parent.replaceChild(newNode.render(), $parent.childNodes[index]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changeType === CHANGE_TYPE_PROP) &#123;</span><br><span class="line">      replaceAttribute($parent.childNodes[index], oldNode.props, newNode.props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="情况-4：递归对子节点执行-Diff"><a href="#情况-4：递归对子节点执行-Diff" class="headerlink" title="情况 4：递归对子节点执行 Diff"></a>情况 4：递归对子节点执行 Diff</h3><p>如果情况 1、2、3 都没有命中，那么说明当前新旧节点自身没有变化。此时，需要遍历它们（Virtual Dom）的<code>children</code>数组（Dom 子节点），递归进行处理。</p>
<p>代码实现非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEl</span>(<span class="params">$parent, newNode, oldNode, index = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changeType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    $parent.appendChild(newNode.render());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    $parent.removeChild($parent.childNodes[index]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((changeType = checkChangeType(newNode, oldNode))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (changeType === CHANGE_TYPE_TEXT) &#123;</span><br><span class="line">      $parent.replaceChild(</span><br><span class="line">        <span class="built_in">document</span>.createTextNode(newNode),</span><br><span class="line">        $parent.childNodes[index]</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changeType === CHANGE_TYPE_REPLACE) &#123;</span><br><span class="line">      $parent.replaceChild(newNode.render(), $parent.childNodes[index]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changeType === CHANGE_TYPE_PROP) &#123;</span><br><span class="line">      replaceAttribute($parent.childNodes[index], oldNode.props, newNode.props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tagName) &#123;</span><br><span class="line">    <span class="keyword">const</span> newLength = newNode.children.length;</span><br><span class="line">    <span class="keyword">const</span> oldLength = oldNode.children.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newLength || i &lt; oldLength; ++i) &#123;</span><br><span class="line">      updateEl(</span><br><span class="line">        $parent.childNodes[index],</span><br><span class="line">        newNode.children[i],</span><br><span class="line">        oldNode.children[i],</span><br><span class="line">        i</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果观察"><a href="#效果观察" class="headerlink" title="效果观察"></a>效果观察</h2><p>将<a href="https://github.com/dongyuanxin/pure-virtual-dom">github.com/dongyuanxin/pure-virtual-dom</a>的代码 clone 到本地，Chrome 打开<code>index.html</code>。</p>
<p>新增 dom 节点.gif:</p>
<p><img src="https://raw.githubusercontent.com/dongyuanxin/pure-virtual-dom/master/public/1.gif"></p>
<p>更新文本内容.gif：</p>
<p><img src="https://raw.githubusercontent.com/dongyuanxin/pure-virtual-dom/master/public/2.gif"></p>
<p>更改节点属性.gif：</p>
<p><img src="https://raw.githubusercontent.com/dongyuanxin/pure-virtual-dom/master/public/3.gif"></p>
<p>⚠️ 网速较慢的同学请移步 github 仓库</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060">How to write your own Virtual DOM</a></li>
</ul>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>微信网页登录逻辑与实现</title>
    <url>/2019/04/15/qian-duan-kuang-jia/03.wx-xiao-cheng-xu/wei-xin-wang-ye-deng-lu-luo-ji-yu-shi-xian/</url>
    <content><![CDATA[<p>现在的网站开发，都绕不开微信登录（毕竟微信已经成为国民工具）。虽然文档已经写得很详细，但是对于没有经验的开发者还是容易踩坑。</p>
<p>所以，专门记录一下微信网页认证的交互逻辑，也方便自己日后回查：</p>
<ol>
<li>加载微信网页 sdk</li>
<li>绘制登陆二维码：新 tab 页面绘制 / 本页面 iframe 绘制</li>
<li>用户扫码登陆，前端跳入回调网址</li>
<li>回调网址进一步做逻辑处理，如果是页内 iframe 绘制二维码，需要通知顶级页</li>
</ol>
<h3 id="微信网页-SDK-加载"><a href="#微信网页-SDK-加载" class="headerlink" title="微信网页 SDK 加载"></a>微信网页 SDK 加载</h3><p>在多人团队协作中，加载资源的代码需要格外小心。因为可能会有多个开发者在同一业务逻辑下调用，这会造成资源的重复加载。</p>
<p>处理方法有两种，第一种是对外暴露多余接口，专门 check 是否重复加载。但是考虑到调用者每次在加载前，都需要显式调用<code>check()</code>方法进行检查，难免会有遗漏。</p>
<p>所以采用第二种方法–设计模式中的缓存模式，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录模式: 防止重复加载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loadWeChatJs = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> exists = <span class="literal">false</span>; <span class="comment">// 打点</span></span><br><span class="line">  <span class="keyword">const</span> src = <span class="string">&quot;//res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js&quot;</span>; <span class="comment">// 微信sdk网址</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 防止重复加载</span></span><br><span class="line">      <span class="keyword">if</span> (exists) <span class="keyword">return</span> resolve(<span class="built_in">window</span>.WxLogin);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">      script.src = src;</span><br><span class="line">      script.type = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">      script.onerror = reject; <span class="comment">// <span class="doctag">TODO:</span> 失败时候, 可以移除script标签</span></span><br><span class="line">      script.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        exists = <span class="literal">true</span>;</span><br><span class="line">        resolve(<span class="built_in">window</span>.WxLogin);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="绘制登陆二维码"><a href="#绘制登陆二维码" class="headerlink" title="绘制登陆二维码"></a>绘制登陆二维码</h3><p>根据<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419316505&token=&lang=zh_CN">《微信登陆开发指南》</a>，将参数传递给<code>window.WxLogin()</code>即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微信默认配置</span></span><br><span class="line"><span class="keyword">const</span> baseOption = &#123;</span><br><span class="line">  self_redirect: <span class="literal">true</span>, <span class="comment">// true: 页内iframe跳转; false: 新标签页打开</span></span><br><span class="line">  id: <span class="string">&quot;wechat-container&quot;</span>,</span><br><span class="line">  appid: <span class="string">&quot;wechat-appid&quot;</span>,</span><br><span class="line">  scope: <span class="string">&quot;snsapi_login&quot;</span>,</span><br><span class="line">  redirect_uri: <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;//1.1.1.1/&quot;</span>),</span><br><span class="line">  state: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loadQRCode = <span class="function">(<span class="params">option, intl = <span class="literal">false</span>, width, height</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _option = &#123; ...baseOption, ...option &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.WxLogin(_option);</span><br><span class="line">      <span class="keyword">const</span> ele = <span class="built_in">document</span>.getElementById(_option[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">      <span class="keyword">const</span> iframe = ele.querySelector(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">      iframe.width = width ? width : <span class="string">&quot;300&quot;</span>;</span><br><span class="line">      iframe.height = height ? height : <span class="string">&quot;420&quot;</span>;</span><br><span class="line">      <span class="comment">// 处理国际化</span></span><br><span class="line">      intl &amp;&amp; (iframe.src = iframe.src + <span class="string">&quot;&amp;lang=en&quot;</span>);</span><br><span class="line">      resolve(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在需要使用的业务组件中，可以在周期函数<code>componentDidMount</code>调用，下面是 demo 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wxOption = &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">	loadWeChatJs()</span><br><span class="line">		.then(<span class="function"><span class="params">WxLogin</span> =&gt;</span> loadQRCode(wxOption))</span><br><span class="line">		.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调网址与-iframe-通信"><a href="#回调网址与-iframe-通信" class="headerlink" title="回调网址与 iframe 通信"></a>回调网址与 iframe 通信</h3><p>这一块我觉得是微信登陆交互中最复杂和难以理解的一段逻辑。开头有讲过，微信二维码渲染有 2 中方式，一种是打开新的标签页，另一种是在指定 id 的容器中插入 iframe。</p>
<p>毫无疑问，第二种交互方式更友好，因为要涉及不同级层的页面通信，代码处理也更具挑战。</p>
<p>为了方便说明，请先看模拟的数据配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redirect 地址会被后端拿到, 后端重定向到此地址, 前端会访问此页面</span></span><br><span class="line"><span class="comment">// redirect 地址中的参数, 是前端人员留给自己使用的; 后端会根据业务需要, 添加更多的字段, 然后一起返回前端</span></span><br><span class="line"><span class="keyword">const</span> querystr =</span><br><span class="line">  <span class="string">&quot;?&quot;</span> +</span><br><span class="line">  stringify(&#123;</span><br><span class="line">    redirect: <span class="built_in">encodeURIComponent</span>(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.location.origin&#125;</span>/account/redirect?`</span> +</span><br><span class="line">        stringify(&#123;</span><br><span class="line">          to: <span class="built_in">encodeURIComponent</span>(<span class="built_in">window</span>.location.origin),</span><br><span class="line">          origin: <span class="built_in">encodeURIComponent</span>(<span class="built_in">window</span>.location.origin),</span><br><span class="line">          state: <span class="string">&quot;login&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ),</span><br><span class="line">    type: <span class="string">&quot;login&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wxOption = &#123;</span><br><span class="line">  id: <span class="string">&quot;wechat-container&quot;</span>,</span><br><span class="line">  self_redirect: <span class="literal">true</span>,</span><br><span class="line">  redirect_uri: <span class="built_in">encodeURIComponent</span>(</span><br><span class="line">    <span class="string">`//1.1.1.1/api/socials/weixin/authorizations<span class="subst">$&#123;querystr&#125;</span>`</span></span><br><span class="line">  ) <span class="comment">// 微信回调请求地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="前后端、微信服务器、用户端交互逻辑"><a href="#前后端、微信服务器、用户端交互逻辑" class="headerlink" title="前后端、微信服务器、用户端交互逻辑"></a>前后端、微信服务器、用户端交互逻辑</h3><p>按照上面的配置，我描述一下前端、用户端、微信服务器和后端交互的逻辑：</p>
<ol>
<li>前端根据 wxOption 加载了二维码，所有信息都放在了二维码中。同时监听微信服务器的消息。</li>
<li>用户手机扫码，通知微信服务器确定登陆。</li>
<li>微信服务器接受到用户的扫码请求，转发给前端。</li>
<li>前端收到微信服务器传来消息，根据 wxOption 的 redirect_uri 参数，跳转到此 url 地址。注意：</li>
</ol>
<ul>
<li>这个接口地址是后端的，请求方式是 GET</li>
<li>前端通过拼接 params 携带参数</li>
<li>地址会被拼接微信服务器传来的一个临时 token，用于交给后端换取用户公众密钥</li>
</ul>
<ol start="5">
<li>后端接收到<code>/api/socials/weixin/authorizations$&#123;querystr&#125;</code>的请求，decode 解码 querystr 中的信息。然后向微信服务端请求用户公众密钥。根绝前后端的约定（demo 中用的是 redirect 字段），重定向到前端指定的 redirect 字段，并且拼接用户公众密钥等更多信息。</li>
<li>前端知悉重定向，跳到重定向的路由（demo 中用的是/account/redirect）</li>
<li>在对应的路由处理后端传来的用户密钥等数据即可</li>
<li>至此，微信认证的四端交互逻辑完成</li>
</ol>
<h3 id="跨-Iframe-通信"><a href="#跨-Iframe-通信" class="headerlink" title="跨 Iframe 通信"></a>跨 Iframe 通信</h3><p>前面流程走完了，现在的情况是页面中 iframe 的二维码区域，已经被替换成了<code>/account/redirect?...</code>的内容。</p>
<p>为了实现通信，需要在页面的周期中监听<code>message</code>事件，并在组件卸载时，卸载此事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="built_in">this</span>.msgReceive, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="built_in">this</span>.msgReceive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">msgReceive</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 监测是否是安全iframe</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">!event.isTrusted</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data); <span class="comment">// 获取iframe中传来的数据, 进一步进行逻辑处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>/account/redirect?...</code>路由对应的组件中，我们需要解析路由中的 params 参数，按照业务逻辑检查后，将结果传递给前面的页面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// step1: 获取url中params参数</span></span><br><span class="line">    <span class="keyword">const</span> querys = getQueryVariable(<span class="built_in">this</span>.props.location.search);</span><br><span class="line">    <span class="comment">// step2: 检查querys中的数据是否符合要求 ...</span></span><br><span class="line">    <span class="comment">// step3: 向顶级页面传递消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.parent &amp;&amp; <span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，微信网页认证的流程完成。</p>
<p><em>更多：关于 iframe 通信的更多细节，请查看 MDN 的文档</em></p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>border-sizing属性详解和应用</title>
    <url>/2018/06/05/ui-she-ji/01.css3/01.border-sizing-shu-xing-xiang-jie-he-ying-yong/</url>
    <content><![CDATA[<blockquote>
<p><code>box-sizing</code>用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。它有<code>content-box</code>、<code>border-box</code>和<code>inherit</code>三种取值。<code>inherit</code>指的是从父元素继承<code>box-sizing</code>表现形式，不再冗赘。</p>
</blockquote>
<h2 id="1-属性讲解"><a href="#1-属性讲解" class="headerlink" title="1. 属性讲解"></a>1. 属性讲解</h2><h4 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a><code>content-box</code></h4><p>默认值，也是 css2.1 中的盒子模型。在计算<code>width</code>和<code>height</code>时候，不计算<code>border</code>、<code>padding</code>和<code>margin</code>。<strong>高度、宽度都只是内容高度</strong>。</p>
<h4 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a><code>border-box</code></h4><p><code>css3</code>新增。 <code>width</code>和<code>height</code>属性包括内容，内边距和边框，但不包括外边距。</p>
<p><strong>计算公式：</strong></p>
<ol>
<li>width = width = border + padding + 内容宽度</li>
<li>height = border + padding + 内容高度</li>
</ol>
<h2 id="2-考虑盒子模型的margin"><a href="#2-考虑盒子模型的margin" class="headerlink" title="2. 考虑盒子模型的margin"></a>2. 考虑盒子模型的<code>margin</code></h2><p>从上面可以知道，即时是<code>border-box</code>也是不计算<code>margin</code>，只是多余计算了<code>border</code>和<code>padding</code>。<strong>因为<code>border</code>和<code>padding</code>都是盒子模型的一部分，但是<code>margin</code>标记的是盒子和盒子的间距</strong>。所以，<code>border-box</code>的解释很符合常理。</p>
<blockquote>
<p>问题来了，如果有时候一定要设置<code>margin</code>，<strong>怎么做到自由控制来保证兼容</strong>？例如，我们下面要设置一个撑满页面的盒子元素，而且有外边距干扰，怎么做？</p>
</blockquote>
<p>实现如下效果图：<br><img src="https://s2.ax1x.com/2019/12/23/l9GIc4.md.png"></p>
<p><strong>代码：</strong><a href="https://github.com/dongyuanxin/markdown-static/blob/master/CSS/border-sizing%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8/index.html">源码下载</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>yuanxin.me<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">      * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* 指定计算方式 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span>; <span class="comment">/* 外边距干扰 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 利用 css3 的 calc */</span></span></span><br><span class="line">        width: calc(100vw - 2 * 10px);</span><br><span class="line">        height: calc(100vh - 2 * 10px);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>所以，当需要计算外边距(margin)，可以配合 css3 中的四则运算（<code>calc</code>）来使用</strong>。</p>
<h2 id="3-使用建议"><a href="#3-使用建议" class="headerlink" title="3. 使用建议"></a>3. 使用建议</h2><blockquote>
<p>根据项目中的使用经验和 w3c 的建议，推荐将<code>box-sizing</code>属性设置为<code>border-box</code>。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex上手与实战</title>
    <url>/2019/03/20/ui-she-ji/01.css3/02.flex-shang-shou-yu-shi-zhan/</url>
    <content><![CDATA[<blockquote>
<p><code>Flex</code>之于 CSS3 就如<code>Promise</code>之于 ES6，都解决了开发者的痛点问题，大大提高了生产力。借助<code>Flex</code>，可以轻松实现<strong>栅栏布局</strong>、<strong>水平/垂直居中</strong>、<strong>自定义排列方向和顺序</strong>等等需求。因此，<code>Flex</code>几乎是 CSS3 的必考内容。</p>
</blockquote>
<h3 id="前端工程师的福音：flex"><a href="#前端工程师的福音：flex" class="headerlink" title="前端工程师的福音：flex"></a>前端工程师的福音：flex</h3><p>原来写前端的过程中，得有一大部分的时间是花费在了水平/垂直居中对齐这件事情上，而网上也是一大堆试图解释某一种对齐方法是正确的文章，搞得头昏脑胀。</p>
<p>终于，弹性布局<code>flex</code>来了，现在团队的开发，在布局上都采用了<code>flex</code>，毕竟不要把生命浪费在对齐这件事情上。</p>
<h3 id="容器的属性和常用值"><a href="#容器的属性和常用值" class="headerlink" title="容器的属性和常用值"></a>容器的属性和常用值</h3><p>容器可以通过设置<code>display</code>属性为<code>flex</code> / <code>inline-flex</code>（行内 flex）来指定其为 flex 布局。</p>
<p>下面，将记录一下容器的属性和常用值，基本可以囊括大多数应用场景哦。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>值</th>
<th>常用值</th>
</tr>
</thead>
<tbody><tr>
<td>flex-direction</td>
<td>项目排列方向</td>
<td>row(默认)、row-reverse、column、column-reverse</td>
<td>row / column</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>项目是否换行</td>
<td>nowrap(默认)、wrap、wrap-reverse</td>
<td>wrap（允许换行）</td>
</tr>
<tr>
<td>justify-content</td>
<td>水平对齐方向</td>
<td>flex-start(默认)、flex-end、center、space-between、space-around</td>
<td>center(<strong>水平居中</strong>)/ space-around(等间距布局)</td>
</tr>
<tr>
<td>align-items</td>
<td>垂直对齐方向</td>
<td>flex-start、flex-end、center、baseline、stretch(默认: 占满整个容器的高度)</td>
<td>center(<strong>垂直居中</strong>)</td>
</tr>
</tbody></table>
<h3 id="项目的属性和常用值"><a href="#项目的属性和常用值" class="headerlink" title="项目的属性和常用值"></a>项目的属性和常用值</h3><p>首先来看下项目元素上常用的 2 个属性，<code>order</code>和<code>flex-grow</code>：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>值</th>
<th>常用值</th>
</tr>
</thead>
<tbody><tr>
<td>order</td>
<td>项目本身的排列顺序</td>
<td>整数，默认为 0。越小越靠前</td>
<td>整数</td>
</tr>
<tr>
<td>flex-grow</td>
<td>项目的放大比例</td>
<td>≥0 的整数，默认为 0</td>
<td>1</td>
</tr>
</tbody></table>
<p>其中，<code>order</code>很好理解，下面通过一个例子来展示<code>flex-grow</code>属性的妙用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      div &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">        flex-grow: 1;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在浏览器中看到，第一个<code>&lt;span&gt;</code>标签由于设置了<code>flex-grow: 1</code>，它自动占据了父容器除了剩下两个<code>&lt;span&gt;</code>标签外的所有空间！</p>
<h3 id="flex-常见应用"><a href="#flex-常见应用" class="headerlink" title="flex 常见应用"></a>flex 常见应用</h3><p><strong>场景 ①：水平垂直居中</strong></p>
<p>以上面的<code>html</code>结构为例，如果要让<code>&lt;div&gt;</code>中的元素水平垂直居中，只需要以下样式代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 ②：左右两侧布局，其中一侧宽度确定；另一侧宽度占满剩余空间，并且自动响应</strong></p>
<p>我们要做的就是将自动响应的那一侧的元素的<code>flex-grow</code>属性设置为 1 即可。</p>
<p><strong>场景 ③：栅栏布局系统</strong></p>
<p>还是以上面的<code>html</code>结构为例，实现一个将屏幕等分为 12 列，3 个<code>&lt;span&gt;</code>标签分别占据屏幕宽度的：1/6、1/6 和 2/3。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和原来相比，<code>flex</code>实现的栅栏布局优点有两个：</p>
<ol>
<li>不再局限于 12 列</li>
<li>不再需要计算宽度，也不需考虑宽度浮点数带来的误差</li>
</ol>
<h3 id="必看：flex-的坑"><a href="#必看：flex-的坑" class="headerlink" title="必看：flex 的坑"></a>必看：flex 的坑</h3><p>在实现水平垂直居中的过程中，发现了<code>flex</code>布局仅仅影响容器的一级子元素。例如下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.level1</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;level1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;level2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>level2 类就不是水平垂直居中的，因为水平垂直居中仅仅影响到了<code>level2</code>，而<strong>不会进一步向下”污染“更深级别的子元素的布局样式</strong>。</p>
<p>如果要让 level2 也实现水平垂直居中，我们可以专门封装一个用于水平垂直居中的类，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.center</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;level1 center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;level2 center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰的网络日志 Flex 布局教程：语法篇</a></li>
<li><a href="http://www.runoob.com/w3cnote/flex-grammar.html">菜鸟教程 Flex 布局语法教程</a></li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>你了解css3的nth-child吗</title>
    <url>/2019/03/19/ui-she-ji/01.css3/03.ni-liao-jie-css3-de-nth-child-ma/</url>
    <content><![CDATA[<blockquote>
<p><code>:nth-child(n)</code> 选择器匹配属于其父元素的第 n 个子元素，借助这个特性，可以实现选择第偶数次序的子元素、选择一定范围内的子元素等“<strong>批量选择操作</strong>”。<br>而它比较难理解的地方是参数表达式中<code>n</code>的含义，以及如何进行数学运算，这也是面试中考察的难点。</p>
</blockquote>
<h3 id="nth-child-介绍"><a href="#nth-child-介绍" class="headerlink" title="nth-child 介绍"></a>nth-child 介绍</h3><p><code>:nth-child(n)</code> 选择器匹配属于其父元素的第 n 个子元素。</p>
<p>使用它的时候需要注意几点：</p>
<ol>
<li>第 n 个子元素的<strong>计数是从 1 开始</strong>，不是从 0 开始的</li>
<li>选择表达式中的<strong>字母<code>n</code>代表 ≥0 的整数</strong></li>
</ol>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>它有 3 种常见用法：</p>
<ul>
<li>直接指明 n 的值：<code>span:nth-child(1)</code></li>
<li>用<code>even</code>/<code>odd</code>分别代表偶数 / 奇数：<code>span:nth-child(even)</code></li>
<li>借助<code>n</code>自定义选择范围：<ul>
<li><code>nth-child(2n)</code>/<code>nth-child(2n + 1)</code>：偶数 / 奇数</li>
<li><code>nth-child(n + 3)</code>：第 3 个开始到最后</li>
</ul>
</li>
</ul>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><p>上面的用法中的第三部分，一般都是使用<code>n</code>，而有时候也会用到<code>-n</code>，比如选取前 2 个元素就是：<code>nth-child(-n + 2)</code>。</p>
<p><strong>为什么是这样呢</strong>？其实运算：<code>-n + 2 ≥ 0</code>，就可以推出<code>n ≤ 2</code>。</p>
<p>由此，结合两者自动取交集，我们就可以限制选择某一范围。比如选择第 6 个到第 9 个，就是：<code>:nth-child(-n+9):nth-child(n+6)</code></p>
<p><strong>注意</strong>：不是<code>nth-child(2 - n)</code>，<code>-n</code>要写在一起！</p>
<h3 id="真正理解“子元素”的含义"><a href="#真正理解“子元素”的含义" class="headerlink" title="真正理解“子元素”的含义"></a>真正理解“子元素”的含义</h3><p>还是<code>nth-child</code>选择器，那么下面这段代码的样式是什么呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child(2n)</span> &#123;</span></span><br><span class="line">        color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>答案是：<code>1</code>是黑色的，<code>2</code>和<code>3</code>都是红色的。</p>
<p>因为<code>&lt;span&gt;2&lt;/span&gt;</code>是其父节点的第 2 个（偶数）子元素。<code>&lt;span&gt;3&lt;/span&gt;</code>是其父节点的第 2 个子元素，第一个是<code>&lt;div&gt;&lt;/div&gt;</code>。</p>
<p>所以辨别是否匹配的关键是：找到父元素，然后再计算在父元素中的位置。</p>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>基础：配置与运行</title>
    <url>/2018/05/29/ui-she-ji/02.scss/01.ji-chu-pei-zhi-yu-yun-xing/</url>
    <content><![CDATA[<h2 id="1、SCSS和Sass"><a href="#1、SCSS和Sass" class="headerlink" title="1、SCSS和Sass"></a>1、<code>SCSS</code>和<code>Sass</code></h2><blockquote>
<p><code>Sass</code> 和 <code>SCSS</code> 其实是同一种东西，我们平时都称之为 <code>Sass</code>。<strong>他们都是用<code>Ruby</code>开发 Css 预处理器，<code>boostrap4</code>已经将<code>less</code>换成了<code>sass</code>。</strong></p>
</blockquote>
<p>不同之处：</p>
<ul>
<li>文件拓展名：分别是<code>sass</code>和<code>scss</code></li>
<li>缩进：<code>sass</code>严格缩进（类似 python 和 ruby），<code>scss</code>是 css 的缩进样式</li>
<li>是否兼容 css 语法：显然，由于缩进的不同，<code>scss</code>是兼容原生的 css 写法。</li>
</ul>
<p>总的来说，<code>scss</code>是<code>sass</code>升级版，兼容 css 语法，并且有着自己的独立语法。</p>
<h2 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h2><ol>
<li>安装 ruby：windows 注意添加注册表路径</li>
<li>安装 sass：利用 ruby 的包管理器<code>gem</code>安装，命令行运行:<code>gem install sass</code></li>
<li>升级和删除 sass：<code>gem update/uninstall sass</code></li>
</ol>
<p><strong>如果国外源过慢？</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://ruby.taobao.org/</span><br><span class="line">gem sources -l <span class="comment">#查看是不是淘宝源</span></span><br></pre></td></tr></table></figure>

<h2 id="3、编译"><a href="#3、编译" class="headerlink" title="3、编译"></a>3、编译</h2><blockquote>
<p>编译指的是：将 scss 文件编译为 css 文件的过程。</p>
</blockquote>
<h3 id="3-1-源文件编译"><a href="#3-1-源文件编译" class="headerlink" title="3.1 源文件编译"></a>3.1 源文件编译</h3><p><strong>单文件编译</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 格式：sass 待编译的Sass文件名:编译后CSS文件名</span></span><br><span class="line">scss scss.scss:css.css</span><br></pre></td></tr></table></figure>

<p><strong>实时自动编译</strong></p>
<p>使用<code>--watch</code>参数即可，scss 会在源文件改动时候，自动重新编译。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scss --watch scss.scss:css.css <span class="comment"># 方便</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-输出文件风格"><a href="#3-2-输出文件风格" class="headerlink" title="3.2 输出文件风格"></a>3.2 输出文件风格</h3><blockquote>
<p>命令行编译时候，使用<code>--style</code>参数。</p>
</blockquote>
<p>一段 scss 代码：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认：嵌套输出方式 nested</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>展开输出方式 expanded</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>紧凑输出方式 compact</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>压缩输出方式 compressed</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><blockquote>
<p>最新的 scss 开启了<code>sourcemap</code>功能，<code>--sourcemap</code>参数默认添加。</p>
</blockquote>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶：继承、占位符和混合宏</title>
    <url>/2018/05/29/ui-she-ji/02.scss/02.jin-jie-ji-cheng-zhan-wei-fu-he-hun-he-hong/</url>
    <content><![CDATA[<blockquote>
<p>如何让 scss 代码可复用？三种复用方式分别用在何处？下方是一段自定义大小的样例 👇</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$height</span>: <span class="number">15px</span> !default;</span><br><span class="line"><span class="variable">$width</span>: <span class="number">18px</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> size(<span class="variable">$list</span>...) &#123;</span><br><span class="line">  <span class="keyword">@if</span> length(<span class="variable">$list</span>) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if length(<span class="variable">$list</span>) == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$list</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$list</span>;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if length(<span class="variable">$list</span>) == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: nth(<span class="variable">$list</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">width</span>: nth(<span class="variable">$list</span>, <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@debug</span> <span class="string">&quot;Too many parameters&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1、继承和占位符"><a href="#1、继承和占位符" class="headerlink" title="1、继承和占位符"></a>1、继承和占位符</h2><blockquote>
<p>两者都是通过<code>@extend</code>来引用。</p>
</blockquote>
<h3 id="1-1-继承"><a href="#1-1-继承" class="headerlink" title="1.1 继承"></a>1.1 继承</h3><blockquote>
<p>一个<strong>已经存在的 css 样式类</strong>，可以被其他样式类继承。</p>
</blockquote>
<p>例如，实现以下 css 样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span>,</span><br><span class="line"><span class="selector-class">.btn--primary</span>,</span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scss 中可以这样写，显然，这种写法便于维护和阅读！</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="keyword">@extend</span> .btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">  <span class="keyword">@extend</span> .btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-占位符"><a href="#1-2-占位符" class="headerlink" title="1.2 占位符"></a>1.2 占位符</h3><blockquote>
<p>顾名思义，如果不被<code>extend</code>引用，它是不会被编译，也就是：<strong>不会占用 css 文件大小</strong>。这是和继承最大区别。</p>
</blockquote>
<p>scss 代码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%btn &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有被extend</span></span><br><span class="line"><span class="comment">// 不会出现在css文件中</span></span><br><span class="line">%test-btn &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="keyword">@extend</span> %btn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">  <span class="keyword">@extend</span> %btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn--primary</span>,</span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--info</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-混合宏"><a href="#2-混合宏" class="headerlink" title="2. 混合宏"></a>2. 混合宏</h2><blockquote>
<p><strong>scss 中的函数</strong>，通过关键字<code>@mixin</code>声明，<code>@include</code>引用。</p>
</blockquote>
<h3 id="2-1-参数设置和调用方式"><a href="#2-1-参数设置和调用方式" class="headerlink" title="2.1 参数设置和调用方式"></a>2.1 参数设置和调用方式</h3><p><strong>无参调用</strong><br>scss：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> btn &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="keyword">@include</span> btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数调用</strong><br>scss:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$radius</span>: <span class="number">3px</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> btn(<span class="variable">$radius</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  <span class="comment">// 默认是 5px</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">$radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="keyword">@include</span> btn(<span class="variable">$radius</span>); <span class="comment">// 传入参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数过多的情况</strong></p>
<blockquote>
<p>当参数 2、3 个时候，可以通过<code>@mixin size($width,$height)</code>这样来调用。当参数过多，使用<code>...</code>符号。</p>
</blockquote>
<p>scss:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$height</span>: <span class="number">15px</span> !default;</span><br><span class="line"><span class="variable">$width</span>: <span class="number">18px</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> size(<span class="variable">$list</span>...) &#123;</span><br><span class="line">  <span class="keyword">@if</span> length(<span class="variable">$list</span>) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if length(<span class="variable">$list</span>) == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$list</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$list</span>;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if length(<span class="variable">$list</span>) == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: nth(<span class="variable">$list</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="attribute">width</span>: nth(<span class="variable">$list</span>, <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@debug</span> <span class="string">&quot;Too many parameters&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--big</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> size(<span class="number">20px</span>, <span class="number">25px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--square</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> size(<span class="number">18px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--test</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> size(</span><br><span class="line">    <span class="number">1px</span>,</span><br><span class="line">    <span class="number">2px</span>,</span><br><span class="line">    <span class="number">3px</span>,</span><br><span class="line">    <span class="number">4px</span></span><br><span class="line">  ); <span class="comment">// just a test. console output &quot;Too many parameters&quot; what we have defined.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的 css 结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn--primary</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--big</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn--square</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-好处和不足"><a href="#2-2-好处和不足" class="headerlink" title="2.2 好处和不足"></a>2.2 好处和不足</h3><blockquote>
<p>混合宏最大的不足：<strong>会复用代码，造成 css 冗赘</strong>（可以尝试一下下方的测试代码）。<br>当然，符合宏可以传递参数这点很 nice。</p>
</blockquote>
<p>可以编译下方代码，观察下结果：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-radius &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-radius;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-版本"><a href="#3-版本" class="headerlink" title="3. 版本"></a>3. 版本</h2><ul>
<li>scss:3.5.6</li>
<li>ruby:2.4.4p296</li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>「译文」逐步替换Sass</title>
    <url>/2019/05/17/ui-she-ji/02.scss/03.yi-wen-zhu-bu-ti-huan-sass/</url>
    <content><![CDATA[<h2 id="翻译说明"><a href="#翻译说明" class="headerlink" title="翻译说明"></a>翻译说明</h2><p>这是一篇介绍现代 css 核心特性的文章，并且借助 sass 进行横向对比，充分体现了 css 作为一门设计语言的快速发展以及新特性为我们开发者带来的强大生产力。</p>
<p>第一次尝试翻译技术文，为了让文章更通俗易懂，很多地方结合了文章本意和自己的说话风格。另外，时间有限水平有限，难免有些失误或者翻译不恰当的地方，欢迎指出讨论。</p>
<p><strong>英文原文地址</strong>：<a href="https://cathydutton.co.uk/posts/why-i-stopped-using-sass/">https://cathydutton.co.uk/posts/why-i-stopped-using-sass/</a></p>
<h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><p>我每年都要重新搭建和设计我的网站，这是一个非常不错的方式去跟进 HTML/CSS 的最新进展、开发模式和网站生成器。在上个月，我发布了新版本：从 Jekyll 和 GithubPages 迁移到 Eleventy 和 Netlify。</p>
<p>一开始，我并没有移除代码中所有的 sass 代码。这本不是我计划中的事情，但随着我不断查看 sass 代码，我一直在思考：它们是否给网站带来了价值，还是仅仅增加了复杂度和依赖性(特指对：scss)？随着这年 css 的发展，曾经让我使用 sass 的原因似乎不那么重要了。</p>
<p>其中一个例子就是我已经移除了媒体查询。当我了解到 CSS 的一些新的特性，那些针对特定屏幕大小的代码（媒体查询）没有必要，因此被移除了。</p>
<h2 id="Sass-解决了什么问题？"><a href="#Sass-解决了什么问题？" class="headerlink" title="Sass 解决了什么问题？"></a>Sass 解决了什么问题？</h2><p>大概 5、6 年前，我第一次了解到 sass 的时候，我是有些换衣的。随着我搭建越来越多的响应式 web 应用，我才意识到借助 sass 的  <code>functions</code>  和  <code>mixins</code>  可以大大提高代码复用。显而易见的是，随着设备、视图窗口和主题等场景的变化，使用（sass 的）变量让代码迁移的成本更低。</p>
<p>下面是我用 sass 做的事情：</p>
<ul>
<li>布局</li>
<li>变量</li>
<li>Typography</li>
</ul>
<h2 id="1-布局"><a href="#1-布局" class="headerlink" title="1) 布局"></a>1) 布局</h2><p>布局一直是 css 中让人困惑的地方。而响应式布局正是我最初决定使用 Sass 去创建 css 布局的重要原因。</p>
<h3 id="使用-sass"><a href="#使用-sass" class="headerlink" title="使用 sass"></a>使用 sass</h3><p>我一直记得我第一次尝试用 css 创建一个响应式网格布局的时候，那要为每列创建一个对应的类名，然后再用语义化不强的类名（比如  <code>col-span-1</code>  和  <code>col-span-4</code> ）来标记它。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.col-span-3</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">24%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-span-4</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32.3%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-span-5</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40.6%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助 sass 的  <code>mixin</code>  和变量，能够不再编写像上面那样的类名。并且能够通过改变  <code>$gridColumns</code>  变量，来创造更灵活的布局。</p>
<p>下面是我写的第一个基于  <code>mixin</code>  的网格布局：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> grid($colSpan, $<span class="attribute">gridColumns:</span> <span class="number">12</span>, $<span class="attribute">margin:</span> <span class="number">1%</span>) &#123;</span><br><span class="line">  $unitWidth: $gridColumns / $colSpan;</span><br><span class="line">  <span class="selector-tag">float</span>: <span class="selector-tag">left</span>;</span><br><span class="line">  width: (100 - $unitWidth * $margin) / $unitWidth;</span><br><span class="line">  margin: 0 $margin/2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入方法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  @include grid(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-content</span> &#123;</span><br><span class="line">  @include grid(9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    @include grid(12);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.main-content</span> &#123;</span><br><span class="line">    @include grid(12);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-网格布局"><a href="#CSS-网格布局" class="headerlink" title="CSS 网格布局"></a>CSS 网格布局</h3><p>通过 css 的  <code>grid</code>  的介绍，我们不再需要用语义化不强的类名或者 sass 或者其他预处理器，来完成网格布局这项功能。Rachel Andrew 说这种方法是最好的：</p>
<blockquote>
<p>你不再需要一种工具来帮助你创建网格布局，因为你现在就拥有它。</p>
</blockquote>
<p>下面的的代码基于内容的宽度范围，创建了一个响应式布局，并且不再需要预设和计算设备的大小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.project</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, minmax(<span class="number">12em</span>, <span class="number">1</span>fr));</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 sass 创建网格布局转变为 css 原生网格布局，是一个“无痛”体验。它不仅仅能够减少对 sass 的依赖，还可以让我编写更灵活的代码，激发更多的设计思路以及不再使用媒体查询设计网站。</p>
<p>但是最明显的不足是浏览器的兼容性。Grid 是目前只在最新浏览器中被支持，包括 IE11、IE10。对  <code>auto-fill</code>  和  <code>auto-fit</code>  属性的支持更少，但可以通过查询规范支持来提前规避。</p>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2) 变量"></a>2) 变量</h2><p>变量就是一个可能变化的值，我一直不知道 css 中有这个功能。今天我的大多数项目都遵循  <a href="https://cathydutton.co.uk/posts/why-i-stopped-using-sass/">ITCSS methodology</a> ，并且创建一个配置文件专门用来存放变量定义。通常，我会为字体样式、颜色和媒体查询设置变量。</p>
<p>之前 sass 的做法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* COLORS */</span></span><br><span class="line">$colors: (</span><br><span class="line">  &quot;<span class="selector-tag">black</span>&quot;: <span class="selector-id">#2a2a2a</span>,</span><br><span class="line">  &quot;<span class="selector-tag">white</span>&quot;: <span class="selector-id">#fff</span>,</span><br><span class="line">  &quot;<span class="selector-tag">grey-light</span>&quot;: <span class="selector-id">#ccc7c3</span>,</span><br><span class="line">  &quot;<span class="selector-tag">grey-dark</span>&quot;: <span class="selector-id">#2a2a2a</span>,</span><br><span class="line">  &quot;<span class="selector-tag">accent</span>&quot;: <span class="selector-id">#ffa600</span>,</span><br><span class="line">  &quot;<span class="selector-tag">off-white</span>&quot;: <span class="selector-id">#f3f3f3</span>,</span><br><span class="line">  &quot;<span class="selector-tag">sky-blue</span>&quot;: <span class="selector-id">#ccf2ff</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BREAKPOINTS */</span></span><br><span class="line">$breakpoints: (</span><br><span class="line">  &quot;<span class="selector-tag">break-mobile</span>&quot;: 290<span class="selector-tag">px</span>,</span><br><span class="line">  &quot;<span class="selector-tag">break-phablet</span>&quot;: 480<span class="selector-tag">px</span>,</span><br><span class="line">  &quot;<span class="selector-tag">break-tablet</span>&quot;: 768<span class="selector-tag">px</span>,</span><br><span class="line">  &quot;<span class="selector-tag">break-desktop</span>&quot;: 1020<span class="selector-tag">px</span>,</span><br><span class="line">  &quot;<span class="selector-tag">break-wide</span>&quot;: 1280<span class="selector-tag">px</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TYPOGRAPHY */</span></span><br><span class="line">$font-stack: (</span><br><span class="line">  decorative: #&#123;&quot;oswald&quot;,</span><br><span class="line">  <span class="selector-tag">Helvetica</span>,</span><br><span class="line">  <span class="selector-tag">sans-serif</span>&#125;,</span><br><span class="line">  general: #&#123;&quot;Helvetica Neue&quot;,</span><br><span class="line">  <span class="selector-tag">Helvetica</span>,</span><br><span class="line">  <span class="selector-tag">Arial</span>,</span><br><span class="line">  <span class="selector-tag">sans-serif</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用变量或者映射让我的网站能够快速和简单地应对大的改动。它也预防了在大型代码项目中过分堆积复杂的外形、颜色变量，特别是 hover 悬浮的动画、引用、边框等等。</p>
<p>例如下面场景：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4caf50</span>; <span class="comment">/* Green */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#3f8c42</span>; <span class="comment">/* Dark Green */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#266528</span>; <span class="comment">/* Darker Green */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够被 sass 的变量和颜色相关的内置函数重写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">$button-colour: #4caf50;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: $button-colour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">darken</span>($button-colour, <span class="number">20%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">darken</span>($button-colour, <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="到底有什么不同？"><a href="#到底有什么不同？" class="headerlink" title="到底有什么不同？"></a>到底有什么不同？</h3><p>css 自带的变量能做的事情更多，不仅仅是替换静态字面量，它可以实时动态计算（而不仅仅是编译构建的时候静态替换）。它允许被 js 修改，并且不需要在代码外面再包裹一层  <code>mixins</code>  和  <code>funtions</code> 。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--button-color</span>: <span class="number">#4caf50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--button-color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> <span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">--button-color</span>: <span class="number">#000000</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--button-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，sass 中对颜色的一些内置函数在 css 中也可以使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--button-color</span>: <span class="number">#4caf50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">color-mod</span>(var(--button-color) <span class="built_in">tint</span>(<span class="number">50%</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不幸的是，这（颜色相关内置函数）一直在处在提案阶段。我决定还是手动定义颜色变量来替换它（提案中的方案）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--colour-dark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--colour-bright);</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你执意使用他们，那么这个包含了很多 css 颜色函数功能的  <a href="https://github.com/jonathantneal/postcss-color-mod-function">PostCSS</a>  项目能够帮助到你。</p>
<h2 id="3-网页排版"><a href="#3-网页排版" class="headerlink" title="3) 网页排版"></a>3) 网页排版</h2><p>最后，对于排版，在之前的代码中，我是用 sass 去创建响应式排版和布局。下面展示的  <code>mixin</code>  的用法让我能轻易地处理不同大小的屏幕与设备：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> typography($size) &#123;</span><br><span class="line">  font-size: $size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> mq(break-desktop) &#123;</span><br><span class="line">    font-size: $size * 1.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我用原生的 css 的功能来进行这些计算：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--font-size</span>: <span class="built_in">calc</span>(<span class="number">18px</span> + <span class="number">0.25vw</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">var</span>(--font-size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>CSS 正在朝向更具内涵的规范发展，在 css 的  <code>grid</code>  特性中，有  <code>flexbox</code>  以及  <code>min-content</code> 、 <code>max-content</code> 、 <code>fit-content</code>  这些属性，而在 Css Grid Layout Module Level2 中也准备加入的新布局： <code>Subgrid</code> 。</p>
<p>这些新的特性都让原生的 css 更有吸引力！</p>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>字体特效</title>
    <url>/2019/07/16/ui-she-ji/03.dong-hua-she-ji/01.zi-ti-te-xiao/</url>
    <content><![CDATA[<h2 id="特效一览"><a href="#特效一览" class="headerlink" title="特效一览"></a>特效一览</h2><p><strong>划线动态</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9YGdI.gif"></p>
<p><strong>背景高亮</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9Yres.gif"></p>
<p><strong>色块进出</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9Y2WT.gif"></p>
<h2 id="划线动态"><a href="#划线动态" class="headerlink" title="划线动态"></a>划线动态</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9YGdI.gif"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，利用<code>::after</code>和<code>::before</code>就可以画出上下两条线，所以只需要一个 dom 元素即可。</p>
<p>其次，对于鼠标移入的动画，要给上面两个伪元素设置<code>:hover</code>选择器。</p>
<p>最后是处理动画方向。我们以上面的线条为例，在鼠标移入的时候，是从右到左变化的。这里是通过设置<code>transform-origin</code>属性来修改动画方向。下面的线条同理，方向相反即可。</p>
<p><strong>注意</strong>：代码是通过<code>scaleX</code>来实现缩放，相比于设置<code>width</code>，会启用 GPU，避免重绘。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>google.com<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#595959</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center left;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center right;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背景高亮"><a href="#背景高亮" class="headerlink" title="背景高亮"></a>背景高亮</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9Yres.gif"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>首先，利用<code>::before</code>伪元素就可以模拟出覆盖需要的色块。所以仅仅需要一个 dom 元素。这里伪元素的<code>content</code>元素必须给，否则不会显示（有些坑）。</p>
<p>其次，色块大小改变是通过<code>scaleY</code>来设置的，原因和第一个动画原因一样。</p>
<p>最后，伪元素的色块会覆盖 dom 上的元素。所以需要给 dom 元素设置<code>z-index</code>，并且让其生效并大于伪元素的<code>z-index</code>。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>google.com<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. content必须给</span></span><br><span class="line"><span class="comment">2. 用transform覆盖 配合 z-index</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="色块进出"><a href="#色块进出" class="headerlink" title="色块进出"></a>色块进出</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9Y2WT.gif"></p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>这和上一个“背景高亮”动画类似，不同的是色块的位置和大小变化方向不同。其余基本一致。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>google.com<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center right;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.1s</span> linear;</span><br><span class="line">  <span class="comment">/* 这里不要指明为 all */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center left;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>输入框特效</title>
    <url>/2019/07/22/ui-she-ji/03.dong-hua-she-ji/02.shu-ru-kuang-te-xiao/</url>
    <content><![CDATA[<h2 id="特效一览"><a href="#特效一览" class="headerlink" title="特效一览"></a>特效一览</h2><p><strong>划线动态</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9YbY6.gif"></p>
<p><strong>动态边框</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9YXlD.gif"></p>
<h2 id="划线动态"><a href="#划线动态" class="headerlink" title="划线动态"></a>划线动态</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9YbY6.gif"></p>
<h3 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h3><p><code>:before</code> 和 <code>:after</code>伪元素指定了一个元素文档树内容之前和之后的内容。由于<code>input</code>标签不是可插入内容的容器。所以这里下划线无法通过伪元素来实现。需要借助其他 dom 节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>包裹在外的父元素<code>div</code>应该设置成<code>inline-block</code>，否则宽度会满屏。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>input</code> 标签需要禁用默认样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fafafa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>span</code>标签实现「左进右出」的动态，需要改变<code>transform-origin</code>方向。为了避免回流重绘，通过<code>scaleX</code>来实现宽度变化的视觉效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> ~ <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.3s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态边框"><a href="#动态边框" class="headerlink" title="动态边框"></a>动态边框</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9YXlD.gif"></p>
<h3 id="原理和代码-1"><a href="#原理和代码-1" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>如动态图所示，有 4 条边框。所以除了<code>input</code>元素外，还需要准备其他 4 个 dom。为了方便定位，嵌套一个父级元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和「划线动态」类似，input 和 div 的样式基本一样。为了好看，改一下 padding 属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fafafa</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其他 4 个 span 元素，它们的位置属性，动画属性，以及颜色都是相同的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span>,</span><br><span class="line"><span class="selector-class">.top</span>,</span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.1s</span> ease-in-out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于.bottom 和.top，它们的变化方向是水平；对于.left 和.right，它们的变化方向是垂直。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span>,</span><br><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是处理延时的特效。动态图中，动画按照下、右、上、左的顺序依次变化。借助的是<code>transition-delay</code>属性，来实现动画延迟。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0.2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.top</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: top center;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0.1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: bottom center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: bottom center;</span><br><span class="line">  <span class="attribute">transition-delay</span>: <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: top center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.zhihu.com/question/21296044">为什么 input 不支持伪元素(:after,:before)？</a></li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>按钮特效</title>
    <url>/2019/07/24/ui-she-ji/03.dong-hua-she-ji/03.an-niu-te-xiao/</url>
    <content><![CDATA[<h2 id="特效一览"><a href="#特效一览" class="headerlink" title="特效一览"></a>特效一览</h2><p><strong>滑箱</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9temj.gif"></p>
<p><strong>果冻</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9twh6.gif"></p>
<p><strong>脉冲</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9t6nH.gif"></p>
<p><strong>闪光</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9tcBd.gif"></p>
<p><strong>气泡</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9tojg.gif"></p>
<h2 id="滑箱特效"><a href="#滑箱特效" class="headerlink" title="滑箱特效"></a>滑箱特效</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9temj.gif"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因为 button 元素可以使用 before/after 伪元素，所以借助伪元素，可以实现动态图中的遮盖层。</p>
<p>为了避免回流重绘，滑箱的运动方向是垂直方向，所以使用<code>scaleY</code>属性。对于动画的方向，需要借助<code>transform-origin</code>改变动画原点。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>root-lucas.github.io<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#40a9ff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fa541c</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.4s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center top;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="果冻特效"><a href="#果冻特效" class="headerlink" title="果冻特效"></a>果冻特效</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9twh6.gif"></p>
<h3 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>果冻特效可以分割成 5 个部分，所以无法简单通过 <code>transition</code> 来实现，要借助<code>animation</code>。并且动画触发的时间点是鼠标移入的时候，因此 <code>animation</code> 要在<code>:hvoer</code>中声明。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#40a9ff</span>;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">animation</span>: jelly <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始编写 jelly 动画的特效。这个动画可以分解为 4 个部分：「初始 =&gt; 挤高 =&gt; 压扁 =&gt; 回到初始状态」。挤高 和 压扁这里都是通过<code>scale</code>来实现的，代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> jelly &#123;</span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  33% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.9</span>, <span class="number">1.1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  66% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>, <span class="number">0.9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>上面的动态已经仿真不错了，如果将 4 部分变成 5 部分：「初始 =&gt; 挤高 =&gt; 压扁 =&gt; 挤高 =&gt; 回到初始状态」。<strong>视觉上会有一种弹簧的特效</strong>，就像手压果冻后的效果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> jelly &#123;</span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  25%,</span><br><span class="line">  75% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.9</span>, <span class="number">1.1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>, <span class="number">0.9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脉冲特效"><a href="#脉冲特效" class="headerlink" title="脉冲特效"></a>脉冲特效</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9t6nH.gif"></p>
<h3 id="原理和代码-1"><a href="#原理和代码-1" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>首先，还是去掉 button 的默认样式。注意设置 button 的<code>z-index</code>属性并且让其生效，要保证其大于 <code>::before</code> 的 <code>z-index</code> 属性，<strong>防止 dom 元素被伪元素覆盖</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的就是设置伪元素。因为脉冲特效给人的感觉是“镂空”放大。因此，变化对象是 <code>border</code> 属性。而镂空的效果，是通过透明背景来实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#1890ff</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动画启动时间是鼠标移入，border 上变化的是颜色变淡和大小变小，透明度也逐渐变成 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.75s</span> ease-out;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid<span class="number">#e6f7ff</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.25</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ transition 和 transform 是放在<code>hover</code>状态下的伪元素，目的是让动画瞬间回到初始状态。</p>
<h2 id="闪光特效"><a href="#闪光特效" class="headerlink" title="闪光特效"></a>闪光特效</h2><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9tcBd.gif"></p>
<h3 id="原理和代码-2"><a href="#原理和代码-2" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>实现上依然是借助伪元素，闪光特效更多注重的是配色，动画方面实现的核心是利用<code>rotate</code>来实现「倾斜」的效果，利用<code>translate3d</code>来实现「闪动」的效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#262626</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">--shine-width</span>: <span class="number">1.25em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#595959</span>;</span><br><span class="line">  <span class="comment">/* 核心代码：位置一步步调整 */</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0%</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.25em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">200%</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">35deg</span>);</span><br><span class="line">  <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.5s</span> ease-in-out;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">500%</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="built_in">rotate</span>(<span class="number">35deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️<code>translate3d</code>除了避免重绘回流，还能启用 GPU 加速，性能更高。但之前为了方便讲述，一般使用的是<code>translate</code>属性。</p>
<h2 id="气泡特效"><a href="#气泡特效" class="headerlink" title="气泡特效"></a>气泡特效</h2><h3 id="效果图-4"><a href="#效果图-4" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9tojg.gif"></p>
<h3 id="原理和代码-3"><a href="#原理和代码-3" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>首先，还是禁用 button 元素的默认样式，并且调整一下配色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#40a9ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 button 的伪元素层级是覆盖 button 的，所以要设置 <code>z-index</code> 属性，防止伪元素遮盖显示。毕竟只想要背景色的遮盖，字体不需要遮盖。在上面的样式中添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后处理的是伪元素的变化效果。<strong>特效是从中心向四周蔓延</strong>，所以应该让其居中。</p>
<p>对于大小变化，还是利用<code>scale</code>属性。</p>
<p>因为是圆形，所以将<code>border-radius</code>设置为 50%即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#9254de</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">50%</span>, -<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">scale</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.45s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-<span class="number">50%</span>, -<span class="number">50%</span>, <span class="number">0</span>) <span class="built_in">scale</span>(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="换个方向？"><a href="#换个方向？" class="headerlink" title="换个方向？"></a>换个方向？</h3><p>示例代码中的气泡特效是从中间向四周扩散，如果想要从左上角向右下角扩散呢？例如下图所示：</p>
<p><img src="https://static.godbmw.com/img/2019-07-24-button-animation/6.gif"></p>
<p>处理过程很简单，<strong>只需要改变一下气泡的初始位置即可</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#9254de</span>;</span><br><span class="line">  <span class="comment">/* 变化位置的代码 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.45s</span> ease-in-out;</span><br><span class="line">  <span class="comment">/* *********** */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://caibaojian.com/transform-origin.html">《transform-origin: 改变动画原点》</a></li>
<li><a href="https://blog.teamtreehouse.com/increase-your-sites-performance-with-hardware-accelerated-css">《Increase Your Site’s Performance with Hardware-Accelerated CSS》</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/05/css-variables.html">《css3 变量》</a></li>
</ul>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>Loader特效·基础篇</title>
    <url>/2019/07/25/ui-she-ji/03.dong-hua-she-ji/04.loader-te-xiao-ji-chu-pian/</url>
    <content><![CDATA[<h2 id="特效一览"><a href="#特效一览" class="headerlink" title="特效一览"></a>特效一览</h2><p><strong>声音波纹</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9U8eJ.gif"></p>
<p><strong>弹性缩放</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9UtF1.gif"></p>
<p><strong>旋转加载</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9UUW6.gif"></p>
<p><strong>渐变点</strong>:</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9UwQO.gif"></p>
<p><strong>翻转纸片</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9U0yD.gif"></p>
<h2 id="声音波纹特效"><a href="#声音波纹特效" class="headerlink" title="声音波纹特效"></a>声音波纹特效</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9U8eJ.gif"></p>
<h3 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>需要几个块，就准备几个空 dom 元素。当然，数量越多，动画越细腻，但同时维护成本也高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先编写一些基础样式代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独观察一个空 dom 元素，其实就是一个缩放动画：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> grow &#123;</span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不同点</strong>：每个元素的动画启动时间不一样；每个元素的初始状态不一样。</p>
<p>下面的代码中有个 2 个时间参数，第一个是动画时长，第二个是延迟时间。如果延迟时间是负数，那么会自动计算对应时间点的动画作为初始状态动画。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: grow <span class="number">1s</span> <span class="number">0s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: grow <span class="number">1s</span> <span class="number">0.15s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: grow <span class="number">1s</span> <span class="number">0.3s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(4)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: grow <span class="number">1s</span> <span class="number">0.45s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="弹性缩放特效"><a href="#弹性缩放特效" class="headerlink" title="弹性缩放特效"></a>弹性缩放特效</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9UtF1.gif"></p>
<h3 id="原理和代码-1"><a href="#原理和代码-1" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>分解一下这个动画，会发现它分为 2 个部分：</p>
<ol>
<li>放大一倍，旋转 360deg</li>
<li>缩小到正常大小，再旋转 360deg</li>
</ol>
<p>因此，动画的代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> stretch &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>) <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">rotate</span>(<span class="number">720deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式效果是通过 border 来实现的，只展示对立方向的 border 即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> transparent solid;</span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#531dab</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: <span class="number">#531dab</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">animation</span>: stretch <span class="number">2s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缩放加载特效"><a href="#缩放加载特效" class="headerlink" title="缩放加载特效"></a>缩放加载特效</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9UUW6.gif"></p>
<h3 id="原理和代码-2"><a href="#原理和代码-2" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>动画很简单，就是无限循环的旋转。主要是如此丝滑的效果，采用的是「慢 =&gt; 快 =&gt; 慢」对应的动画函数，也就是<code>ease-in-out</code>。</p>
<p>样式效果和上一个类似，也是通过操作 border 实现。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#d3adf7</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#722ed1</span>;</span><br><span class="line">  <span class="attribute">animation</span>: spin <span class="number">1s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渐变点特效"><a href="#渐变点特效" class="headerlink" title="渐变点特效"></a>渐变点特效</h2><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9UwQO.gif"></p>
<h3 id="原理和代码-3"><a href="#原理和代码-3" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>和「声音波纹」特效类似，展示点的个数取决于空 dom 元素个数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>动画特效非常简单，就是「透明 =&gt; 完全不透明 =&gt; 透明」这个过程。整体效果也是通过调整动画时长 &amp;&amp; 动画延迟启动时间来实现的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff4d4f</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: fade <span class="number">1s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: fade <span class="number">1s</span> <span class="number">0.2s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: fade <span class="number">1s</span> <span class="number">0.4s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> fade &#123;</span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="翻转纸片"><a href="#翻转纸片" class="headerlink" title="翻转纸片"></a>翻转纸片</h2><h3 id="效果图-4"><a href="#效果图-4" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9U0yD.gif"></p>
<h3 id="代码和原理"><a href="#代码和原理" class="headerlink" title="代码和原理"></a>代码和原理</h3><p>这个特效比较有意思的地方是<strong>动画很细腻</strong>。主要是分为两部分，一个是关于 y 轴的 180deg 旋转，另一个是关于 x 轴的 180deg 旋转。要借助<code>rotateX</code>和<code>rotateY</code>来实现。</p>
<p>⚠️ 为了取得位于中间位置的轴线，要设置<code>transform-origin: center</code>。</p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eb2f96</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">  <span class="attribute">animation</span>: paper <span class="number">2s</span> ease infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> paper &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">0</span>) <span class="built_in">rotateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">180deg</span>) <span class="built_in">rotateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">180deg</span>) <span class="built_in">rotateY</span>(<span class="number">180deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>Loader特效·进阶篇</title>
    <url>/2019/07/26/ui-she-ji/03.dong-hua-she-ji/05.loader-te-xiao-jin-jie-pian/</url>
    <content><![CDATA[<h2 id="特效一览"><a href="#特效一览" class="headerlink" title="特效一览"></a>特效一览</h2><p>🌊 波浪特效：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9U4Og.gif"></p>
<p>🕙 撞钟特效：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9UImQ.gif"></p>
<p>⏳ 沙漏特效：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9UTTs.gif"></p>
<p>🏃 追逐特效：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9Uqf0.gif"></p>
<h2 id="🌊-波浪特效"><a href="#🌊-波浪特效" class="headerlink" title="🌊 波浪特效"></a>🌊 波浪特效</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9U4Og.gif"></p>
<h3 id="原理和代码"><a href="#原理和代码" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>这里的动画效果是分成 2 个过程：上 =&gt; 下 =&gt; 回到上。<strong>其实这两个过程是相反的</strong>。可以使用动画属性<code>alternate</code>，在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">3.5em</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="attribute">animation</span>: wave <span class="number">1.2s</span> ease-in-out alternate infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">0.2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">animation-delay</span>: -<span class="number">0.4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> wave &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⚠️ 在不清楚<code>alternate</code>之前，有尝试过将<code>wave</code>过程拆分成 2 部分。但是这样动画函数<code>ease-in-out</code>是作用于整个过程，而不是作用于其中一个过程。动画的观感上就不再具有「波浪律动」的效果。</p>
<h2 id="🕙-撞钟特效"><a href="#🕙-撞钟特效" class="headerlink" title="🕙 撞钟特效"></a>🕙 撞钟特效</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9UImQ.gif"></p>
<h3 id="原理和代码-1"><a href="#原理和代码-1" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>准备 3 个 dom 元素，左起第一个和第三个有动画特效，第二个没有。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff4d4f</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: left <span class="number">2s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(2)</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type(3)</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: right <span class="number">2s</span> ease-in-out infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个动画特效，乍一看是使用了延迟启动。但是延迟启动无法实现，因为只有动画第一次启动时候延迟，当动画重复开始的时候并不会延迟。<strong>因此需要在动画过程中，让其有一段时间处于静止状态</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0 ~ 50% 移动；50% ～ 100%静止 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> left &#123;</span><br><span class="line">  0%,</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0 ~ 50% 静止；50% ～ 100%移动 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> right &#123;</span><br><span class="line">  0%,</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  75% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="⏳-沙漏特效"><a href="#⏳-沙漏特效" class="headerlink" title="⏳ 沙漏特效"></a>⏳ 沙漏特效</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9UTTs.gif"></p>
<h3 id="原理和代码-2"><a href="#原理和代码-2" class="headerlink" title="原理和代码"></a>原理和代码</h3><p>沙漏特效这里仅仅需要一个<code>div</code>元素模拟容器，利用伪元素模拟里面的沙子。容器的动画是旋转；里面沙子的动画是配合旋转，在对应时刻填充 / 消失。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> <span class="number">#d46b08</span> solid;</span><br><span class="line">  <span class="attribute">animation</span>: spin <span class="number">1.5s</span> ease infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fa8c16</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center top;</span><br><span class="line">  <span class="attribute">animation</span>: fill <span class="number">3s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来想象一下现实中旋转沙漏的效果（只考虑容器的一半），刚开始，沙漏是满的；180 度转过来后，沙子会自动到下面，此时这半部分沙漏是空的；最后再转过来，沙子又会回到这部分容器。</p>
<p>对于容器来说，其实就是不停的旋转；对于沙子来说，分成 2 个过程：满 =&gt; 消失 =&gt; 满。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 容器 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 沙子 */</span></span><br><span class="line"><span class="keyword">@keyframes</span> fill &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  0%,</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SVG-特别篇：追逐特效-🏃"><a href="#SVG-特别篇：追逐特效-🏃" class="headerlink" title="SVG 特别篇：追逐特效 🏃"></a>SVG 特别篇：追逐特效 🏃</h2><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://s2.ax1x.com/2019/12/24/l9Uqf0.gif"></p>
<h3 id="绘制-SVG"><a href="#绘制-SVG" class="headerlink" title="绘制 SVG"></a>绘制 SVG</h3><p>首先，我们需要绘制 svg 标签，这里绘制的是一个以(50, 50)为圆心，半径为 10 的圆形。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;25 25 50 50&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了方便维护，关于线条的样式均放在了样式表中编写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">svg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">3.75em</span>;</span><br><span class="line">  <span class="attribute">animation</span>: rotate <span class="number">2s</span> linear infinite;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">svg</span> <span class="selector-tag">circle</span> &#123;</span><br><span class="line">  <span class="attribute">fill</span>: none;</span><br><span class="line">  <span class="attribute">stroke</span>: red;</span><br><span class="line">  <span class="attribute">stroke-width</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">stroke-linecap</span>: round;</span><br><span class="line">  <span class="attribute">animation</span>: dash <span class="number">3s</span> linear infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动画分为 2 个部分，一个是旋转，一个是关于 svg 线条的变化。旋转需要指明动画方向是<code>center</code>，这个在<code>svg</code>标签设置<code>viewBox</code>时，才会生效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>: center;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stroke-dasharray-和-stroke-dashoffset"><a href="#stroke-dasharray-和-stroke-dashoffset" class="headerlink" title="stroke-dasharray 和 stroke-dashoffset"></a>stroke-dasharray 和 stroke-dashoffset</h3><p>stroke-dasharray 用来指明实现、虚线的长度。比如 <code>stroke-dasharray: 10 30</code>，就是说实线和虚线长度分别为 10 和 30。如果总长度远超过 10 + 30 = 40，那么一直是 10、30、10、30……这样的循环。</p>
<p>stroke-dashoffset 用来指明绘制的起点。如果是正数，那么绘制起点在默认起点之前，整体有一部分被隐藏了；如果是负数，那么绘制起点在默认起点之后，整体的视觉效果是向前推进。</p>
<p>stroke-dashoffset 比较不容易理解，这里举个 🌰。还是以前面准备好的 svg 为例，整个调整的效果如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/12/24/l9Uzm4.gif"></p>
<h3 id="实现动画效果"><a href="#实现动画效果" class="headerlink" title="实现动画效果"></a>实现动画效果</h3><p>分解一下动画的过程：「逐渐变长，并且前移 =&gt; 继续前移 =&gt; 回复到初始长度」。借助上部分所述的 stroke-dasharray 和 stroke-dashoffset，动画实现如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> dash &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">stroke-dasharray</span>: <span class="number">1</span>, <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">stroke-dasharray</span>: <span class="number">20</span>, <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>: -<span class="number">15</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">stroke-dasharray</span>: <span class="number">20</span>, <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>: -<span class="number">62</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>三栏布局的5种方案</title>
    <url>//2019-12-11-learning-five-layout</url>
    <content><![CDATA[<p>题目：</p>
<p>假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应的设置方案有几种？</p>
<blockquote>
<p>这里考察的是你对CSS的理解</p>
</blockquote>
<h4 id="首先初始化样式"><a href="#首先初始化样式" class="headerlink" title="首先初始化样式"></a>首先初始化样式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTML编写"><a href="#HTML编写" class="headerlink" title="HTML编写"></a>HTML编写</h4><p>由于三栏布局HTML代码几乎差不多，下面就不过多重复编写了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&#x27;container1&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是xxx解决方案<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是三栏布局左右固定中间自适应<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong> 浮动解决方案需要将<code>.center</code>的类标签与<code>.right</code>类互换位置即可。</p>
<p>下面我们将通过修改<code>css</code>样式来解决布局方案，样式的<code>container1</code>可根据下面方案自行修改即可。</p>
<h3 id="1-浮动解决方案"><a href="#1-浮动解决方案" class="headerlink" title="1.浮动解决方案"></a>1.浮动解决方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container1</span> <span class="selector-tag">div</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.right</span>&#123;<span class="attribute">width</span>: <span class="number">300px</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.left</span>&#123;<span class="attribute">float</span>: left;&#125;</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.right</span>&#123;<span class="attribute">float</span>: right;&#125;</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.center</span>&#123;<span class="attribute">background</span>: palegreen;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 兼容性比较好；把清除浮动和周边元素的关系处理好的话。</p>
<p><strong>缺点：</strong> 清除浮动，浮动以后脱离文档流，处理不好会带来很多问题，本身的局限性。</p>
<h3 id="2-定位解决方案"><a href="#2-定位解决方案" class="headerlink" title="2.定位解决方案"></a>2.定位解决方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container2</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;<span class="attribute">position</span>: relative;&#125;</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-tag">div</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;<span class="attribute">position</span>: absolute;&#125;</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-class">.right</span>&#123;<span class="attribute">width</span>: <span class="number">300px</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-class">.center</span>&#123;<span class="attribute">background</span>: palegreen;<span class="attribute">left</span>: <span class="number">300px</span>;<span class="attribute">right</span>: <span class="number">300px</span>;&#125;</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-class">.left</span>&#123;<span class="attribute">left</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.container2</span> <span class="selector-class">.right</span>&#123;<span class="attribute">right</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 快捷，配合js使用不容易出问题。</p>
<p><strong>缺点：</strong> 布局已经脱离文档流了，就意味下面所有子元素也必须脱离文档流，导致了这个方案的可使用性比较差。</p>
<h3 id="3-flex-box-解决方案"><a href="#3-flex-box-解决方案" class="headerlink" title="3.flex box 解决方案"></a>3.flex box 解决方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container3</span>&#123;<span class="attribute">display</span>: flex;&#125;</span><br><span class="line"><span class="selector-class">.container3</span> <span class="selector-tag">div</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-class">.container3</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.container3</span> <span class="selector-class">.right</span>&#123;<span class="attribute">width</span>: <span class="number">300px</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.container3</span> <span class="selector-class">.center</span>&#123;<span class="attribute">flex</span>: <span class="number">1</span>;<span class="attribute">background</span>: palegreen&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 解决了上面两个方案的不足</p>
<p><strong>缺点：</strong> IE8及以下不支持 flex </p>
<h3 id="4-表格-table-解决方案"><a href="#4-表格-table-解决方案" class="headerlink" title="4.表格 table 解决方案"></a>4.表格 table 解决方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container4</span>&#123;<span class="attribute">display</span>: table;<span class="attribute">width</span>: <span class="number">100%</span>;<span class="attribute">min-height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-class">.container4</span> <span class="selector-tag">div</span>&#123;<span class="attribute">display</span>: table-cell;&#125;</span><br><span class="line"><span class="selector-class">.container4</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.container4</span> <span class="selector-class">.right</span>&#123;<span class="attribute">width</span>: <span class="number">300px</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.container4</span> <span class="selector-class">.center</span>&#123;<span class="attribute">background</span>: palegreen;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 轻易的做到，表格兼容性非常好，flex解决不了的（IE8不支持flex），想实现同样效果可以用表格。</p>
<p><strong>缺点：</strong> 历史的诟病以外，其中某一个单元格的高度超出了的时候，两侧的单元格也是要调整高度的；有时候的场景是不需要同时增高的。</p>
<h3 id="5-新技术-Grid-方案"><a href="#5-新技术-Grid-方案" class="headerlink" title="5.新技术 Grid 方案"></a>5.新技术 Grid 方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container5</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container5</span> <span class="selector-tag">div</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-class">.container5</span> <span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.container5</span> <span class="selector-class">.right</span>&#123;<span class="attribute">background-color</span>: palegreen;&#125;</span><br><span class="line"><span class="selector-class">.container5</span> <span class="selector-class">.center</span>&#123;<span class="attribute">background-color</span>: <span class="number">#ccc</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> 可以做很多复杂的布局，代码量也简化很多，是未来的趋势；</p>
<p><strong>缺点：</strong> 兼容性问题，各种浏览器及旧版本支持不是很好。</p>
<h3 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h3><p>在业务中的方案根据上面的优缺点来应对需求使用相应的布局方案。笔者考虑到兼容性及其他因素在这里推荐 <strong>flex</strong>和<strong>table</strong>俩种方案。</p>
<h3 id="三栏布局上下高度固定"><a href="#三栏布局上下高度固定" class="headerlink" title="三栏布局上下高度固定"></a>三栏布局上下高度固定</h3><p>看了上面那么多方案，是否自己也可以手动实现一下三栏上下高度固定，中间自适应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&#x27;flex-layout&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>7.三栏布局上下固定, 中间自适应:flex box方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;three_columns&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span>上<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flex box布局<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>下<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.three_columns</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three_columns</span> <span class="selector-class">.top</span>,</span><br><span class="line"><span class="selector-class">.three_columns</span> <span class="selector-class">.bottom</span>&#123;<span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background</span>: palegreen;&#125;</span><br><span class="line"><span class="selector-class">.three_columns</span> <span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>实现俩栏布局,右边固定,左边自适应</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>6.俩栏布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&#x27;two-column&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是俩栏布局,右边固定,左边自适应<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是俩栏布局,右边固定,左边自适应<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two-column</span>&#123;<span class="attribute">display</span>: flex;&#125;</span><br><span class="line"><span class="selector-class">.two-column</span> <span class="selector-tag">div</span>&#123;<span class="attribute">min-height</span>: <span class="number">100px</span>;&#125;</span><br><span class="line"><span class="selector-class">.two-column</span> <span class="selector-class">.right</span>&#123;<span class="attribute">width</span>: <span class="number">400px</span>;<span class="attribute">background</span>: palegreen;&#125;</span><br><span class="line"><span class="selector-class">.two-column</span> <span class="selector-class">.left</span>&#123;<span class="attribute">flex</span>:<span class="number">1</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>&#125;</span><br></pre></td></tr></table></figure>

<p>总结：语义化标签对SEO更友好。代码书写的规范方便后期的维护。</p>
<p><a href="https://root-lucas.github.io/Code-Examples/HTML5/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E7%9A%845%E7%A7%8D%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95.html">本章代码在线阅览效果地址</a></p>
<p>如果你觉得该文章能帮助到你，这里欢迎<a href="https://github.com/root-lucas/Code-Examples">star小星星</a>。</p>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒模型详解</title>
    <url>/2019/12/12/ui-she-ji/04.html-css/02.css-he-mo-xing-xiang-jie/</url>
    <content><![CDATA[<h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><ul>
<li>基本概念： 标准模型 + IE 模型</li>
<li>标准模型和IE模型的区别</li>
<li>CSS 如何设置这俩种模型</li>
<li>JS 如何设置获取盒模型对应的宽和高</li>
<li>实例 （根据盒模型解释边距重叠）</li>
<li>BFC （边距重叠的解决方案）</li>
</ul>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p>
<p>盒子一共有四部分：</p>
<ul>
<li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。（虽然margin不是盒子宽度 但却占用 像素）</li>
<li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li>
<li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li>
<li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li>
</ul>
<p><strong>根据浏览器的不同将盒子模型分为俩种：</strong> 标准模型和IE模型</p>
<h2 id="2-标准模型和IE模型的区别"><a href="#2-标准模型和IE模型的区别" class="headerlink" title="2.标准模型和IE模型的区别"></a>2.标准模型和IE模型的区别</h2><p>在做出区别之前我们在这里先了解CSS盒子模型是怎么计算的！</p>
<p>示例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">25px</span> solid green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS盒子的总宽度 = 内容宽度 + 填充宽度 + 边框宽度 + 外边框宽度；</p>
<p>CSS盒子的总宽度计算公式 = width + padding-left + padding-right + border-left + border-right + margin-left + margin-right；</p>
<p>以上面的CSS例子作准：</p>
<p>让我们自己算算：<code>300px (宽) + 50px (左 + 右填充) + 50px (左 + 右边框) + 50px (左 + 右外边距) = 450px</code></p>
<p>好了我们知道CSS盒子模型的计算方式我们下面来讲述标准模型和IE模型</p>
<p><strong>1.W3C盒子模型（标准盒模型）：</strong></p>
<p><img src="https://img4.mukewang.com/5b73f51e00015f7907740523.jpg" alt="img"></p>
<p><strong>标准模型</strong>的宽度是：<strong>content的宽度，不包含padding和border</strong>；（内容content是一个独立的部分）</p>
<p><strong>2.IE盒子模型（怪异盒模型）：</strong></p>
<p><img src="https://img1.mukewang.com/5b73f53f0001a7ec07610507.jpg" alt="img"></p>
<p><strong>IE模型</strong>的宽度是：<strong>宽和高是计算 border 和 padding 的</strong>。</p>
<p>计算方式：width + border + padding</p>
<h2 id="3-CSS-如何设置这俩种模型"><a href="#3-CSS-如何设置这俩种模型" class="headerlink" title="3.CSS 如何设置这俩种模型"></a>3.CSS 如何设置这俩种模型</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:content-box</span>;（标准模型<span class="selector-tag">--</span>浏览器默认）   </span><br><span class="line"><span class="selector-tag">box-sizing</span><span class="selector-pseudo">:border-box</span>;（<span class="selector-tag">IE</span>模型<span class="selector-tag">--IE</span>浏览器专属）</span><br></pre></td></tr></table></figure>

<h2 id="4-JS-如何设置获取盒模型对应的宽和高"><a href="#4-JS-如何设置获取盒模型对应的宽和高" class="headerlink" title="4.JS 如何设置获取盒模型对应的宽和高"></a>4.JS 如何设置获取盒模型对应的宽和高</h2><p>获取盒模型的方式有四种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>dom.style.width/height(只能取内联样式的宽和高,支持读写)</span><br><span class="line">    ----getElementById(<span class="string">&#x27;div&#x27;</span>).style.width/height</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>dom.currentStyle.width/height</span><br><span class="line">(渲染之后的宽高--只有IE支持)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="built_in">window</span>.getComputedStyle(dom).width/height</span><br><span class="line">(渲染之后的宽高--兼容性通用型更好一些,包括了内联样式、嵌入样式和外部样式,支持读取但不支持写入)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>dom.getBoundingClientRect().width/height</span><br><span class="line">(适用场景：计算一个元素的绝对位置；这个绝对位置根据视窗</span><br><span class="line">也就是左上角这个位置的绝对位置) 这个方法可以拿到四个元素：left top width height)</span><br></pre></td></tr></table></figure>

<h2 id="5-根据盒模型解释边距重叠"><a href="#5-根据盒模型解释边距重叠" class="headerlink" title="5.根据盒模型解释边距重叠"></a>5.根据盒模型解释边距重叠</h2><p><strong>1.父子元素边距重叠</strong></p>
<p>已知子元素高度为100px，距父元素顶部10px，计算父元素的高度？</p>
<ol>
<li>因为父元素和子元素存在边距重叠(margin-top)，所以父元素高度为100px；</li>
<li>父元素设置了overflow：hidden；之后父元素高度为110px；</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    *&#123;<span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-tag">blue</span>;  <span class="comment">/*若是不加overflow则父背景与子背景重叠,被覆盖*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* overflow: hidden; 父子元素边距重叠 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.child</span>&#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        margin-top: 10px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&#x27;parent&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&#x27;child&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>overflow:hidden;</code> 解决了重叠问题；相当于给父元素创建了一个BFC（块级格式化上下文，后面会讲）</p>
<p><strong>2.兄弟元素重叠</strong></p>
<p>若是兄弟元素都存在上边距或者下边距，发生重叠则取最大值；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        *&#123;<span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.brother1</span>&#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin-bottom</span>: 20<span class="selector-tag">px</span>;    <span class="comment">/*与下面的元素重叠,20px较10px大则取最大值*/</span></span></span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.brother2</span>&#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&#x27;brother1&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&#x27;brother2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>borther1</code>元素下边距为20px，下面那个<code>brother2</code>元素上边距为10px，因此发生了重叠，根据两者之间取最大值则会合并成20px。大多数边距重叠都会发生在兄弟重叠。</p>
<p><strong>3.空元素</strong></p>
<p>如果一个无内容空元素设置上下边距，其自身上下边距也会产生重叠，从margin-top\margin-bottom取一个最大值，作为它的一个边距。   </p>
<h2 id="6-BFC-（边距重叠的解决方案）"><a href="#6-BFC-（边距重叠的解决方案）" class="headerlink" title="6.BFC （边距重叠的解决方案）"></a>6.BFC （边距重叠的解决方案）</h2><p>BFC是块级元素格式化上下文，IFC是内联元素格式化上下文。</p>
<p><strong>BFC的原理（渲染规则）：</strong></p>
<ol>
<li>在BFC这个元素的垂直方向的边距会发生重叠</li>
<li>BFC的区域不会与浮动元素的相重叠（清除浮动布局）</li>
<li>BFC在页面是一个独立的容器，外面的元素不会影响它里面元素，反过来一样</li>
<li>计算BFC高度的时候浮动元素也会参与计算</li>
</ol>
<p><strong>如何创建BFC？</strong></p>
<ul>
<li>overflow 不为 visible</li>
<li>float值不为 none（只要有浮动，当前元素就创建了BFC）</li>
<li>position不为 static 和relative</li>
<li>display为 inline-block, table-cell, table-caption, flex, inline-flex</li>
</ul>
<p><strong>BFC使用场景</strong></p>
<ol>
<li>在写页面布局的时候不想有这个重叠，就给子元素增加一个父元素，<strong>父元素创建一个BFC就能解决问题；</strong></li>
<li>布局相关的BFC应用:</li>
</ol>
<p><strong>应用1：BFC垂直方向边距重叠</strong></p>
<p>垂直方向三个p元素，p{margin:5px auto 25px},之后第二个第三个的上边距变成25px；发生了边距重叠，取得的是最大值；如果不想重叠，就需要再那个元素在加一个父级div，<strong>对父级div创建BFC（overflow：hidden）</strong></p>
<p><strong>应用2：BFC不与float重叠</strong></p>
<p>两栏布局，左边宽度固定左浮动height：100px，右边自适应height：120px;右边的高度增高的时候，右边的背景色已经侵染到了左侧，（当布局的时候左侧没有float元素，它依然会往左侵染），解决方法：<strong>给右侧元素创建一个BFC（overflow：atuo）</strong></p>
<p><strong>应用3：清除浮动；（BFC子元素即使是float元素也会参与计算）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.layout&#123;<span class="attr">background</span>:orange&#125;</span><br><span class="line">.float&#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line"></span><br><span class="line">----&gt;只看到.float的内容没看到父级的背景颜色；父级高度为<span class="number">0</span>；</span><br><span class="line">----&gt;一个普通的元素当子元素是float元素的时候，它的高度计算没有包含进来；</span><br><span class="line"></span><br><span class="line">.layout&#123;<span class="attr">background</span>:orange;overflow:hidden;&#125;</span><br><span class="line">.float&#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line"></span><br><span class="line">----&gt;给layout设置BFC之后，float内容有了背景颜色，父级有了高度；</span><br><span class="line">----&gt;当把外层元素设为BFC的时候，子元素的浮动元素也会参与父级的高度计算；</span><br></pre></td></tr></table></figure>

<p>演示代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        *&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.BFC 垂直方向边距重叠 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;margin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#margin</span>&#123;</span></span><br><span class="line">                background: palegoldenrod;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-id">#margin</span>&gt;<span class="selector-tag">p</span>&#123;</span></span><br><span class="line">                margin-bottom: 45px;</span><br><span class="line">                background: red;</span><br><span class="line">                border: 1px solid blue;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden;&quot;</span>&gt;</span>   <span class="comment">&lt;!-- 不产生边距重叠 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.BFC 不与float重叠 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#layout</span>&#123;</span></span><br><span class="line">                background: red;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-id">#layout</span> <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background: pink;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-id">#layout</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">                height: 110px;</span><br><span class="line"><span class="css">                <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">                overflow: auto;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.BFC 子元素即使是float也会参与高度计算 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;float&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-id">#float</span>&#123;</span></span><br><span class="line">                background: red;</span><br><span class="line">                overflow: auto;</span><br><span class="line"><span class="css">                <span class="comment">/* float: left; */</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-id">#float</span> <span class="selector-class">.float</span>&#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">                font-size: 30px;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float&quot;</span>&gt;</span>我是浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>应用4：BFC的元素在计算高度的时候会考虑内部子元素float</strong><br>（子元素是float也不影响父元素高度的计算，它的内容页会被参与进来）</p>
]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件详解</title>
    <url>/2019/12/12/ui-she-ji/04.html-css/03.dom-shi-jian-xiang-jie/</url>
    <content><![CDATA[<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><ul>
<li>基本概念： DOM事件的级别</li>
<li>DOM 事件模型</li>
<li>DOM 事件流</li>
<li>描述 DOM 事件捕获的具体流程</li>
<li>Event 对象的常见应用</li>
<li>自定义事件</li>
</ul>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DOM事件类   </span><br><span class="line">DOM1标准制定的时候没有涉及任何和事件相关的东西;</span><br><span class="line"></span><br><span class="line">事件级别</span><br><span class="line">    DOM0    element.onclick=function()&#123;&#125;;</span><br><span class="line">    //--&gt;true,false指定冒泡还是捕获</span><br><span class="line">    </span><br><span class="line">	//IE attachEvent</span><br><span class="line">    DOM2    element.addEventListener(&#x27;click&#x27;,function()&#123;&#125;,false);</span><br><span class="line">	//--&gt;默认是false(冒泡),true是捕获</span><br><span class="line"></span><br><span class="line">    //事件类型增加了很多；</span><br><span class="line">    DOM3    element.addEventListener(&#x27;keyup&#x27;,function()&#123;&#125;,false);</span><br></pre></td></tr></table></figure>

<h3 id="2-DOM-事件模型"><a href="#2-DOM-事件模型" class="headerlink" title="2.DOM 事件模型"></a>2.DOM 事件模型</h3><p>事件模型过程：</p>
<ol>
<li><p>捕获（从上往下）<code>element.addEventListener(&#39;click&#39;,function()&#123;&#125;,true);</code>        </p>
</li>
<li><p>冒泡（从目标元素往上）<code>element.addEventListener(&#39;click&#39;,function()&#123;&#125;,false);</code></p>
</li>
</ol>
<h3 id="3-DOM-事件流"><a href="#3-DOM-事件流" class="headerlink" title="3.DOM 事件流"></a>3.DOM 事件流</h3><p>浏览器在为当前页面与用户做交互的过程中，比如点击了鼠标左键，这个左键是怎么传到你的页面上，又是怎么响应的。</p>
<p><strong>一个完整的事件流分三个阶段：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、捕获阶段	   用户点击了鼠标</span><br><span class="line"><span class="number">2</span>、目标阶段     事件通过捕获到达目标元素</span><br><span class="line"><span class="number">3</span>、冒泡阶段     从目标元素上传到<span class="built_in">window</span>对象后响应给用户看到</span><br></pre></td></tr></table></figure>

<h3 id="4-描述-DOM-事件捕获的具体流程"><a href="#4-描述-DOM-事件捕获的具体流程" class="headerlink" title="4.描述 DOM 事件捕获的具体流程"></a>4.描述 DOM 事件捕获的具体流程</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">第一个接受事件的对象是<span class="built_in">window</span>;</span><br><span class="line">取得body标签：<span class="built_in">document</span>.body;</span><br><span class="line">表示html节点：<span class="built_in">document</span>.documentElement;  <span class="comment">// 等于html全部节点(除了!doctype)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// window对象是浏览器提供的, 根据浏览器厂商不同而异</span></span><br><span class="line"><span class="comment">// document对象是W3C标准, 统一的</span></span><br><span class="line"><span class="comment">// window.document可以拿到整个页面所有内容</span></span><br></pre></td></tr></table></figure>



<p><img src="https://upload-images.jianshu.io/upload_images/1620777-dafb1778461af7d9.png" alt="事件流程图"></p>
<p>捕获流程： window–&gt;document–&gt;html标签–&gt;body–&gt;父级元素–子级元素…–&gt;目标元素</p>
<p>冒泡流程：从目标元素一层一层最后到window完成了一次冒泡的流程 ； </p>
<h3 id="5-Event对象的常见应用"><a href="#5-Event对象的常见应用" class="headerlink" title="5.Event对象的常见应用"></a>5.Event对象的常见应用</h3><ul>
<li><strong>1.event.preventDefault(); 阻止默认行为</strong> ：绑定事件后会阻止了a元素的链接跳转</li>
<li><strong>2.event.stopPropagation(); 阻止冒泡</strong> ：父级元素、子元素都绑定有事件，触发子元素事件的同时也会触发父元素事件</li>
<li><strong>3.event.stoplmmediatePropagation(); 事件响应优先级</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个按钮绑定了两个click事件1和2，想通过优先级的方式，第一个响应函数是a，</span><br><span class="line">第二个响应函数是b，依次注册了a、b两个事件，想让执行a之后完不再执行b了；</span><br><span class="line">a响应函数中加上上面那个代码，就会成功的阻止b执行；</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>4.event.currentTarget（currentTarget当前绑定事件的对象；指定的是父级元素)：</strong>  事件委托中会得到 <code>ul</code> 元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把子元素的事件代理都转移到父元素上，只绑定一次事件就可以了。做响应的时候就要区分是哪个元素被触发。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>5.event.target（target是当前被点击的元素）：</strong> 事件委托中会得到 <code> li</code> 元素</li>
</ul>
<h3 id="6-自定义事件-模拟事件"><a href="#6-自定义事件-模拟事件" class="headerlink" title="6.自定义事件(模拟事件)"></a>6.自定义事件(模拟事件)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建自定义事件, Event是无法传递参数的</span></span><br><span class="line"><span class="keyword">var</span> newEve = <span class="keyword">new</span> Event(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line">element.addEventListener(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Im is a custome event&#x27;</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发自定义事件newEve</span></span><br><span class="line">element.dispatchEvent(newEve);</span><br></pre></td></tr></table></figure>

<p><code>Event</code>对象的不足只能指定<strong>事件名</strong>，如果想给这个事件加些数据，Event是做不到的；得用<code>CustomEvent</code>对象；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建自定义事件, CustomEvent是可以传递参数的</span></span><br><span class="line"><span class="keyword">var</span> newEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="attr">detail</span>: elem.dataset.time &#125;);	<span class="comment">// 点击后拿到值2019-10-01</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; data-time=&quot;2019-10-01&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.监听事件</span></span><br><span class="line">elemment.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.发送/触发事件Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>举一例子来写出上面的事件DOM讲述的模型。</p>
<p><strong>DOM事件捕获的具体流程以及自定义事件的方法：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#btn</span>&#123;</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">data-name</span>=<span class="string">&#x27;hello root&#x27;</span>&gt;</span>目标元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> eve = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 下面为捕获流程, 与代码顺序无关, 改为冒泡则将true改为false即可</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;window captrue!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;docuemnt captrue!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.documentElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;HTML captrue!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;body captrue!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        eve.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;element captrue!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.使用Event创建自定义事件,  Event是无法传递参数的</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> newEve1 = <span class="keyword">new</span> Event(<span class="string">&#x27;hello&#x27;</span>);  </span></span><br><span class="line"><span class="javascript">        eve.addEventListener(<span class="string">&#x27;hello&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;Im is a custome event&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 触发Event自定义事件newEve1, 业务中一般放在别的事件中响应</span></span></span><br><span class="line">        eve.dispatchEvent(newEve1); </span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;================================&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 2.使用CustomEvent创建自定义事件, CustomEvent是可以传递参数的</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newEvent2 = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="attr">detail</span>: eve.dataset.name &#125;);	<span class="comment">// 点击后拿到值hello root</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">data-name</span>=<span class="string">&#x27;hello root&#x27;</span>&gt;</span>目标元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听事件</span></span></span><br><span class="line"><span class="javascript">        eve.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;Im is a custome CustomEvent&#x27;</span>,e.detail);    <span class="comment">// 传递参数</span></span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">false</span>);</span></span><br><span class="line">            </span><br><span class="line"><span class="javascript">        <span class="comment">// 发送/触发事件</span></span></span><br><span class="line">        eve.dispatchEvent(newEvent2);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6重难点整理</title>
    <url>/2019/04/29/qian-duan-zhi-shi-ti-xi/01.javascript/es6-chong-nan-dian-zheng-li/</url>
    <content><![CDATA[<p>👇 内容速览 👇</p>
<ul>
<li>let 和 const</li>
<li>Set 和 Map</li>
<li>Generator 和 yield</li>
<li>Promise、async/await 介绍</li>
<li>Proxy 代理器</li>
<li>…</li>
</ul>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><p>ES6 新增了<code>let</code>和<code>const</code>，它们声明的变量，都处于“块级作用域”。并且不存在“变量提升”，不允许重复声明。</p>
<p>同时，<code>const</code>声明的变量所指向的内存地址保存的数据不得改变：</p>
<ul>
<li>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</li>
<li>对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），不能保证指向的数据结构不可变。</li>
</ul>
<p>如果要保证指向的数据结构也不可变，需要自行封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冻结对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">obj</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constantize</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.isFrozen(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果属性是对象，递归冻结</span></span><br><span class="line">    <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> &amp;&amp; (obj[key] = constantize(obj[key]));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********测试代码 **********/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: &#123;</span><br><span class="line">      a: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  d: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fronzenObj = constantize(obj);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fronzenObj.d = [];</span><br><span class="line">  fronzenObj.b.c = <span class="number">3</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><blockquote>
<p>题目：解释下<code>Set</code>和<code>Map</code>。</p>
</blockquote>
<ul>
<li>Set 元素不允许重复</li>
<li>Map 类似对象，但是它的键（key）可以是任意数据类型</li>
</ul>
<p><strong>①Set 常用方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化一个set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素，返回Set本身</span></span><br><span class="line">set.add(<span class="number">5</span>).add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set大小</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查元素存在</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，返回bool</span></span><br><span class="line"><span class="keyword">let</span> success = set.delete(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(success);</span><br><span class="line"></span><br><span class="line">set.clear();</span><br></pre></td></tr></table></figure>

<p>其他遍历方法：由于没有键名，<code>values()</code>和<code>keys()</code>返回同样结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>②Map 常用方法</strong></p>
<p>Map 接口基本和 Set 一致。不同的是增加新元素的 API 是：<code>set(key, value)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以任意对象为 Key 值</span></span><br><span class="line"><span class="comment">// 这里以 Date 对象为例</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">map.set(key, <span class="string">&quot;today&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key));</span><br></pre></td></tr></table></figure>

<h3 id="Generator-与-yield"><a href="#Generator-与-yield" class="headerlink" title="Generator 与 yield"></a>Generator 与 yield</h3><p><code>generator</code>函数是 es6 提供的新特性，它的最大特点是：<strong>控制函数的执行</strong>。让我们从网上最火的一个例子来看：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>); <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>); <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>

<p>通俗的解释下为什么会有这种输出：</p>
<ol>
<li>给函数 foo 传入参数 5，但由于它是 generator，所以执行到<strong>第一个 yield 前</strong>就停止了。</li>
<li>第一次调用 next()，<strong>这次传入的参数会被忽略</strong>暂停**。</li>
<li>第二次调用 next(12)，<strong>传入的参数会被当作上一个 yield 表达式的返回值</strong>。因此，y = 2 * 12 = 24。执行到第二个 yield，返回其后的表达式的值 24 / 3 = 8。然后函数在此处暂停。</li>
<li>第三次调用 next(13)，没有 yield，只剩 return 了，按照正常函数那样返回 return 的表达式的值，并且<code>done</code>为<code>true</code>。</li>
</ol>
<p><strong>难点</strong>：在于为什么最后的<code>value</code>是 42 呢？</p>
<p>首先，<code>x</code>的值是刚开始调用 foo 函数传入的 5。而最后传入的 13 被当作第二个 yield 的返回值，所以<code>z</code>的值是 13。对于<code>y</code>的值，我们在前面第三步中已经计算出来了，就是 24。</p>
<p>所以，<code>x + y + z = 5 + 24 + 13 = 42</code></p>
<p>看懂了上面的分析，再看下面这段代码就很好理解了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next(); <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br></pre></td></tr></table></figure>

<p>只有第一次调用 next 函数的时候，输出的 value 是 6。其他时候由于没有给 next 传入参数，因此 yield 的返回值都是<code>undefined</code>，进行运算后自然是<code>NaN</code>。</p>
<h3 id="Promise-介绍"><a href="#Promise-介绍" class="headerlink" title="Promise 介绍"></a>Promise 介绍</h3><p>简单归纳下 Promise：<strong>三个状态、两个过程、一个方法</strong></p>
<ul>
<li>三个状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></li>
<li>两个过程（<strong>单向不可逆</strong>）：<ul>
<li><code>pending</code>-&gt;<code>fulfilled</code></li>
<li><code>pending</code>-&gt;<code>rejected</code></li>
</ul>
</li>
<li>一个方法<code>then</code>：<code>Promise</code>本质上只有一个方法，<code>catch</code>和<code>all</code>方法都是基于<code>then</code>方法实现的。</li>
</ul>
<p>请看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造 Promise 时候, 内部函数立即执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;new Promise&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;finifsh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="async-await-介绍"><a href="#async-await-介绍" class="headerlink" title="async/await 介绍"></a>async/await 介绍</h3><p><code>async</code>函数返回一个<code>Promise</code>对象，可以使用<code>then</code>方法添加回调函数。</p>
<p>当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>这也是它最受欢迎的地方：<strong>能让异步代码写起来像同步代码，并且方便控制顺序</strong>。</p>
<p>可以利用它实现一个<code>sleep</code>函数阻塞进程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">millisecond</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve, millisecond);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>); <span class="comment">// 睡眠1秒</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(); <span class="comment">// 执行测试函数</span></span><br></pre></td></tr></table></figure>

<p>虽然方便，<strong>但是它也不能取代<code>Promise</code>，尤其是我们可以很方便地用<code>Promise.all()</code>来实现并发</strong>，而<code>async/await</code>只能实现串行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, second);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chuanXingDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bingXingDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tasks = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    tasks.push(sleep(<span class="number">1000</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>bingXingDemo()</code>，几乎同时输出，它是并发执行；运行<code>chuanXingDemo()</code>，每个输出间隔 1s，它是串行执行。</p>
<h3 id="ES6-对象和-ES5-对象"><a href="#ES6-对象和-ES5-对象" class="headerlink" title="ES6 对象和 ES5 对象"></a>ES6 对象和 ES5 对象</h3><blockquote>
<p>题目：es6 class 的 new 实例和 es5 的 new 实例有什么区别？</p>
</blockquote>
<p>在<code>ES6</code>中（和<code>ES5</code>相比），<code>class</code>的<code>new</code>实例有以下特点：</p>
<ul>
<li><code>class</code>的构造参数必须是<code>new</code>来调用，不可以将其作为普通函数执行</li>
<li><code>es6</code> 的<code>class</code>不存在变量提升</li>
<li><strong>最重要的是：es6 内部方法不可以枚举</strong>。es5 的<code>prototype</code>上的方法可以枚举。</li>
</ul>
<p>为此我做了以下测试代码进行验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ES5Class()); <span class="comment">// es5:可以直接作为函数运行</span></span><br><span class="line"><span class="comment">// console.log(new ES6Class()) // 会报错：不存在变量提升</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5Class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES5Class.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6Class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> es5 = <span class="keyword">new</span> ES5Class();</span><br><span class="line"><span class="keyword">let</span> es6 = <span class="keyword">new</span> ES6Class();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐在循环对象属性的时候，使用for...in</span></span><br><span class="line"><span class="comment">// 在遍历数组的时候的时候，使用for...of</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;ES5 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">in</span> es5) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6:不可枚举</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;ES6 :&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> _ <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考/推荐</strong>：<a href="https://fed.renren.com/2017/08/07/js-oop-es52es6/">《JavaScript 创建对象—从 es5 到 es6》</a></p>
<h3 id="Proxy-代理器"><a href="#Proxy-代理器" class="headerlink" title="Proxy 代理器"></a>Proxy 代理器</h3><p>他可以实现 js 中的“元编程”：在目标对象之前架设拦截，可以过滤和修改外部的访问。</p>
<p>它支持多达 13 种拦截操作，例如下面代码展示的<code>set</code>和<code>get</code>方法，分别可以在设置对象属性和访问对象属性时候进行拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// receiver 指向 proxy 实例</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`GET: target is <span class="subst">$&#123;target&#125;</span>, property is <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`SET: target is <span class="subst">$&#123;target&#125;</span>, property is <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">0</span>, <span class="attr">d</span>: &#123; <span class="attr">e</span>: -<span class="number">1</span> &#125; &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">newObj.a; <span class="comment">// output: GET...</span></span><br><span class="line">newObj.b.c; <span class="comment">// output: GET...</span></span><br><span class="line"></span><br><span class="line">newObj.a = <span class="number">123</span>; <span class="comment">// output: SET...</span></span><br><span class="line">newObj.b.c = -<span class="number">1</span>; <span class="comment">// output: GET...</span></span><br></pre></td></tr></table></figure>

<p>运行这段代码，会发现最后一行的输出是 <code>GET ...</code>。也就是说它触发的是<code>get</code>拦截器，而不是期望的<code>set</code>拦截器。<strong>这是因为对于对象的深层属性，需要专门对其设置 Proxy</strong>。</p>
<p><strong>更多请见</strong>：<a href="http://es6.ruanyifeng.com/#docs/proxy">《阮一峰 ES6 入门：Proxy》</a></p>
<h3 id="EsModule-和-CommonJS-的比较"><a href="#EsModule-和-CommonJS-的比较" class="headerlink" title="EsModule 和 CommonJS 的比较"></a>EsModule 和 CommonJS 的比较</h3><p>目前 js 社区有 4 种模块管理规范：AMD、CMD、CommonJS 和 EsModule。 ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：</p>
<ul>
<li>CommonJS 支持动态导入，也就是 <code>require($&#123;path&#125;/xx.js)</code>，后者目前不支持，但是已有提案：<code>import(xxx)</code></li>
<li>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>commonJs 输出的是值的浅拷贝，esModule 输出值的引用</li>
<li>ES Module 会编译成 <code>require/exports</code> 来执行的</li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识梳理(下)</title>
    <url>/2019/03/26/qian-duan-zhi-shi-ti-xi/01.javascript/javascript-ji-chu-zhi-shi-shu-li-xia/</url>
    <content><![CDATA[<p>👇 内容速览 👇</p>
<ul>
<li>实现 ES5 继承的 4 种方法</li>
<li>原型和原型链</li>
<li>作用域和作用域链</li>
<li>Event Loop</li>
<li>执行上下文</li>
<li>闭包的理解和分析</li>
</ul>
<h3 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h3><blockquote>
<p>题目：ES5 中常用继承方法。</p>
</blockquote>
<p><strong>方法一：绑定构造函数</strong></p>
<p>缺点：不能继承父类原型方法/属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.species = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行父类的构造方法, 上下文为实例对象</span></span><br><span class="line">  Animal.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.species); <span class="comment">// output: 动物</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二：原型链继承</strong></p>
<p>缺点：无法向父类构造函数中传递参数；子类原型链上定义的方法有先后顺序问题。</p>
<p><strong>注意</strong>：js 中交换原型链，均需要修复<code>prototype.constructor</code>指向问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.species = species;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * func方法是无效的, 因为后面原型链被重新指向了Animal实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Cat.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat; <span class="comment">// 修复: 将Cat.prototype.constructor重新指向本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.func(); <span class="comment">// output: Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.species); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>方法 3:组合继承</strong></p>
<p>结合绑定构造函数和原型链继承 2 种方式，缺点是：调用了 2 次父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.species = species;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Animal.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">cat.func(); <span class="comment">// output: Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.species); <span class="comment">// output: cat</span></span><br></pre></td></tr></table></figure>

<p><strong>方法 4:寄生组合继承</strong></p>
<p>改进了组合继承的缺点，只需要调用 1 次父类的构造函数。<strong>它是引用类型最理想的继承范式</strong>。（引自：《JavaScript 高级程序设计》）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寄生组合继承的核心代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>sub 子类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>parent 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">sub, parent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到父类的原型</span></span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">  <span class="comment">// 改变constructor指向</span></span><br><span class="line">  prototype.constructor = sub;</span><br><span class="line">  <span class="comment">// 父类原型赋给子类</span></span><br><span class="line">  sub.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">species</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.species = species;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Animal.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 只调用了1次构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Cat, Animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">cat.func(); <span class="comment">// output: Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.species); <span class="comment">// output: cat</span></span><br></pre></td></tr></table></figure>

<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><ul>
<li>所有的引用类型（数组、对象、函数），都有一个<code>__proto__</code>属性，<del>属性值是一个普通的对象</del></li>
<li>所有的函数，都有一个 prototype 属性，属性值也是一个普通的对象</li>
<li>所有的引用类型（数组、对象、函数），<code>__proto__</code>属性值指向它的构造函数的 prototype 属性值</li>
</ul>
<p><strong>注</strong>：ES6 的箭头函数没有<code>prototype</code>属性，但是有<code>__proto__</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><blockquote>
<p>题目：如何理解 JS 中的原型？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建示例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.printName();</span><br><span class="line">f.alertName();</span><br></pre></td></tr></table></figure>

<p>但是执行<code>alertName</code>时发生了什么？这里再记住一个重点 <strong>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<code>__proto__</code>（即它的构造函数的<code>prototype</code>）中寻找</strong>，因此<code>f.alertName</code>就会找到<code>Foo.prototype.alertName</code>。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote>
<p>题目：如何 JS 中的原型链？</p>
</blockquote>
<p>以上一题为基础，如果调用<code>f.toString()</code>。</p>
<ol>
<li><code>f</code>试图从<code>__proto__</code>中寻找（即<code>Foo.prototype</code>），还是没找到<code>toString()</code>方法。</li>
<li>继续向上找，从<code>f.__proto__.__proto__</code>中寻找（即<code>Foo.prototype.__proto__</code>中）。<strong>因为<code>Foo.prototype</code>就是一个普通对象，因此<code>Foo.prototype.__proto__ = Object.prototype</code></strong></li>
<li>最终对应到了<code>Object.prototype.toString</code></li>
</ol>
<p>这是对深度遍历的过程，寻找的依据就是一个链式结构，所以叫做“原型链”。</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><blockquote>
<p>题目：如何理解 JS 的作用域和作用域链。</p>
</blockquote>
<p><strong>① 作用域</strong></p>
<p>ES5 有”全局作用域“和”函数作用域“。ES6 的<code>let</code>和<code>const</code>使得 JS 用了”块级作用域“。</p>
<p>为了解决 ES5 的全局冲突，一般都是闭包编写：<code>(function()&#123; ... &#125;)()</code>。将变量封装到函数作用域。</p>
<p><strong>② 作用域链</strong></p>
<p>当前作用域没有找到定义，继续向父级作用域寻找，直至全局作用域。<strong>这种层级关系，就是作用域链</strong>。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><blockquote>
<p>题目：讲解下面代码的执行过程和结果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="literal">false</span>;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;while执行了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会一直执行并且输出”while…”。<strong>JS 是单线程的，先跑执行栈里的同步任务，然后再跑任务队列的异步任务</strong>。</p>
<h4 id="执行栈和任务队列"><a href="#执行栈和任务队列" class="headerlink" title="执行栈和任务队列"></a>执行栈和任务队列</h4><blockquote>
<p>题目：说一下 JS 的 Event Loop。</p>
</blockquote>
<p>简单总结如下：</p>
<ol>
<li>JS 是单线程的，其上面的所有任务都是在两个地方执行：<strong>执行栈和任务队列</strong>。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。</li>
<li>当执行栈的任务都执行完了（栈空），js 会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。</li>
<li>这个过程是循环进行，所以称作<code>Loop</code>。</li>
</ol>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><blockquote>
<p>题目：解释下“全局执行上下文“和“函数执行上下文”。</p>
</blockquote>
<p>①<strong>全局执行上下文</strong></p>
<p>解析 JS 时候，创建一个 <strong>全局执行上下文</strong> 环境。把代码中即将执行的（<strong>内部函数的不算，因为你不知道函数何时执行</strong>）变量、函数声明都拿出来。**未赋值的变量就是<code>undefined</code>**。</p>
<p>下面这段代码输出：<code>undefined</code>；而不是抛出<code>Error</code>。因为在解析 JS 的时候，变量 a 已经存入了全局执行上下文中了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>②<strong>函数执行上下文</strong></p>
<p>和全局执行上下文差不多，但是多了<code>this</code>和<code>arguments</code>和参数。</p>
<p>在 JS 中，<code>this</code>是关键字，它作为内置变量，<strong>其值是在执行的时候确定（不是定义的时候确定）</strong>。</p>
<h3 id="闭包的理解和分析"><a href="#闭包的理解和分析" class="headerlink" title="闭包的理解和分析"></a>闭包的理解和分析</h3><blockquote>
<p>题目：解释下 js 的闭包</p>
</blockquote>
<p>直接上<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN</a>的解释：闭包是<strong>函数</strong>和<strong>声明该函数的词法环境</strong>的组合。</p>
<p>而在 JavaScript 中，函数是被作为一级对象使用的，它既可以本当作值返回，还可以当作参数传递。理解了：“<strong>Js 中的函数运行在它们被定义的作用域，而不是它们被执行的作用域</strong>”（摘自《JavaScript 语言精粹》） 这句话即可。</p>
<blockquote>
<p>题目：闭包优缺点</p>
</blockquote>
<p>闭包封住了变量作用域，有效地防止了全局污染；但同时，它也存在<strong>内存泄漏</strong>的风险：</p>
<ul>
<li>在浏览器端可以通过强制刷新解决，对用户体验影响不大</li>
<li>在服务端，由于 node 的内存限制和累积效应，可能会造成进程退出甚至服务器沓机</li>
</ul>
<p>解决方法是显式对外暴露一个接口，专门用以清理变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mem = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    clear: <span class="function">() =&gt;</span> (mem = <span class="literal">null</span>), <span class="comment">// 显式暴露清理接口</span></span><br><span class="line"></span><br><span class="line">    get: <span class="function"><span class="params">page</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (page <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[page];</span><br><span class="line">      &#125;</span><br><span class="line">      mem[page] = <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识梳理(上)</title>
    <url>/2019/03/26/qian-duan-zhi-shi-ti-xi/01.javascript/javascript-ji-chu-zhi-shi-shu-li-shang/</url>
    <content><![CDATA[<p>👇 内容速览 👇</p>
<ul>
<li>  普通函数和箭头函数的<code>this</code></li>
<li>  原始数据类型及其判断和转化方法</li>
<li>  深浅拷贝及实现</li>
<li>  JS 事件模型</li>
<li>  常见的高阶函数</li>
</ul>
<h3 id="普通函数和箭头函数的-this"><a href="#普通函数和箭头函数的-this" class="headerlink" title="普通函数和箭头函数的 this"></a>普通函数和箭头函数的 this</h3><p>还是一道经典题目，下面的这段代码的输出是什么？（为了方便解释，输出放在了注释中）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 1. &#123;a: 100&#125;</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 2. Window</span></span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通 JS</span></span><br><span class="line">    arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 3. Window</span></span><br><span class="line">        <span class="keyword">return</span> item + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 箭头函数</span></span><br><span class="line">    <span class="keyword">let</span> brr = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;es6&#x27;</span>, <span class="built_in">this</span>) <span class="comment">// 4. &#123;a: 100&#125;</span></span><br><span class="line">        <span class="keyword">return</span> item + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>其实诀窍很简单，常见的基本是 3 种情况：es5 普通函数、es6 的箭头函数以及通过<code>bind</code>改变过上下文返回的新函数。</p>
<p>① <strong>es5 普通函数</strong>：</p>
<ul>
<li>  函数被直接调用，上下文一定是<code>window</code></li>
<li>  函数作为对象属性被调用，例如：<code>obj.foo()</code>，上下文就是对象本身<code>obj</code></li>
<li>  通过<code>new</code>调用，<code>this</code>绑定在返回的实例上</li>
</ul>
<p>② <strong>es6 箭头函数</strong>： 它本身没有<code>this</code>，会沿着作用域向上寻找，直到<code>global</code> / <code>window</code>。请看下面的这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inner = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner()()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run.bind(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)() <span class="comment">// Output: 1</span></span><br></pre></td></tr></table></figure>

<p>③ <strong>bind 绑定上下文返回的新函数</strong>：就是被第一个 bind 绑定的上下文，而且 bind 对“箭头函数”无效。请看下面的这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run.bind(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)() <span class="comment">// output: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次bind，上下文由第一个bind的上下文决定</span></span><br><span class="line">run.bind(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;).bind(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;)() <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure>

<p>最后，再说说这几种方法的优先级：new &gt; bind &gt; 对象调用 &gt; 直接调用</p>
<p>至此，这道题目的输出就说可以解释明白了。</p>
<h3 id="原始数据类型和判断方法"><a href="#原始数据类型和判断方法" class="headerlink" title="原始数据类型和判断方法"></a>原始数据类型和判断方法</h3><blockquote>
<p>题目：JS 中的原始数据类型？</p>
</blockquote>
<p>ECMAScript 中定义了 7 种原始类型：</p>
<ul>
<li>  Boolean</li>
<li>  String</li>
<li>  Number</li>
<li>  Null</li>
<li>  Undefined</li>
<li>  Symbol（新定义）</li>
<li>  BigInt（新定义）</li>
</ul>
<p><strong>注意</strong>：原始类型不包含 Object 和 Function</p>
<blockquote>
<p>题目：常用的判断方法？</p>
</blockquote>
<p>在进行判断的时候有<code>typeof</code>、<code>instanceof</code>。对于数组的判断，使用<code>Array.isArray()</code>：</p>
<ul>
<li><p>typeof：</p>
<ul>
<li>  typeof 基本都可以正确判断数据类型</li>
<li>  <code>typeof null</code>和<code>typeof [1, 2, 3]</code>均返回”object”</li>
<li>  ES6 新增：<code>typeof Symbol()</code>返回”symbol”</li>
</ul>
</li>
<li><p>instanceof：</p>
<ul>
<li><p>专门用于实例和构造函数对应</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Obj(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Obj) <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>  判断是否是数组：<code>[1, 2, 3] instanceof Array</code></p>
</li>
</ul>
</li>
<li><p>  Array.isArray()：ES6 新增，用来判断是否是’Array’。<code>Array.isArray(&#123;&#125;)</code>返回<code>false</code>。</p>
</li>
</ul>
<h3 id="原始类型转化"><a href="#原始类型转化" class="headerlink" title="原始类型转化"></a>原始类型转化</h3><p>当我们对一个“对象”进行数学运算操作时候，会涉及到对象 =&gt; 基础数据类型的转化问题。</p>
<p>事实上，当一个对象执行例如加法操作的时候，如果它是原始类型，那么就不需要转换。否则，将遵循以下规则：</p>
<ol>
<li>调用实例的<code>valueOf()</code>方法，如果有返回的是基础类型，停止下面的过程；否则继续</li>
<li>调用实例的<code>toString()</code>方法，如果有返回的是基础类型，停止下面的过程；否则继续</li>
<li>都没返回原始类型，就会报错</li>
</ol>
<p>请看下面的测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a + <span class="string">&#x27;123&#x27;</span>) <span class="comment">// output: a123</span></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">1</span>) <span class="comment">// output: 101</span></span><br><span class="line"><span class="built_in">console</span>.log(c + <span class="string">&#x27;123&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>除了<code>valueOf</code>和<code>toString</code>，es6 还提供了<code>Symbol.toPrimitive</code>供对象向原始类型转化，并且<strong>它的优先级最高</strong>！！稍微改造下上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">1</span>) <span class="comment">// output: 10001</span></span><br></pre></td></tr></table></figure>

<p>最后，其实关于<code>instanceof</code>判断是否是某个对象的实例，es6 也提供了<code>Symbol.hasInstance</code>接口，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(num) % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Odd = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.hasInstance](num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(num) % <span class="number">2</span> !== <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> Even) <span class="comment">// output: false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> Odd) <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><blockquote>
<p>题目：实现对象的深拷贝。</p>
</blockquote>
<p>在 JS 中，函数和对象都是浅拷贝（地址引用）；其他的，例如布尔值、数字等基础数据类型都是深拷贝（值引用）。</p>
<p>值得提醒的是，ES6 的<code>Object.assign()</code>和 ES7 的<code>...</code>解构运算符都是“浅拷贝”。实现深拷贝还是需要自己手动撸“轮子”或者借助第三方库（例如<code>lodash</code>）：</p>
<ul>
<li><p>  手动做一个“完美”的深拷贝函数：<a href="https://root-lucas.github.io/passages/2019-03-18-interview-js-code/">https://root-lucas.github.io/passages/2019-03-18-interview-js-code/</a></p>
</li>
<li><p>  借助第三方库：jq 的<code>extend(true, result, src1, src2[ ,src3])</code>、lodash 的<code>cloneDeep(src)</code></p>
</li>
<li><p>  <code>JSON.parse(JSON.stringify(src))</code>：这种方法有局限性，如果属性值是函数或者一个类的实例的时候，无法正确拷贝</p>
</li>
<li><p>借助 HTML5 的<code>MessageChannel</code>：这种方法有局限性，当属性值是函数的时候，会报错</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> MessageChannel()</span></span><br><span class="line"><span class="javascript">            port2.onmessage = <span class="function">(<span class="params">ev</span>) =&gt;</span> resolve(ev.data)</span></span><br><span class="line">            port1.postMessage(obj)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line">        a: 1,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: [1, 2],</span><br><span class="line"><span class="javascript">            d: <span class="string">&#x27;() =&gt; &#123;&#125;&#x27;</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    deepClone(obj).then(<span class="function">(<span class="params">obj2</span>) =&gt;</span> &#123;</span></span><br><span class="line">        obj2.b.c[0] = 100</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(obj.b.c) <span class="comment">// output: [1, 2]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(obj2.b.c) <span class="comment">// output: [100, 2]</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="JS-事件流"><a href="#JS-事件流" class="headerlink" title="JS 事件流"></a>JS 事件流</h3><h4 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h4><p>事件流分为：<strong>冒泡</strong>和<strong>捕获</strong>，顺序是先捕获再冒泡。</p>
<p><strong>事件冒泡</strong>：子元素的触发事件会一直向父节点传递，一直到根结点停止。此过程中，可以在每个节点捕捉到相关事件。可以通过<code>stopPropagation</code>方法终止冒泡。</p>
<p><strong>事件捕获</strong>：和“事件冒泡”相反，从根节点开始执行，一直向子节点传递，直到目标节点。</p>
<p><code>addEventListener</code>给出了第三个参数同时支持冒泡与捕获：默认是<code>false</code>，事件冒泡；设置为<code>true</code>时，是事件捕获。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100vw; background: red;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 事件捕获：先输出 &quot;外层click事件触发&quot;; 再输出 &quot;内层click事件触发&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> useCapture = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span></span><br><span class="line">    btn.addEventListener(</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;click&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;内层click事件触发&#x27;</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        useCapture</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    app.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;外层click事件触发&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="DOM0-级-和-DOM2-级"><a href="#DOM0-级-和-DOM2-级" class="headerlink" title="DOM0 级 和 DOM2 级"></a>DOM0 级 和 DOM2 级</h4><p><strong>DOM2 级</strong>：前面说的<code>addEventListener</code>，它定义了<code>DOM</code>事件流，捕获 + 冒泡。</p>
<p><strong>DOM0 级</strong>：</p>
<ul>
<li>  直接在 html 标签内绑定<code>on</code>事件</li>
<li>  在 JS 中绑定<code>on</code>系列事件</li>
</ul>
<p><strong>注意</strong>：现在通用<code>DOM2</code>级事件，优点如下：</p>
<ol>
<li>可以绑定 / 卸载事件</li>
<li>支持事件流</li>
<li>冒泡 + 捕获：相当于每个节点同一个事件，至少 2 次处理机会</li>
<li>同一类事件，可以绑定多个函数</li>
</ol>
<h3 id="常见的高阶函数"><a href="#常见的高阶函数" class="headerlink" title="常见的高阶函数"></a>常见的高阶函数</h3><p>没什么好说的，跑一下下面的代码就可以理解了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map: 生成一个新数组，遍历原数组，</span></span><br><span class="line"><span class="comment">// 将每个元素拿出来做一些变换然后放入到新的数组中</span></span><br><span class="line"><span class="keyword">let</span> newArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">item</span>) =&gt;</span> item * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`New array is <span class="subst">$&#123;newArr&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter: 数组过滤, 根据返回的boolean</span></span><br><span class="line"><span class="comment">// 决定是否添加到数组中</span></span><br><span class="line"><span class="keyword">let</span> newArr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`New array2 is <span class="subst">$&#123;newArr2&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce: 结果汇总为单个返回值</span></span><br><span class="line"><span class="comment">// acc: 累计值; current: 当前item</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current)</span><br><span class="line"><span class="keyword">const</span> sum2 = arr.reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2) <span class="comment">// 106</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript原型链</title>
    <url>/2019/03/24/qian-duan-zhi-shi-ti-xi/01.javascript/javascript-yuan-xing-lian/</url>
    <content><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>创建 (声明) 对象有几种方法</li>
<li>原型、构造函数、实例、原型链</li>
<li><code>instanceof</code> 的原理</li>
<li>new 运算符</li>
</ul>
<h3 id="一-创建对象有几种方法"><a href="#一-创建对象有几种方法" class="headerlink" title="一.  创建对象有几种方法"></a>一.  创建对象有几种方法</h3><h4 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test2 = &#123;<span class="attr">x</span>:<span class="number">123</span>,<span class="attr">y</span>:<span class="number">345</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(test2);<span class="comment">//&#123;x:123,y:345&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(test2.x);<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(test2.__proto__.x);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(test2.__proto__.x === test2.x);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="2-构造函数new"><a href="#2-构造函数new" class="headerlink" title="2.构造函数new"></a>2.构造函数new</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1 #通过new Object声明的一个对象</span></span><br><span class="line"><span class="keyword">var</span> test1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">x</span>:<span class="number">123</span>,<span class="attr">y</span>:<span class="number">345</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(test1);<span class="comment">//&#123;x:123,y:345&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.x);<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.__proto__.x);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.__proto__.x === test1.x);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2  #使用显式构造函数创建对象</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123; <span class="built_in">this</span>.name = name;&#125;;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&#x27;o3&#x27;</span>);  <span class="comment">//M &#123;name: &quot;o3&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>new的作用: 1.创了一个新对象; 2.this指向构造函数; 3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象</p>
<h4 id="3-内置方法"><a href="#3-内置方法" class="headerlink" title="3.内置方法"></a>3.内置方法</h4><p><code>Obejct.create(obj,descriptor)</code>,obj是对象,describe描述符属性(可选)，创建一个具有指定原型且可选择性地包含指定属性的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;<span class="attr">x</span>:<span class="number">123</span>,<span class="attr">y</span>:<span class="number">345</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> test = <span class="built_in">Object</span>.create(p);</span><br><span class="line"><span class="built_in">console</span>.log(test);<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(test.x);<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__.x);<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__.x === test.x);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__ === p)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create</code>方法是把参数中这个对象作为一个新对象的原型对象赋给<code>test</code>的，<code>test</code>本身不具备这个属性的，通过原型链来连接这个原型对象的。（所以<code>test</code>对象本身没有name这个属性，只能通过原型链来找name属性。</p>
<h4 id="三种方法的优缺点"><a href="#三种方法的优缺点" class="headerlink" title="三种方法的优缺点"></a>三种方法的优缺点</h4><ol>
<li>功能:都能实现对象的声明,并能够赋值和取值</li>
<li>继承性:内置方法创建的对象继承到__proto__属性上</li>
<li>隐藏属性:三种声明方法会默认为内部的每个成员（属性或方法）生成一些隐藏属性，这些隐藏属性是可以读取和可配置的,属性分类见下面：</li>
<li>属性读取:<code>Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptors()</code></li>
<li>属性设置:<code>Object.definePropertype或Object.defineProperties</code></li>
</ol>
<h3 id="二-原型链的关系"><a href="#二-原型链的关系" class="headerlink" title="二. 原型链的关系"></a>二. 原型链的关系</h3><p>下图仔细观察原型、构造函数、对象实例、原型链之间的关系。</p>
<p><img src="https://s2.ax1x.com/2020/01/12/lTUshD.png" alt="原型链的关系"></p>
<h4 id="1-对象实例"><a href="#1-对象实例" class="headerlink" title="1.对象实例"></a>1.对象实例</h4><p>​    只要是对象就是一个实例；回顾上面的创建对象的几种方式，任何一个实例对象都有一个隐式原型<code>__proto__</code>对象。</p>
<h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h4><p>凡是通过关键字<code>new</code>来操作后边的函数，这个函数就是构造函数；准确的说任何一个函数只要被new使用了，后面这个函数就可以被叫做构造函数。</p>
<p>构造函数可以使用<code>new</code>运算符来生成一个实例；</p>
<h4 id="3-原型对象"><a href="#3-原型对象" class="headerlink" title="3.原型对象"></a>3.原型对象</h4><p>任何一个函数都有一个<code>prototype</code>属性，他是函数所独有的，这个<code>prototype</code>指的就是显式原型对象；</p>
<p>任何一个实例对象都有一个<code>__proto__</code>对象。他是对象所独有的，这个<code>__proto__</code>指的就是隐式原型对象；</p>
<p><code>__proto__ </code>是原型链查询中实际用到的，它总是指向 <code>prototype</code>；</p>
<p><code>prototype</code> 是函数所独有的，在定义构造函数时自动创建，它总是被<code>__proto__</code>所指。</p>
<h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4.原型链"></a>4.原型链</h4><p>每个对象都可以有一个原型<code>_proto_</code>，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找知道终点<code>null</code>…… 这个操作被委托在整个原型链上，这个就是我们说的原型链了</p>
<p><strong>原型链是通过什么来实现这个往上找的过程呢？</strong><br>通过prototype这个原型和__proto__属性来完成原型链的查找的；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3174701-18a76d28c0a9ea1b" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;name:&#39;lucas&#39;&#125;;   </span><br><span class="line">obj1.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype  &#x2F;&#x2F; true</span><br><span class="line">obj1.__proto__.__proto__  			&#x2F;&#x2F; null  #这是原型链顶端了</span><br><span class="line">Object.prototype.__proto__  		&#x2F;&#x2F; null #这是原型链顶端了</span><br><span class="line"></span><br><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.__proto__.__proto__  &#x2F;&#x2F; null #这是原型链顶端了</span><br><span class="line"></span><br><span class="line">let person &#x3D; new Person();</span><br><span class="line">person.__proto__.__proto__.__proto__  &#x2F;&#x2F; null #这是原型链顶端了</span><br><span class="line">person.__proto__  &#x3D;&#x3D;&#x3D; Person.prototype  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M</span> (<span class="params">name</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">this</span>.name = name; </span><br><span class="line">&#125;<span class="comment">//person是构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&#x27;o3&#x27;</span>) <span class="comment">// personTwo是实例</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/10/22/16df35d0ab151801?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="原型关系详解"></p>
<blockquote>
<p>原型对象都有一个默认的constructor属性指向构造函数</p>
</blockquote>
<h3 id="三-instanceof-原理"><a href="#三-instanceof-原理" class="headerlink" title="三. instanceof 原理"></a>三. instanceof 原理</h3><p><code>instanceof</code>主要用于判断某个实例是否属于某个类型，也可用于判断某个实例是否是其父类型或者祖先类型的实例。</p>
<p><code>instanceof </code>主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，<code>instanceof </code>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例对象上有__proto__这个属性，实例对象的这个属性引用是它构造函数的原型对象（也就是找到的这个构造函数）；</span><br><span class="line">构造函数有prototype这个属性，这个属性引用的原型对象，在往下走，实例对象的__proto__这个属性，其实是引用这个原型对象。</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/12/lTDuX4.png" alt="instanceof原理图"></p>
<p><strong>模拟开发instanceof</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rightVal = right.prototype</span><br><span class="line">    <span class="keyword">const</span> leftVal = left.__proto__</span><br><span class="line">    <span class="comment">// 若找不到就到一直循环到父类型或祖类型</span></span><br><span class="line">    <span class="function"><span class="title">while</span>(<span class="params"><span class="literal">true</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftVal === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftVal === rightVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        leftVal = leftVal.__proto__ <span class="comment">// 获取祖类型的__proto__</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四-new-运算符"><a href="#四-new-运算符" class="headerlink" title="四. new 运算符"></a>四. new 运算符</h3><p><img src="https://s2.ax1x.com/2020/01/12/lTrM28.png" alt="new运算符"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new2 = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建一个空对象，这个对象要继承这个构造函数的原型对象（空对象要关联构造函数的原型对象；）</span></span><br><span class="line">    <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> k = func.call(o);<span class="comment">//call用来转移上下文（this），把这个上下文转成o对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.判断构造函数的运行结果是不是对象类型</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="keyword">typeof</span> k ===<span class="string">&#x27;object&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise概述</title>
    <url>/2019/04/24/qian-duan-zhi-shi-ti-xi/01.javascript/promise-gai-shu/</url>
    <content><![CDATA[<h2 id="关于Promise"><a href="#关于Promise" class="headerlink" title="关于Promise"></a>关于<code>Promise</code></h2><ul>
<li><code>Promise</code>实例一旦被创建就会被执行</li>
<li><code>Promise</code>过程分为两个分支：<code>pending=&gt;resolved</code>和<code>pending=&gt;rejected</code></li>
<li><code>Promise</code>状态改变后，依然会执行之后的代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> warnDemo = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(ctx);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;After resolved, but Run&quot;</span>); <span class="comment">// 依然会执行这个语句</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">warnDemo(<span class="string">&quot;ctx&quot;</span>).then(<span class="function"><span class="params">ctx</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;ctx&#125;</span>`</span>));</span><br></pre></td></tr></table></figure>

<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a><code>then</code>方法</h2><p>在<code>Console</code>键入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">t.__proto__;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。</p>
<p><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 必须返回一个Promise实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">            resolve(...) <span class="comment">// 传入resolve函数的参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(...)</span><br><span class="line">            reject(err) <span class="comment">// reject参数必须是Error对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(ARGS).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve 函数</span></span><br><span class="line">&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// reject 函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="连续调用then"><a href="#连续调用then" class="headerlink" title="连续调用then"></a>连续调用<code>then</code></h4><p>因为<code>then</code>方法返回另一个<code>Promise</code>对象。当这个对象状态发生改变，就会分别调用<code>resolve</code>和<code>reject</code></p>
<p>写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func(ARGS).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;).then(</span><br><span class="line">    ()=&gt;&#123; ... &#125;,</span><br><span class="line">    () =&gt; &#123; ... &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params">ready</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">      resolve(<span class="string">&quot;Right&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;arg is false&quot;</span>);</span><br><span class="line">      reject(error); <span class="comment">// 传入Error对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloWorld(<span class="literal">false</span>).then(</span><br><span class="line">  msg =&gt; &#123;</span><br><span class="line">    <span class="comment">// true：helloWorld的参数</span></span><br><span class="line">    <span class="comment">// 参数msg：在上面的Promise对象中传入了</span></span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a><code>catch</code>方法</h2><p>等同于 <code>.then(null, rejection)</code>。另外，<code>then</code>方法指定的回调函数运行中的错误，也会被<code>catch</code>捕获。</p>
<p>所以，之前的写法可以改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 必须返回一个Promise实例</span></span><br><span class="line">    <span class="keyword">const</span> promise =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">            resolve(...)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(...)</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(ARGS).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve 函数</span></span><br><span class="line">&#125;).catch(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// reject 函数</span></span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 没有错误就会跳过上面的catch</span></span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure>

<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a><code>finally</code>方法</h2><blockquote>
<p>指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。可以理解为<code>then</code>方法的实例，即在<code>resolve</code>和<code>reject</code>里面的公共操作函数</p>
</blockquote>
<h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a><code>all</code>方法</h2><blockquote>
<p>用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。它接收一个具有<code>Iterator</code>接口的参数。其中，<code>item</code>如果不是<code>Promise</code>对象，会自动调用<code>Promise.resolve</code>方法</p>
</blockquote>
<p>以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]); <span class="comment">// p是新包装好的一个Promise对象</span></span><br></pre></td></tr></table></figure>

<p>对于<code>Promise.all()</code>包装的<code>Promise</code>对象，只有实例的状态都变成<code>fulfilled</code>。</p>
<p>可以用来操作数据库：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise.then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise.then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([booksPromise, userPromise]).then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span></span><br><span class="line">  pickTopRecommentations(books, user)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。而对于每个<code>promise</code>对象，一旦它被自己定义<code>catch</code>方法捕获异常，那么状态就会更新为<code>resolved</code>而不是<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;p2 error&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">  .catch(</span><br><span class="line">    <span class="comment">// 如果注释掉 catch，进入情况2</span></span><br><span class="line">    <span class="comment">// 否则，情况1</span></span><br><span class="line">    e =&gt; e.message</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">  .then(</span><br><span class="line">    result =&gt; <span class="built_in">console</span>.log(result) <span class="comment">// 情况1</span></span><br><span class="line">  )</span><br><span class="line">  .catch(</span><br><span class="line">    e =&gt; <span class="built_in">console</span>.log(<span class="string">&quot;error in all&quot;</span>) <span class="comment">// 情况2</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h2 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a><code>race方法</code></h2><blockquote>
<p>和<code>all</code>方法类似，<code>Promise.race</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。而且只要有一个状态被改变，那么新的<code>Promise</code>状态会立即改变</p>
</blockquote>
<p>也是来自阮一峰大大的例子，如果 5 秒内无法<code>fetech</code>，那么<code>p</code>状态就会变为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">&quot;/resource-that-may-take-a-while&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;request timeout&quot;</span>)), <span class="number">5000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure>

<h2 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h2><h3 id="状态只改变一次"><a href="#状态只改变一次" class="headerlink" title="状态只改变一次"></a>状态只改变一次</h3><blockquote>
<p><code>Promise</code> 的状态一旦改变，就永久保持该状态，不会再变了。</p>
</blockquote>
<p>下面代码中，<code>Promise</code>对象<code>resolved</code>后，状态就无法再变成<code>rejected</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;ok&quot;</span>); <span class="comment">// 状态变成 resolved</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;test&quot;</span>); <span class="comment">// Promise 的状态一旦改变，就永久保持该状态</span></span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message); <span class="comment">// 所以，无法捕获错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="错误冒泡"><a href="#错误冒泡" class="headerlink" title="错误冒泡"></a>错误冒泡</h3><blockquote>
<p><code>Promise</code> 对象的错误具有“冒泡”性质，<strong>会一直向后传递，直到被捕获为止</strong>。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p>
</blockquote>
<h3 id="“吃掉错误”机制"><a href="#“吃掉错误”机制" class="headerlink" title="“吃掉错误”机制"></a>“吃掉错误”机制</h3><blockquote>
<p><code>Promise</code>会吃掉内部的错误，并不影响外部代码的运行。所以需要<code>catch</code>，以防丢掉错误信息。</p>
</blockquote>
<p>阮一峰大大给出的 demo：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;everything is great&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>还有如下 demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">someAsyncThing()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;oh no&quot;</span>, error);</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">    y + <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;carry on&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>demo 基本可以在<a href="http://es6.ruanyifeng.com/#docs/promise">阮一峰的 Es6 讲解</a>中找到，只是为了理解做了一些修改。</li>
<li>还有网上的一些博客，这里就不一一说明了</li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面向对象</title>
    <url>/2019/08/26/qian-duan-zhi-shi-ti-xi/01.javascript/javascript-mian-xiang-dui-xiang/</url>
    <content><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>类与实例<ul>
<li>类的声明</li>
<li>生成实例</li>
</ul>
</li>
<li>类与继承<ul>
<li>如何实现继承</li>
<li>继承的几种方式</li>
</ul>
</li>
</ul>
<h2 id="一-类与实例"><a href="#一-类与实例" class="headerlink" title="一. 类与实例"></a>一. 类与实例</h2><p>JavaScript的所有数据都可以看成对象（一切皆为对象）。那是不是我们已经在使用面向对象编程了呢？</p>
<p>当然不是。如果我们只使用<code>Number</code>、<code>Array</code>、<code>string</code>以及基本的<code>&#123;...&#125;</code>定义的对象，还无法发挥出面向对象编程的威力。</p>
<p>JavaScript 的ES6标准还没出来之前是不区分类和实例的概念，而是通过原型（prototype）(模拟类的)来实现面向对象编程。</p>
<h3 id="1-类的声明"><a href="#1-类的声明" class="headerlink" title="1.类的声明"></a>1.类的声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6中的Class关键字的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-生成实例"><a href="#2-生成实例" class="headerlink" title="2.生成实例"></a>2.生成实例</h3><p>通过<code>new</code> 关键字来实例化上面的声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal(), <span class="keyword">new</span> Animal2());</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/12/lTg6Cn.png" alt="类"></p>
<h2 id="二-类与继承"><a href="#二-类与继承" class="headerlink" title="二. 类与继承"></a>二. 类与继承</h2><h3 id="1-如何实现继承"><a href="#1-如何实现继承" class="headerlink" title="1.如何实现继承"></a>1.如何实现继承</h3><p>js中实现继承的方式主要是通过原型链完成的。</p>
<p>JavaScript的原型继承实现方式就是：</p>
<ol>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ol>
<h3 id="2-继承的几种方式"><a href="#2-继承的几种方式" class="headerlink" title="2.继承的几种方式"></a>2.继承的几种方式</h3><h4 id="1-借助构造函数实现继承"><a href="#1-借助构造函数实现继承" class="headerlink" title="1.借助构造函数实现继承"></a>1.借助构造函数实现继承</h4><p><strong>核心：</strong> 使用父类的构造函数(<code>Parent1.prototype.constructor</code>)来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）（只实现了部分继承，如果父类的属性都在构造函数上，那没有问题；如果父类的原型对象上还有方法，那子类是拿不到这些方法的）</p>
<p><strong>缺点：</strong> 方法都在构造函数中定义， 只能继承父类的<strong>实例属性和方法</strong>，不能继承<strong>原型属性/方法</strong>，无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.friends = [<span class="string">&#x27;小李&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>];</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent1.prototype.geSex = function () &#123;    //这里对原型进行扩展的方法就无法复用了</span></span><br><span class="line"><span class="comment">//   console.log(&quot;男&quot;);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent1.call(<span class="built_in">this</span>,<span class="string">&#x27;老明&#x27;</span>);　　<span class="comment">//这一句是核心关键</span></span><br><span class="line">    <span class="comment">//这样就会在新Child1对象上执行Parent1构造函数中定义的所有对象初始化代码，</span></span><br><span class="line">    <span class="comment">// 结果Child1的每个实例都会具有自己的friends属性的副本</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Child1(<span class="number">23</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.name);　　　　<span class="comment">//老明</span></span><br><span class="line"><span class="built_in">console</span>.log(result.friends);　　<span class="comment">//[&quot;小李&quot;, &quot;小红&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(result.getName());　　<span class="comment">//老明</span></span><br><span class="line"><span class="built_in">console</span>.log(result.age);　　　　<span class="comment">//23</span></span><br><span class="line"><span class="built_in">console</span>.log(result.getSex());　　<span class="comment">//这个会报错，调用不到父原型上面扩展的方法</span></span><br></pre></td></tr></table></figure>



<h4 id="2-借助原型链实现继承"><a href="#2-借助原型链实现继承" class="headerlink" title="2.借助原型链实现继承"></a>2.借助原型链实现继承</h4><p><strong>弥补构造函数实现继承不足</strong>。</p>
<p><strong>核心:</strong>   将父类的实例作为子类的原型</p>
<p><strong>缺点：</strong> 在一个类上实例了两个对象，改第一个对象的属性，第二个对象也跟着改变； 引起这个问题的原因：原型链上的原型对象是共用的；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Parent2.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">//对原型进行扩展</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2(<span class="string">&#x27;老明&#x27;</span>);   <span class="comment">//这一句是关键 //通过构造器函数创建出一个新对象，把老对象的东西都拿过来。</span></span><br><span class="line"></span><br><span class="line">Child2.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  改第子类的属性，父类也跟着改变  */</span></span><br><span class="line"><span class="comment">//  Child2.prototype.getName = function () &#123;   //这里可以重写从父类继承来的方法,且会优先调用自己的。</span></span><br><span class="line"><span class="comment">//      console.log(222);</span></span><br><span class="line"><span class="comment">//  &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Child2(<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.getName());  <span class="comment">//老明　　//调用了从Parent2原型中继承来的方法(继承到了当前对象的原型中)　　</span></span><br><span class="line"><span class="built_in">console</span>.log(result.getAge());   <span class="comment">//22 　　//调用了从Child2原型中扩展来的方法</span></span><br></pre></td></tr></table></figure>

<h4 id="3-组合方式"><a href="#3-组合方式" class="headerlink" title="3.组合方式"></a>3.组合方式</h4><p>组合继承（所有的实例都能拥有自己的属性，并且可以使用相同的方法，组合继承避免了原型链和借用构造函数的缺陷，结合了两个的优点，是最常用的继承方式）</p>
<p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后再通过将父类实例作为子类原型，实现函数复用</p>
<p><strong>缺点：</strong>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.friends = [<span class="string">&#x27;小李&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Parent3.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">   Parent3.call(<span class="built_in">this</span>,<span class="string">&#x27;老明&#x27;</span>);　　<span class="comment">//这一步很关键</span></span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3(<span class="string">&#x27;老明&#x27;</span>);　　<span class="comment">//这一步也很关键</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> Child3(<span class="number">24</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.name);　　　　<span class="comment">//老明</span></span><br><span class="line">result.friends.push(<span class="string">&quot;小白&quot;</span>);　　 <span class="comment">// 增加数组值</span></span><br><span class="line"><span class="built_in">console</span>.log(result.friends);　　<span class="comment">//[&#x27;小李&#x27;,&#x27;小红&#x27;,&#x27;小智&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(result.getName());　　<span class="comment">//老明</span></span><br><span class="line"><span class="built_in">console</span>.log(result.age);　　　　<span class="comment">//24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="keyword">new</span> Child3(<span class="number">25</span>);   <span class="comment">//通过借用构造函数都有自己的属性，通过原型享用公共的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.name);　　<span class="comment">//老明</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.friends);　　<span class="comment">//[&#x27;小李&#x27;,&#x27;小红&#x27;]  </span></span><br></pre></td></tr></table></figure>

<h4 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4.寄生组合继承"></a>4.寄生组合继承</h4><p><strong>核心：</strong>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<p><strong>缺点：</strong>堪称完美，但实现较为复杂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent4</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.friends = [<span class="string">&#x27;小李&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent4.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child4</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    Parent4.call(<span class="built_in">this</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;     <span class="comment">// 创建一个没有实例方法的类</span></span><br><span class="line">    Super.prototype = Parent4.prototype;</span><br><span class="line">    Child4.prototype = <span class="keyword">new</span> Super();     <span class="comment">//将实例作为子类的原型</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="keyword">new</span> Child4(<span class="number">23</span>);  <span class="comment">// Child4 &#123;name: &quot;小明&quot;, friends: Array(2), age: 23&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.name);	<span class="comment">// 小明</span></span><br><span class="line">result1.friends.push(<span class="string">&#x27;小白&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1.friends); <span class="comment">// [&quot;小李&quot;, &quot;小红&quot;, &quot;小白&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.getName());  <span class="comment">// 小明</span></span><br><span class="line"><span class="built_in">console</span>.log(result1.age);  <span class="comment">//23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="keyword">new</span> Parent4(<span class="string">&#x27;root&#x27;</span>); <span class="comment">// Parent4 &#123;name: &quot;root&quot;, friends: Array(2)&#125;</span></span><br></pre></td></tr></table></figure>







<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与字符串类型相同方法区别</title>
    <url>/2019/03/28/qian-duan-zhi-shi-ti-xi/01.javascript/shu-zu-yu-zi-fu-chuan-lei-xing-xiang-tong-fang-fa-qu-bie/</url>
    <content><![CDATA[<p>数组和字符串有很多相似的对方，比如数组和字符串都有以下方法：</p>
<ol>
<li> concat</li>
<li> indexOf</li>
<li> lastIndexOf</li>
<li> slice</li>
<li> includes</li>
</ol>
<blockquote>
<p>鉴于toString及valueOf方法基本类型都有,这里就不做过多介绍了</p>
</blockquote>
<h3 id="1、数组中indexOf和较数组中includes的比较"><a href="#1、数组中indexOf和较数组中includes的比较" class="headerlink" title="1、数组中indexOf和较数组中includes的比较"></a>1、数组中indexOf和较数组中includes的比较</h3><ul>
<li>看函数的返回值：indexOf返回的是数值型的而includes返回的是布尔型的</li>
<li>都可以支持第二参数，而且的第二个参数都支持负数形式</li>
<li>数组中的indexOf不能判断数组中是否有NaN而includes可以</li>
</ul>
<h4 id="1-1-indexOf不能判断NaN"><a href="#1-1-indexOf不能判断NaN" class="headerlink" title="1.1 indexOf不能判断NaN"></a>1.1 indexOf不能判断NaN</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>))   <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>))  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-判断稀疏数组结果不同"><a href="#1-2-判断稀疏数组结果不同" class="headerlink" title="1.2 判断稀疏数组结果不同"></a>1.2 判断稀疏数组结果不同</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [,,];</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">undefined</span>))<span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">undefined</span>))<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是因为 indexOf 认为稀疏数组，省略掉的值是不存在的，但 includes 认为是undefined</p>
</blockquote>
<h3 id="2、字符串的indexOf和数组中的indexOf的比较"><a href="#2、字符串的indexOf和数组中的indexOf的比较" class="headerlink" title="2、字符串的indexOf和数组中的indexOf的比较"></a>2、字符串的indexOf和数组中的indexOf的比较</h3><p>功能：搜索字符串or数组中的元素，并返回它所在的位置。<br>语法：<code>array.indexOf(item,start)</code></p>
<ul>
<li>这两个方法都可以接收两个参数</li>
<li>这两个方法在没有查找的指定的字符都返回-1</li>
<li>字符串中的indexOf中的第二个参数不支持负数而数组的indexOf支持</li>
<li>字符串的indexOf在传入参数不是字符串的情况下默认会转换为字符串而数组的indexOf不会进行数据类的转换</li>
</ul>
<h4 id="2-1-字符串的参数不支持负数"><a href="#2-1-字符串的参数不支持负数" class="headerlink" title="2.1 字符串的参数不支持负数"></a>2.1 字符串的参数不支持负数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&quot;a&quot;</span>, -<span class="number">1</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">&quot;a&quot;</span>, -<span class="number">1</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-字符串的参数会自动转换"><a href="#2-2-字符串的参数会自动转换" class="headerlink" title="2.2 字符串的参数会自动转换"></a>2.2 字符串的参数会自动转换</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;1&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="number">1</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">1</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h3 id="3、字符串的includes和数组中的includes的比较"><a href="#3、字符串的includes和数组中的includes的比较" class="headerlink" title="3、字符串的includes和数组中的includes的比较"></a>3、字符串的includes和数组中的includes的比较</h3><p>功能：用来判断一个字符串or数组是否包含一个指定的值，如果是返回 true，否则false<br>语法：<code>arr.includes(searchElement, fromIndex)</code></p>
<ul>
<li>这两个方法都可以接收两个参数</li>
<li>这两个方法在没有查找的指定的字符都返回false</li>
<li>字符串中的includes中的第二个参数不支持负数而数组的includes支持</li>
<li>字符串的includes在传入参数不是字符串的情况下默认会转换为字符串而数组的includes不会进行数据类的转换</li>
</ul>
<h4 id="3-1-字符串的参数不支持负数"><a href="#3-1-字符串的参数不支持负数" class="headerlink" title="3.1 字符串的参数不支持负数"></a>3.1 字符串的参数不支持负数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&quot;a&quot;</span>, -<span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="string">&quot;a&quot;</span>, -<span class="number">1</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-字符串的参数会自动转换"><a href="#3-2-字符串的参数会自动转换" class="headerlink" title="3.2 字符串的参数会自动转换"></a>3.2 字符串的参数会自动转换</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;1&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">1</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="4、字符串的slice和数组中的slice的比较"><a href="#4、字符串的slice和数组中的slice的比较" class="headerlink" title="4、字符串的slice和数组中的slice的比较"></a>4、字符串的slice和数组中的slice的比较</h3><p>功能：提取字符串or数组的某个部分,不会改变现有的值，而仅仅会返回被连接字符串or数组的一个副本。<br>语法：<code>arr.slice(start,end)</code></p>
<ul>
<li>在不传入任何参数的情况下都是把原来的值拷贝一份</li>
<li>字符串的slice的第二个参数是不支持负数的而数组的可以</li>
<li>都可以接收两个参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.slice(<span class="number">1</span>, <span class="number">4</span>)) <span class="comment">//[2, 3, 4];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;hello root&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1.slice(<span class="number">1</span>,<span class="number">4</span>)); <span class="comment">//ell</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5、字符串的concat和数组中的concat的比较"><a href="#5、字符串的concat和数组中的concat的比较" class="headerlink" title="5、字符串的concat和数组中的concat的比较"></a>5、字符串的concat和数组中的concat的比较</h3><p>功能：方法用于连接两个或多个字符串or数组；不会改变现有的值，而仅仅会返回被连接字符串or数组的一个副本。<br>语法：<code>arr.concat(arrayX,arrayX,......,arrayX)</code></p>
<ul>
<li>这两个方法都没有限定参数，而且参数可以是任何数据类型的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">&quot; world!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1.concat(str2));  <span class="comment">//&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&quot;root&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)); <span class="comment">//[&quot;hello&quot;, &quot;root&quot;]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2018/06/24/qian-duan-zhi-shi-ti-xi/01.javascript/zheng-ze-biao-da-shi/</url>
    <content><![CDATA[<h2 id="正则常见函数"><a href="#正则常见函数" class="headerlink" title="正则常见函数"></a>正则常见函数</h2><p>正则表达式常用的方法分为 2 类：</p>
<ol>
<li>字符串上调用，进行正则规则匹配。操作对象是正则表达式</li>
<li>正则表达式上调用。操作对象是字符串。</li>
</ol>
<p>准备了下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/runoob/gi</span>; <span class="comment">// 正则表达式</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Visit Runoob!runoob&quot;</span>; <span class="comment">// 待匹配字符串</span></span><br></pre></td></tr></table></figure>

<p>① <strong>字符串上调用的方法</strong>，常见的有：<code>search</code>/ <code>match</code> / <code>replace</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return: Number 代表搜索到的开始地址</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/Runoob/i</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return: Array 匹配出来的所有字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/run/gi</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return: 新的string对象</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="regexp">/visit/i</span>, <span class="string">&quot;visit&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>② <strong>正则表达式对象上的方法</strong>，常见的有：<code>test</code> / <code>exec</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return: Boolean 代表是否符合匹配</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return: 找到第一个匹配的值，返回一个数组，存放着匹配信息</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.exec(str));</span><br></pre></td></tr></table></figure>

<h2 id="实现千分位标注"><a href="#实现千分位标注" class="headerlink" title="实现千分位标注"></a>实现千分位标注</h2><blockquote>
<p>题目：实现千分位标注位，考虑小数、负数和整数三种情况。</p>
</blockquote>
<p><code>sep</code>参数是自定义的分隔符，默认是<code>,</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现千分位标注位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>str 待标注的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>sep 标注符号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> addSeparator = <span class="function">(<span class="params">str = <span class="string">&quot;&quot;</span>, sep = <span class="string">&quot;,&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  str += <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = str.split(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">    re = <span class="regexp">/(\d+)(\d&#123;3&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> integer = arr[<span class="number">0</span>],</span><br><span class="line">    decimal = arr.length &lt;= <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">`.<span class="subst">$&#123;arr[<span class="number">1</span>]&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (re.test(integer)) &#123;</span><br><span class="line">    integer = integer.replace(re, <span class="string">&quot;$1&quot;</span> + sep + <span class="string">&quot;$2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> integer + decimal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addSeparator(-<span class="number">10000.23</span>)); <span class="comment">// -10,000.23</span></span><br><span class="line"><span class="built_in">console</span>.log(addSeparator(<span class="number">100</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(addSeparator(<span class="number">1234</span>, <span class="string">&quot;;&quot;</span>)); <span class="comment">// 1;234</span></span><br></pre></td></tr></table></figure>

<h2 id="全局匹配与lastIndex"><a href="#全局匹配与lastIndex" class="headerlink" title="全局匹配与lastIndex"></a>全局匹配与<code>lastIndex</code></h2><blockquote>
<p>题目：请说出下面代码执行结果（为了方便，我将结果注释在代码中了），并且解释。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/o/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(str)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(str)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(str)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于使用的是<strong>全局匹配</strong>，因此会多出来<code>lastIndex</code>这个属性，打印如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/o/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(re.test(str), re.lastIndex); <span class="comment">// true 2</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(str), re.lastIndex); <span class="comment">// true 3</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(str), re.lastIndex); <span class="comment">// false 0</span></span><br></pre></td></tr></table></figure>

<p><strong>简单理解就是：同一个全局匹配的正则对同一个目标串匹配后，匹配过的部分串将不再匹配。</strong></p>
<h2 id="字符串第一个出现一次的字符"><a href="#字符串第一个出现一次的字符" class="headerlink" title="字符串第一个出现一次的字符"></a>字符串第一个出现一次的字符</h2><blockquote>
<p>题目：字符串中第一个出现一次的字符</p>
</blockquote>
<p>利用字符串的<code>match</code>方法匹配指定字符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> find_ch = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">const</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(ch, <span class="string">&quot;g&quot;</span>);</span><br><span class="line">    <span class="comment">// 检查每个字符的匹配数量</span></span><br><span class="line">    <span class="keyword">if</span> (str.match(re).length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出答案是 l</span></span><br><span class="line"><span class="built_in">console</span>.log(find_ch(<span class="string">&quot;google&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>除了上述方法，使用<code>indexOf/lastIndexOf</code>同样可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> find_ch = <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.indexOf(ch) === str.lastIndexOf(ch)) &#123;</span><br><span class="line">      <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出答案是 l</span></span><br><span class="line"><span class="built_in">console</span>.log(find_ch(<span class="string">&quot;google&quot;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript基础篇</title>
    <url>/2019/08/27/qian-duan-zhi-shi-ti-xi/02.typescript/typescript-ji-chu-pian/</url>
    <content><![CDATA[<p>这篇笔记，主要记录了自己最近在 typescript 实践中的经验。总结了常见的用法。</p>
<h2 id="联合类型与交叉类型"><a href="#联合类型与交叉类型" class="headerlink" title="联合类型与交叉类型"></a>联合类型与交叉类型</h2><p>联合类型：使用<code>|</code>作为标记，常用于对象类型是多种类型之一。</p>
<p>交叉类型：使用<code>&amp;</code> 作为标记，创建新类型，拥有多个类型的所有定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  school: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为交叉类型，两个接口的定义必须都符合</span></span><br><span class="line"><span class="keyword">const</span> a: Student &amp; People = &#123;</span><br><span class="line">  name: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  school: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为联合类型，只能访问接口公有定义</span></span><br><span class="line"><span class="keyword">let</span> b: Student | People = a;</span><br><span class="line"><span class="built_in">console</span>.log(b.name);</span><br><span class="line"><span class="comment">// console.log(b.age) // error：编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="数组、元祖与枚举"><a href="#数组、元祖与枚举" class="headerlink" title="数组、元祖与枚举"></a>数组、元祖与枚举</h2><p>数组的定义，可以使用范型，也可以使用<code>[]</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums2: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 更推荐</span></span><br></pre></td></tr></table></figure>

<p>元祖使用<code>[]</code>声明，枚举使用<code>enum</code>声明。它们的应用场景比较少。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举👇</span></span><br><span class="line"><span class="built_in">enum</span> Days &#123;</span><br><span class="line">  Sun, <span class="comment">// 0</span></span><br><span class="line">  Mon, <span class="comment">// 1</span></span><br><span class="line">  Tue, <span class="comment">// 2</span></span><br><span class="line">  Wed, <span class="comment">// 3</span></span><br><span class="line">  Thu, <span class="comment">// 4</span></span><br><span class="line">  Fri, <span class="comment">// 5</span></span><br><span class="line">  Sat <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元祖👇</span></span><br><span class="line"><span class="keyword">let</span> yuanzu: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line">yuanzu[<span class="number">0</span>] = <span class="string">&quot;Xcat Liu&quot;</span>;</span><br><span class="line">yuanzu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// yuanzu[2] = &#x27;fwef&#x27; // error：编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>当「类型推断」无法判定类型的时候，需要利用「类型断言」来告诉编译器对象的类型。</p>
<p>对于类型断言，推荐使用：<code>as</code>。而不是在对象前使用<code>&lt;&gt;</code>，这和 jsx 语法有冲突。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LogInfo &#123;</span><br><span class="line">  time: <span class="built_in">Date</span>;</span><br><span class="line">  info: <span class="built_in">string</span>;</span><br><span class="line">  level?: <span class="string">&quot;log&quot;</span> | <span class="string">&quot;error&quot;</span> | <span class="string">&quot;warning&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1: LogInfo = &#123;</span><br><span class="line">  time: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">  info: <span class="string">&quot;obj1&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logInfo = process.env.NODE_ENV === <span class="string">&quot;development&quot;</span> ? obj2 : obj1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(logInfo.info) // error: 编译报错</span></span><br><span class="line"><span class="built_in">console</span>.log((logInfo <span class="keyword">as</span> LogInfo).info); <span class="comment">// 类型断言，指明接口类型为：LogInfo</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>这功能非常好用了，比如声明一个联合声明：<code>&#39;log&#39; | &#39;info&#39; | &#39;error&#39;</code>。许多地方要用到，总不能每次都写一遍，因此：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogLevel = <span class="string">&quot;log&quot;</span> | <span class="string">&quot;info&quot;</span> | <span class="string">&quot;error&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数与剩余参数"><a href="#默认参数与剩余参数" class="headerlink" title="默认参数与剩余参数"></a>默认参数与剩余参数</h3><p>默认参数的语法是<code>=</code>，不能给「可选参数」。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&quot;默认值&quot;</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>「剩余参数」是数组类型，并且元素类型无法确定，因此指定为 <code>any</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Async-Function"><a href="#Async-Function" class="headerlink" title="Async Function"></a>Async Function</h3><p>对于<code>async/await</code>函数来说，返回值是 Promise 对象。Promise 对象的类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Promise&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The</span></span><br><span class="line"><span class="comment">   * resolved value cannot be modified from the callback.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>onfinally The callback to execute when the Promise is settled (fulfilled or rejected).</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns </span>A Promise for the completion of the callback.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">finally</span>(onfinally?: (<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="literal">undefined</span> | <span class="literal">null</span>): <span class="built_in">Promise</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，asnyc 返回结果的类型需要用到范型语法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>ts 的函数重载和 c++、java 等语言中的函数重载不一样。ts 函数重载最终，还是编译成一个函数（c 语言等是编译成不同函数）。</p>
<p>它的目的是为了提供编译器进行更多种类的类型判断，而不需要使用“类型断言”技术。在定义函数重载的时候，要按照「精确 =&gt; 宽泛」的级层来定义函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(</span><br><span class="line">      x</span><br><span class="line">        .toString()</span><br><span class="line">        .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">      .split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>一个接口允许有任意的属性：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  gender: <span class="string">&quot;male&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><p>借助「索引签名」，可以进一步规范存储对象的结构。索引签名的参数可以是 number 或 string。</p>
<p>例如下面，Info 接口就是所有的字符串字读的值必须为 number 类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">string</span>; <span class="comment">// 编译error：x不符合索引签名的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，此处也可以同时拥有两种类型的索引签名：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  [name: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">  [age: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想规定「有限」的字符串字面量，借助 <code>in</code> 即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogLevel = <span class="string">&quot;log&quot;</span> | <span class="string">&quot;info&quot;</span> | <span class="string">&quot;warning&quot;</span> | <span class="string">&quot;error&quot;</span> | <span class="string">&quot;success&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localLogFile: &#123;</span><br><span class="line">  [level <span class="keyword">in</span> LogLevel]?: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  info: <span class="string">&quot;info.log&quot;</span>,</span><br><span class="line">  warning: <span class="string">&quot;warning.log&quot;</span>,</span><br><span class="line">  error: <span class="string">&quot;error.log&quot;</span>,</span><br><span class="line">  success: <span class="string">&quot;success.log&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> MongoConf &#123;</span><br><span class="line">  host: <span class="built_in">string</span>;</span><br><span class="line">  port: <span class="built_in">number</span>;</span><br><span class="line">  db: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ProcessConf &#123;</span><br><span class="line">  pid: <span class="built_in">number</span>;</span><br><span class="line">  mongodb: MongoConf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型声明复用"><a href="#类型声明复用" class="headerlink" title="类型声明复用"></a>类型声明复用</h2><p>在 typescript 的编译器中，类型定义是可以导出的。比如上面定义的 <code>MongoConf</code> 就可以 export 出来，给别的文件使用：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> MongoConf &#123;</span><br><span class="line">  host: <span class="built_in">string</span>;</span><br><span class="line">  port: <span class="built_in">number</span>;</span><br><span class="line">  db: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; MongoConf &#125; <span class="keyword">from</span> <span class="string">&quot;./a.ts&quot;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈promise-async-await的执行顺序与V8引擎的BUG</title>
    <url>/2019/04/29/qian-duan-zhi-shi-ti-xi/01.javascript/tan-tan-promise-async-await-de-zhi-xing-shun-xu-yu-v8-yin-qing-de-bug/</url>
    <content><![CDATA[<h2 id="1-题目和答案"><a href="#1-题目和答案" class="headerlink" title="1. 题目和答案"></a>1. 题目和答案</h2><blockquote>
<p>故事还是要从下面这道面试题说起：请问下面这段代码的输出是什么？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述，在<code>Chrome 66</code>和<code>node v10</code>中，正确输出是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line">Promise</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：在新版本的浏览器中，<code>await</code>输出顺序被“提前”了，请看官耐心慢慢看。</p>
</blockquote>
<h2 id="2-流程解释"><a href="#2-流程解释" class="headerlink" title="2. 流程解释"></a>2. 流程解释</h2><p>边看输出结果，边做解释吧：</p>
<ol>
<li>正常输出<code>script start</code></li>
<li>执行<code>async1</code>函数，此函数中又调用了<code>async2</code>函数，输出<code>async2 end</code>。回到<code>async1</code>函数，<strong>遇到了<code>await</code>，让出线程</strong>。</li>
<li>遇到<code>setTimeout</code>，扔到<strong>下一轮宏任务队列</strong></li>
<li>遇到<code>Promise</code>对象，立即执行其函数，输出<code>Promise</code>。其后的<code>resolve</code>，被扔到了微任务队列</li>
<li>正常输出<code>script end</code></li>
<li>此时，此次<code>Event Loop</code>宏任务都执行完了。来看下第二步被扔进来的微任务，因为<code>async2</code>函数是<code>async</code>关键词修饰，因此，将<code>await async2</code>后的代码扔到微任务队列中</li>
<li>执行第 4 步被扔到微任务队列的任务，输出<code>promise1</code>和<code>promise2</code></li>
<li>执行第 6 步被扔到微任务队列的任务，输出<code>async1 end</code></li>
<li>第一轮 EventLoop 完成，执行第二轮 EventLoop。执行<code>setTimeout</code>中的回调函数，输出<code>setTimeout</code>。</li>
</ol>
<h2 id="3-再谈-async-和-await"><a href="#3-再谈-async-和-await" class="headerlink" title="3. 再谈 async 和 await"></a>3. 再谈 async 和 await</h2><p>细心的朋友肯定会发现前面第 6 步，如果<code>async2</code>函数是没有<code>async</code>关键词修饰的一个普通函数呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新的async2函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line">Promise</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>不同的结果就出现在前面所说的第 6 步：如果 await 函数后面的函数是普通函数，那么其后的微任务就正常执行；否则，会将其再放入微任务队列。</p>
<h2 id="4-其实是-V8-引擎的-BUG"><a href="#4-其实是-V8-引擎的-BUG" class="headerlink" title="4. 其实是 V8 引擎的 BUG"></a>4. 其实是 V8 引擎的 BUG</h2><p>看到前面，正常人都会觉得真奇怪！（但是按照上面的诀窍倒也是可以理解）</p>
<p>然而 V8 团队确定了<strong>这是个 bug</strong>（很多强行解释要被打脸了），具体的 PR<a href="https://github.com/tc39/ecma262/pull/1250">请看这里</a>。好在，这个问题已经在最新的 Chrome 浏览器中<strong>被修复了</strong>。</p>
<p>简单点说，前面两段不同代码的运行结果都是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async2 end</span><br><span class="line">Promise</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p><code>await</code>就是让出线程，其后的代码放入微任务队列（不会再多一次放入的过程），就这么简单了。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript实战篇</title>
    <url>/2019/08/27/qian-duan-zhi-shi-ti-xi/02.typescript/typescript-shi-zhan-pian/</url>
    <content><![CDATA[<p>最近在做运营侧中台项目的重构，目前的选型是 koa2+typescript。在实际生产中，切实体会到了 typescript 类型带来的好处。</p>
<p>为了更形象说明 typescript 的优势，还是先来看一个场景吧：</p>
<h2 id="BUG-现场"><a href="#BUG-现场" class="headerlink" title="BUG 现场"></a>BUG 现场</h2><p>作为一门灵活度特别大的语言，坏处就是：<strong>复杂逻辑编写过程中，数据结构信息可能由于逻辑复杂、人员变更等情况而丢失，从而写出来的代码含有隐含错误</strong>。</p>
<p>比如这次我在给<a href="https://github.com/root-lucas/Blog/">自己的博客</a>编写<a href="https://github.com/root-lucas/Blog/blob/master/bin/prettier.js">node 脚本</a>的时候就遇到了这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllFiles</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = fs.readdirSync(root);</span><br><span class="line">  files.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> file = path.resolve(root, name);</span><br><span class="line">    <span class="keyword">if</span> (isFolder(file)) &#123;</span><br><span class="line">      findAllFiles(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(&#123;</span><br><span class="line">        path: file,</span><br><span class="line">        check: <span class="literal">false</span>,</span><br><span class="line">        content: fs.readFileSync(file)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>result 保存了递归遍历的所有文件的 path、check、content 信息，其中 content 信息会被传给<code>prettier.js</code>的<code>check(content: string, options: object)</code>方法。</p>
<p>显然，上述代码是有错误的，但是极难发现。只有运行它的时候，才能通过堆栈报错来进行定位。<strong>但如果借助 ts，就可以立即发现错误，保持代码稳健</strong>。</p>
<p>这个问题放在文章最后再说，下面看看 ts 在 koa 项目中的运用吧。</p>
<h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><p>由于没有历史包袱，整个项目的架构还是非常清爽的。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── bin <span class="comment"># 存放scripts的脚本文件</span></span><br><span class="line">├── dist <span class="comment"># 编译打包后的js文件</span></span><br><span class="line">├── docs <span class="comment"># 详细文档</span></span><br><span class="line">├── package.json <span class="comment"># npm</span></span><br><span class="line">├── sh <span class="comment"># pm2等脚本</span></span><br><span class="line">├── src <span class="comment"># 项目源码</span></span><br><span class="line">├── tmp <span class="comment"># 存放临时文件的地方</span></span><br><span class="line">└── tsconfig.json <span class="comment"># typescript编译配置</span></span><br></pre></td></tr></table></figure>

<h2 id="typescript-编译与-npm-配置"><a href="#typescript-编译与-npm-配置" class="headerlink" title="typescript 编译与 npm 配置"></a>typescript 编译与 npm 配置</h2><p>因为是用 ts 来编写代码，因此需要专门编写 typescript 的配置文件：<code>tsconfig.json</code>。根据个人习惯，以及之前组内的 ts 项目，配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>, <span class="comment">// 编译生成的模块系统代码</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2017&quot;</span>, <span class="comment">// 指定ecmascript的目标版本</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>, <span class="comment">// 禁止隐式any类型</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">false</span>, <span class="comment">// 是否允许出现js</span></span><br><span class="line">    <span class="attr">&quot;newLine&quot;</span>: <span class="string">&quot;LF&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一些有历史遗留的项目，或者说用 js 逐步重构为 ts 的项目来说，由于存在大量的 js 遗留代码，因此<code>allowJs</code>这里应该为<code>true</code>，<code>noImplicitAny</code>应该为<code>false</code>。</p>
<p>在<code>package.json</code>中，配置两个脚本，一个是 dev 模式，另一个是 prod 模式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;tsc --watch &amp; export NODE_ENV=development &amp;&amp; node bin/dev.js -t dist/ -e dist/app.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;rm -rf dist/* &amp;&amp; tsc&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 dev 模式下，需要 tsc 监听配置中<code>include</code>中指定的 ts 文件的变化，并且实时编译。<code>bin/dev.js</code>是根据项目需要编写的监听脚本，它会监听<code>dist/</code>目录中编译后的 js 文件，一旦有满足重启条件，就重启服务器。</p>
<h2 id="类型声明文件"><a href="#类型声明文件" class="headerlink" title="类型声明文件"></a>类型声明文件</h2><p>koajs 与常见插件的类型声明都要在@types 下安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i --save-dev @types/koa @types/koa-router @types/koa2-cors @types/koa-bodyparser</span><br></pre></td></tr></table></figure>

<h2 id="区分-dev-prod-环境"><a href="#区分-dev-prod-环境" class="headerlink" title="区分 dev/prod 环境"></a>区分 dev/prod 环境</h2><p>为了方便之后的开发和上线，<code>src/config/</code>目录如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── dev.ts</span><br><span class="line">├── index.ts</span><br><span class="line">└── prod.ts</span><br></pre></td></tr></table></figure>

<p>配置分为 prod 和 dev 两份。dev 模式下，向控制台打印信息；在 prod 下，需要向指定位置写入日志信息。类似的，dev 下不需要进行身份验证，prod 下需要内网身份验证。因此，利用 ts 的<code>extends</code>特性来复用数据声明：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mode: dev</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ConfigScheme &#123;</span><br><span class="line">  <span class="comment">// 监听端口</span></span><br><span class="line">  port: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// mongodb配置</span></span><br><span class="line">  mongodb: &#123;</span><br><span class="line">    host: <span class="built_in">string</span>;</span><br><span class="line">    port: <span class="built_in">number</span>;</span><br><span class="line">    db: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mode: prod</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ProdConfigScheme <span class="keyword">extends</span> ConfigScheme &#123;</span><br><span class="line">  <span class="comment">// 日志存储位置</span></span><br><span class="line">  logRoot: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 index.ts 中，通过<code>process.env.NODE_ENV</code>变量值来判断模式，进而导出对应的配置。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; devConf &#125; <span class="keyword">from</span> <span class="string">&quot;./dev&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; prodConf &#125; <span class="keyword">from</span> <span class="string">&quot;./prod&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = process.env.NODE_ENV === <span class="string">&quot;development&quot;</span> ? devConf : prodConf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config;</span><br></pre></td></tr></table></figure>

<p>如此，外界直接引入即可。但在开发过程中，例如身份认证中间件。虽然 dev 模式下不会开启，但编写它的时候，引入的<code>config</code>类型是<code>ConfigScheme</code>，在访问<code>ProdConfigScheme</code>上的字段时候 ts 编译器会报错。</p>
<p>这时候，ts 的断言就派上用场了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config, &#123; ProdConfigScheme &#125; <span class="keyword">from</span> <span class="string">&quot;./../config/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; logRoot &#125; = config <span class="keyword">as</span> ProdConfigScheme;</span><br></pre></td></tr></table></figure>

<h2 id="中间件编写"><a href="#中间件编写" class="headerlink" title="中间件编写"></a>中间件编写</h2><p>对于整体项目，和 koa 关联较大的业务逻辑主要体现在中间件。这里以运营系统必有的「操作留存中间件」的编写为例，展示如何在 ts 中编写中间件的业务逻辑和数据逻辑。</p>
<p>引入 koa 以及编写好的轮子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Koa <span class="keyword">from</span> <span class="string">&quot;koa&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; print &#125; <span class="keyword">from</span> <span class="string">&quot;./../helpers/log&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&quot;./../config/&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getDB &#125; <span class="keyword">from</span> <span class="string">&quot;./../database/mongodb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">mongodb</span>: mongoConf &#125; = config; <span class="comment">// mongo配置</span></span><br><span class="line"><span class="keyword">const</span> collectionName = <span class="string">&quot;logs&quot;</span>; <span class="comment">// 集合名称</span></span><br></pre></td></tr></table></figure>

<p>操作留存中需要留存的数据字段有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">staffName: 操作人</span><br><span class="line">visitTime: 操作时间</span><br><span class="line">url: 接口地址</span><br><span class="line">params: 前端传来的所有参数</span><br></pre></td></tr></table></figure>

<p>ts 中借助 interface 直接约束字段类型即可。一目了然，对于之后的维护者来说，基本不需要借助文档，即可理解我们要和 db 交互的数据结构。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> LogScheme &#123;</span><br><span class="line">  staffName: <span class="built_in">string</span>;</span><br><span class="line">  visitTime: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">  params?: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，编写中间件函数逻辑，参数需要指明类型。当然，直接指明参数是 any 类型也可以，但这样和 js 就没差别，而且也体会不到 ts 带来文档化编程的好处。</p>
<p>因为之前已经安装了<code>@types/koa</code>，因此这里不需要我们手动编写 <code>.d.ts</code> 文件。并且，koa 的内置数据类型已经被挂在了前面 import 进来的<code>Koa</code>上了（是的，ts 帮我们做了很多事情）。上下文的类型就是 <code>Koa.BaseContext</code>，回调函数类型是<code>() =&gt; Promise&lt;any&gt;</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">ctx: Koa.BaseContext, next: () =&gt; <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> db = <span class="keyword">await</span> getDB(mongoConf.db); <span class="comment">// 从db链接池中获取链接实例</span></span><br><span class="line">  <span class="keyword">if</span> (!db) &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;mongodb errror at controllers/logger&quot;</span>;</span><br><span class="line">    ctx.status = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doc: LogScheme = &#123;</span><br><span class="line">    staffName: ctx.headers[<span class="string">&quot;staffname&quot;</span>] || <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">    visitTime: <span class="built_in">Date</span>.now().toString(<span class="number">10</span>),</span><br><span class="line">    url: ctx.url,</span><br><span class="line">    params: ctx.request.body</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不需要await等待这段逻辑执行完毕</span></span><br><span class="line">  db.collection(collectionName)</span><br><span class="line">    .insertOne(doc)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span></span><br><span class="line">      print(<span class="string">`fail to log info to mongo: <span class="subst">$&#123;error.message&#125;</span>`</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> logger;</span><br></pre></td></tr></table></figure>

<h2 id="单元函数"><a href="#单元函数" class="headerlink" title="单元函数"></a>单元函数</h2><p>这里以一个日志输出的单元函数为例，说一下「索引签名」的应用。</p>
<p>首先，通过联合类型约束了日志级别：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LogLevel = <span class="string">&quot;log&quot;</span> | <span class="string">&quot;info&quot;</span> | <span class="string">&quot;warning&quot;</span> | <span class="string">&quot;error&quot;</span> | <span class="string">&quot;success&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，打算准备一个映射：日志等级 =&gt; 文件名称 的数据结构，例如 info 级别的日志对应输出的文件就是 <code>info.log</code>。显然，这个 object 的所有 key，必须符合 LogLevel。写法如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> localLogFile: &#123;</span><br><span class="line">  [level <span class="keyword">in</span> LogLevel]: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  log: <span class="string">&quot;info.log&quot;</span>,</span><br><span class="line">  info: <span class="string">&quot;info.log&quot;</span>,</span><br><span class="line">  warning: <span class="string">&quot;warning.log&quot;</span>,</span><br><span class="line">  error: <span class="string">&quot;error.log&quot;</span>,</span><br><span class="line">  success: <span class="string">&quot;success.log&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果对于 log 级别的日志，不需要输出到文件仅仅需要打印到控制台。那么<code>localLogFile</code>应该没有<code>log</code>字段，如果直接去掉<code>log</code>字段，ts 编译器报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Property &#39;log&#39; is missing in type &#39;&#123; info: string; warning: string; error: string; success: string; &#125;&#39; but required in type &#39;&#123; log: string | void; info: string | void; warning: string | void; error: string | void; success: string | void; &#125;&#39;.</span><br></pre></td></tr></table></figure>

<p>根据错误，这里将索引签名字段设置为「可选」即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> localLogFile: &#123;</span><br><span class="line">  [level <span class="keyword">in</span> LogLevel]?: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  info: <span class="string">&quot;info.log&quot;</span>,</span><br><span class="line">  warning: <span class="string">&quot;warning.log&quot;</span>,</span><br><span class="line">  error: <span class="string">&quot;error.log&quot;</span>,</span><br><span class="line">  success: <span class="string">&quot;success.log&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="关于-export"><a href="#关于-export" class="headerlink" title="关于 export"></a>关于 export</h2><p><strong>使用<code>export</code>导出复杂对象时候，请加上类型声明，不要依赖与 ts 的类型推断</strong>。</p>
<p><code>index.ts</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> level0 <span class="keyword">from</span> <span class="string">&quot;./level0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ApiScheme &#123;</span><br><span class="line">  method: ApiMethod;</span><br><span class="line">  host: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ApiSet &#123;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: ApiScheme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> apis: ApiSet = &#123;</span><br><span class="line">  ...level0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>level0.ts</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ApiSet &#125; <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明导出对象的数据类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> level0: ApiSet = &#123;</span><br><span class="line">  <span class="string">&quot;qcloud.tcb.getPackageInfo&quot;</span>: &#123;</span><br><span class="line">    method: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    host: tcb.dataUrl</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;qcloud.tcb.getAlarmRecord&quot;</span>: &#123;</span><br><span class="line">    method: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">    host: tcb.dataUrl</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="回到开头"><a href="#回到开头" class="headerlink" title="回到开头"></a>回到开头</h2><p>回到开头的场景，如果用 typescript，我们会先声明<code>result</code>中每个对象的格式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> FileInfo &#123;</span><br><span class="line">  path: <span class="built_in">string</span>;</span><br><span class="line">  check: <span class="built_in">boolean</span>;</span><br><span class="line">  content: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result: FileInfo[] = [];</span><br></pre></td></tr></table></figure>

<p>此时，你会发现 typescript 编译器已经给出了报错，在 <code>content: fs.readFileSync(file)</code> 这一行中，报错信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不能将类型“Buffer”分配给类型“string”。</span><br></pre></td></tr></table></figure>

<p>如此，在编写代码的时候，就能立即发现错误。而不是写了几百行，然后跑起来后，根据堆栈报错一行行去定位问题。</p>
<p>仔细想一下，如果是 30 个人合作的大型 node/前端项目，出错的风险会有多高？定位错误成本会有多高？所以，只想说 ts 真香！</p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul>
<li><a href="https://ts.xcatliu.com/">《TypeScript 入门教程》</a></li>
<li><a href="https://basarat.gitbooks.io/typescript/content/docs/getting-started.html">《TypeScript Deep Div》</a></li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>FileAPI文件操作实战</title>
    <url>/2019/02/24/qian-duan-zhi-shi-ti-xi/03.html5/html5-fileapi-wen-jian-cao-zuo-shi-zhan/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTML5 为我们提供了 File API 相关规范。主要涉及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">File 接口</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader 对象</a> 。</p>
<p>本文整理了兼容性检测、文件选择、属性读取、文件读取、进度监控、大文件分片上传以及拖拽上传等开发中常见的前端文件操作。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，我们的 File 来自于<code>&lt;input&gt;</code>标签中选中的文件列表。所以，准备如下的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;images&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- File API相关操作写在了script.js中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="检测兼容性"><a href="#检测兼容性" class="headerlink" title="检测兼容性"></a>检测兼容性</h2><p>File 对象是特殊类型的 Blob。在 script 入口处，应该检测当前浏览器是否支持 File API：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">window</span>.File &amp;&amp; <span class="built_in">window</span>.FileReader &amp;&amp; <span class="built_in">window</span>.FileList &amp;&amp; <span class="built_in">window</span>.Blob)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;当前浏览器对FileAPI的支持不完善&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监听文件选择"><a href="#监听文件选择" class="headerlink" title="监听文件选择"></a>监听文件选择</h2><p>对于 type 为 file 类型的<code>&lt;input&gt;</code>标签，在选择文件的时候，会触发<code>change</code>事件。用户选中的文件信息也会传入回调函数的第一个参数中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; files &#125; = event.target;</span><br><span class="line">  <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;没有选择文件&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;选中的文件信息是：&quot;</span>, files);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&quot;#files&quot;</span>)</span><br><span class="line">  .addEventListener(<span class="string">&quot;change&quot;</span>, handleFileSelect, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="文件属性-File"><a href="#文件属性-File" class="headerlink" title="文件属性-File"></a>文件属性-File</h2><p><code>event.target.files</code> 是一个<code>FileList</code>对象，它是一个由<code>File</code>对象组成的列表。</p>
<p>每个 File 对象，保存着选中的对应文件的属性。常用的有：</p>
<ul>
<li>name：文件名</li>
<li>type：文件类型</li>
<li>size：文件大小</li>
</ul>
<p>下面，通过 type 属性，过滤掉非图片类型的文件，只展示图片类型文件的信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; files &#125; = event.target;</span><br><span class="line">  <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;没有选择文件&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> innerHTML = [];</span><br><span class="line">  <span class="keyword">const</span> reImage = <span class="regexp">/image.*/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reImage.test(file.type)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    innerHTML.push(</span><br><span class="line">      <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;li&gt;</span></span><br><span class="line"><span class="string">        &lt;strong&gt;<span class="subst">$&#123;file.name&#125;</span>&lt;/strong&gt;</span></span><br><span class="line"><span class="string">        (<span class="subst">$&#123;file.type || <span class="string">&quot;n/a&quot;</span>&#125;</span>) -</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;file.size&#125;</span> bytes</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&quot;#list&quot;</span>).innerHTML = <span class="string">`&lt;ul&gt;<span class="subst">$&#123;innerHTML.join(<span class="string">&quot;&quot;</span>)&#125;</span>&lt;/ul&gt;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读取文件-FileReader"><a href="#读取文件-FileReader" class="headerlink" title="读取文件-FileReader"></a>读取文件-FileReader</h2><p>还是以图片读取为例，读取并且显示所有的图片类型文件。</p>
<p>文件读取需要使用<code>FileReader</code>对象，它常用 3 个回调方法：</p>
<ul>
<li>onload: 文件读取完成</li>
<li>onloadstart：文件上传开始</li>
<li>onprogress : 文件上传中触发</li>
</ul>
<p><strong>和<code>Image</code>类似，在读取文件之前，需要先绑定事件处理</strong>。它读取操作有：readAsArrayBuffer、readAsDataURL、readAsBinaryString、readAsText。传入的参数就是<code>File</code>对象。</p>
<p>那么这几个方法有什么区别呢？<strong>不同的读取方式，回调事件<code>onload</code>接受到的<code>event.target.result</code>不相同</strong>。比如，<code>readAsDataURL</code>读取的话，result 是一个图片的 url。</p>
<p>下面就是读取图片文件，然后展示的一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; files &#125; = event.target;</span><br><span class="line">  <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> vm = <span class="built_in">document</span>.createDocumentFragment(),</span><br><span class="line">    re = <span class="regexp">/image.*/</span>,</span><br><span class="line">    loaded = <span class="number">0</span>, <span class="comment">// 完成加载的图片数量</span></span><br><span class="line">    total = <span class="number">0</span>; <span class="comment">// 总共图片数量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计image文件数量</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    re.test(file.type) &amp;&amp; total++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onloadstart回调</span></span><br><span class="line">  <span class="keyword">const</span> handleLoadStart = <span class="function">(<span class="params">ev, file</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&gt;&gt;&gt; Start load <span class="subst">$&#123;file.name&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// onload回调</span></span><br><span class="line">  <span class="keyword">const</span> handleOnload = <span class="function">(<span class="params">ev, file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&lt;&lt;&lt; End load <span class="subst">$&#123;file.name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">    img.height = <span class="number">250</span>;</span><br><span class="line">    img.width = <span class="number">250</span>;</span><br><span class="line">    img.src = ev.target.result;</span><br><span class="line">    vm.appendChild(img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成加载后，将其放入dom元素中</span></span><br><span class="line">    <span class="keyword">if</span> (++loaded === total) &#123;</span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">&quot;#images&quot;</span>).appendChild(vm);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!re.test(file.type)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onloadstart = <span class="function"><span class="params">ev</span> =&gt;</span> handleLoadStart(ev, file);</span><br><span class="line">    reader.onload = <span class="function"><span class="params">ev</span> =&gt;</span> handleOnload(ev, file);</span><br><span class="line">    <span class="comment">// 读取文件对象</span></span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&quot;#files&quot;</span>)</span><br><span class="line">  .addEventListener(<span class="string">&quot;change&quot;</span>, handleFileSelect, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="监控读取进度"><a href="#监控读取进度" class="headerlink" title="监控读取进度"></a>监控读取进度</h2><p>在监控读取进度的时候，主要是处理 FileReader 对象上的 <code>onprogress</code> 事件。</p>
<p>下面的例子，请打开一个较大的文件来查看效果（否则一下就读取完了）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; files &#125; = event.target;</span><br><span class="line">  <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleLoadStart = <span class="function">(<span class="params">ev, file</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&gt;&gt;&gt; Start load <span class="subst">$&#123;file.name&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> handleProgress = <span class="function">(<span class="params">ev, file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ev.lengthComputable) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算进度，并且以百分比形式展示</span></span><br><span class="line">    <span class="keyword">const</span> percent = <span class="built_in">Math</span>.round((ev.loaded / ev.total) * <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&lt;&lt;&lt; Loding <span class="subst">$&#123;file.name&#125;</span>, progress is <span class="subst">$&#123;percent&#125;</span>%`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onloadstart = <span class="function"><span class="params">ev</span> =&gt;</span> handleLoadStart(ev, file);</span><br><span class="line">    reader.onprogress = <span class="function"><span class="params">ev</span> =&gt;</span> handleProgress(ev, file);</span><br><span class="line">    reader.readAsArrayBuffer(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&quot;#files&quot;</span>)</span><br><span class="line">  .addEventListener(<span class="string">&quot;change&quot;</span>, handleFileSelect, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="大文件分片读取"><a href="#大文件分片读取" class="headerlink" title="大文件分片读取"></a>大文件分片读取</h2><p>在对于超大文件，一般采用分片上传的思路解决。文章开头有讲到，File 是 Blob 的一个特例。而 Blob 上有一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">slice 方法</a>，通过它，前端就可以实现分片读取大文件的操作。</p>
<p>为了方便说明，请先准备好一个 txt 文件，文件内容就是：<code>hello world</code>。</p>
<p>示例代码如下，代码中只读取前 5 个字节，由于每个英文字母占 1 个字节，所以打印结果应该是“hello”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleFileSelect</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; files &#125; = event.target;</span><br><span class="line">  <span class="keyword">if</span> (!files.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为了方便说明，这里仅仅读取第一个文件</span></span><br><span class="line">  <span class="keyword">const</span> file = files[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 读取前5个字节的内容</span></span><br><span class="line">  <span class="keyword">const</span> blob = file.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  <span class="comment">// 控制台输出结果应该是：hello</span></span><br><span class="line">  reader.onload = <span class="function"><span class="params">ev</span> =&gt;</span> <span class="built_in">console</span>.log(ev.target.result);</span><br><span class="line">  reader.readAsText(blob);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&quot;#files&quot;</span>)</span><br><span class="line">  .addEventListener(<span class="string">&quot;change&quot;</span>, handleFileSelect, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="拖拽上传"><a href="#拖拽上传" class="headerlink" title="拖拽上传"></a>拖拽上传</h2><p>和前面所述的 File API 相关是完全一样的。唯一需要特殊处理的是文件对象的获取入口改变了。对于<code>&lt;input&gt;</code>标签，监听 onchange 事件，FileList 存放在 event.target.files 中；对于拖拽操作，FileList 存放在拖拽事件的回调函数参数里，通过 event.dataTransfer.files 访问即可。</p>
<p>需要修改一下 html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      border: 3px dotted red;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>脚本文件的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDropover</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="comment">/***** 访问拖拽文件 *****/</span></span><br><span class="line">  <span class="keyword">const</span> files = event.dataTransfer.files;</span><br><span class="line">  <span class="built_in">console</span>.log(files);</span><br><span class="line">  <span class="comment">/**********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#container&quot;</span>);</span><br><span class="line">target.addEventListener(<span class="string">&quot;dragover&quot;</span>, handleDropover);</span><br><span class="line">target.addEventListener(<span class="string">&quot;drop&quot;</span>, handleDrop);</span><br></pre></td></tr></table></figure>

<h2 id="后端相关"><a href="#后端相关" class="headerlink" title="后端相关"></a>后端相关</h2><p>后端相关超出了本文的讨论范围，可以参考<a href="https://github.com/purplebamboo/blog/issues/17">这篇文章</a>。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5原生拖放事件的学习与实践</title>
    <url>/2019/02/28/qian-duan-zhi-shi-ti-xi/03.html5/html5-yuan-sheng-tuo-fang-shi-jian-de-xue-xi-yu-shi-jian/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前学习了 HTML5 的拖放事件，开发中也用到了拖拽组件。为了厘清整体的逻辑，专门做了一个小例子。</p>
<p>具体实现的效果也很简单：元素可以在容器中任意拖动，元素被移入容器的时候，还会有相关样式的改变已达到更好的展示效果。</p>
<p>例子基本运用了拖放事件的全部事件，并且尽量简洁的展示了出来。特此记录。</p>
<h3 id="拖放事件介绍"><a href="#拖放事件介绍" class="headerlink" title="拖放事件介绍"></a>拖放事件介绍</h3><p>由名字可以看出来，拖放事件由 2 部分组成：拖动和释放。</p>
<p>而拖动又由 2 部分组成，分别是被拖动元素的相关事件和元素容器的相关事件。</p>
<p><strong>1、被拖动元素的相关事件</strong> ：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dragstart</td>
<td>在元素开始被拖动时候触发</td>
</tr>
<tr>
<td>drag</td>
<td>在元素被拖动时反复触发</td>
</tr>
<tr>
<td>dragend</td>
<td>在拖动操作完成时触发</td>
</tr>
</tbody></table>
<p><strong>2、容器的相关事件</strong> ：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dragenter</td>
<td>当被拖动元素进入目的地元素所占据的屏幕空间时触发，<strong>一般需要取消浏览器的默认行为</strong>。</td>
</tr>
<tr>
<td>dragover</td>
<td>当被拖动元素在目的地元素内时触发，<strong>一般需要取消浏览器的默认行为</strong>。</td>
</tr>
<tr>
<td>dragleave</td>
<td>当被拖动元素没有放下就离开目的地元素时触发</td>
</tr>
</tbody></table>
<p><strong>3、释放事件</strong> ：</p>
<table>
<thead>
<tr>
<th>事件名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>drop</td>
<td>当被拖动元素在目的地元素里放下时触发，<strong>一般需要取消浏览器的默认行为</strong>。</td>
</tr>
</tbody></table>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p>为了方便说明，先看代码实现的效果。请前往  <a href="https://root-lucas.github.io/Code-Examples/HTML5/HTML5%E5%AE%9E%E7%8E%B0%E6%9D%A5%E5%9B%9E%E6%8B%96%E6%94%BE%E5%9B%BE%E7%89%872.html">Github 仓库</a>)  下载到本地，然后用 Chrome 打开 html 文件，初始效果如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554824440934-6b099e29-5d03-47c8-9fcd-358dfac034ce.png#align=left&display=inline&height=489&name=image.png&originHeight=612&originWidth=329&size=8385&status=done&width=263" alt="image.png"></p>
<p>将图中的可拖拽元素，拖放到下面的容器中，这个过程的效果如下所示。箭头表示拖拽方向，方框代表动态改变的容器样式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554824491746-4b790630-bb53-479a-9f5d-eaafef60cb23.png#align=left&display=inline&height=501&name=image.png&originHeight=627&originWidth=364&size=15595&status=done&width=291" alt="image.png"></p>
<p>最后，松开鼠标，将元素放入到下面的容器中，整个过程完成。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554824562321-b6b1a435-27b5-43ca-abb8-7e63265b839e.png#align=left&display=inline&height=477&name=image.png&originHeight=596&originWidth=315&size=8094&status=done&width=252" alt="image.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先，先编写 html 代码。因为元素可以在两个容器之间任意拖动，因此这两个容器都需要监听 drapenter、dragover、dragleave、drop 这四个事件。</p>
<p>被拖拽元素的 <code>draggable</code>  属性需要指明为 <code>true</code> ，才可以被拖拽。同时为了记录一些信息，需要监听 dragstart 事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragenter</span>=<span class="string">&quot;onDragEnter(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragover</span>=<span class="string">&quot;onDragOver(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragleave</span>=<span class="string">&quot;onDragLeave(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondrop</span>=<span class="string">&quot;onDrop(event)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;onDragStart(event)&quot;</span>&gt;</span></span><br><span class="line">      被拖拽元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragenter</span>=<span class="string">&quot;onDragEnter(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragover</span>=<span class="string">&quot;onDragOver(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondragleave</span>=<span class="string">&quot;onDragLeave(event)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ondrop</span>=<span class="string">&quot;onDrop(event)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了让拖拽效果更明显，实现效果展示-&gt;第二部分的，拖拽元素进入一个新的容器的时候，新容器展示阴影效果。编写阴影效果样式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaaaaa</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: box-shadow .<span class="number">3s</span> ease;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-id">#target</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.container</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom-width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">6px</span> -<span class="number">6px</span> <span class="number">#777</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>最后，编写 <code>demo.js</code>  代码。具体逻辑请看代码中的注释信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="literal">null</span>,</span><br><span class="line">  container = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找拖拽元素的容器类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentContainer</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node || node === <span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.classList.contains(<span class="string">&quot;container&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> findParentContainer(node.parentNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素开始被拖拽时, 标记元素原生的容器类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDragStart</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  target = event.target;</span><br><span class="line">  container = findParentContainer(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素进入目的容器时, 如果不是原来的容器, 则可以放置</span></span><br><span class="line"><span class="comment">// 此时更改样式, 以更好向用户展示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDragEnter</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.target !== container) &#123;</span><br><span class="line">    event.target.classList.add(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素在目的容器内时触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDragOver</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素离开目的容器, 需要移除相关样式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDragLeave</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  event.target.classList.remove(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素被放置在目的容器, 添加DOM节点, 移除相关样式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  event.target.appendChild(target);</span><br><span class="line">  event.target.classList.remove(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">  target = <span class="literal">null</span>;</span><br><span class="line">  container = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>代码地址: <a href="https://root-lucas.github.io/Code-Examples/HTML5/HTML5%E5%AE%9E%E7%8E%B0%E6%9D%A5%E5%9B%9E%E6%8B%96%E6%94%BE%E5%9B%BE%E7%89%872.html">Github</a></li>
<li><a href="http://www.w3school.com.cn/html5/html_5_draganddrop.asp">《HTML5 拖放》</a></li>
<li><a href="https://juejin.im/post/5a169d08518825592c07c666">《HTML5 原生拖拽/拖放》</a></li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>ServiceWorker离线缓存实战</title>
    <url>/2019/04/20/qian-duan-zhi-shi-ti-xi/03.html5/serviceworker-chi-xian-huan-cun-shi-zhan/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近实战了 Service Worker（以下简称“sw”）来进行网站缓存，以实现离线状态下，网站仍然可以正常使用。</p>
<p>尤其对于个人博客这种以内容为主体的静态网站，离线访问和缓存优化尤其重要；并且 Ajax 交互较少，离线访问和缓存优化的实现壁垒因此较低。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>虽然 sw 要求必须在 https 环境下才可以使用，但是为了方便开发者，通过<code>localhost</code>或者<code>127.0.0.1</code>也可以正常加载和使用。</p>
<p>利用 cnpm 下载<code>http-server</code>：<code>npm install http-server -g</code></p>
<p>进入存放示例代码的文件目录，启动静态服务器：<code>http-server -p 80</code></p>
<p>最后，准备下 html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./image.png&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://user-gold-cdn.xitu.io/2017/10/4/50e8f96bbcb3bc644a083a409ce0ce2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>一些提示信息sdfsf<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>浏览器是否支持：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;isSupport&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>service worker是否注册成功：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;isSuccess&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>当前注册状态：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;state&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>当前service worker状态：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;swState&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注册-Service-Worker"><a href="#注册-Service-Worker" class="headerlink" title="注册 Service Worker"></a>注册 Service Worker</h2><p>我们通过<code>script.js</code>来判断浏览器是否支持 serviceWorker，并且加载对应的代码。<code>script.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断浏览器是否支持</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;serviceWorker&quot;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;支持&quot;</span>);</span><br><span class="line">    <span class="built_in">window</span>.navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">&quot;/sw.js&quot;</span>, &#123;</span><br><span class="line">        scope: <span class="string">&quot;/&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;注册失败&quot;</span>, error.message);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;不支持&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="注册时机"><a href="#注册时机" class="headerlink" title="注册时机"></a>注册时机</h3><p>如上所示，最好在页面资源加载完成的事件(<code>window.onload</code>)之后注册 serviceWorker 线程。<strong>因为 serviceWorker 也会浪费资源和网络 IO</strong>，不能因为它而影响正常情况下（网络信号 ok 的情况）的使用体验。</p>
<h3 id="拦截作用域"><a href="#拦截作用域" class="headerlink" title="拦截作用域"></a>拦截作用域</h3><p>之后，我们需要用 serviceWorker 线程来拦截资源请求，但不是所有的资源都能被拦截，<strong>这主要是看 serviceWorker 的作用域：它只管理其路由和子路由下的资源文件</strong>。</p>
<p>例如上面代码中，<code>/sw.js</code>是 serviceWorker 脚本，它拦截根路径下的所有静态资源。如果是<code>/static/sw.js</code>，就只拦截<code>/static/</code>下的静态资源。</p>
<p>开发者也可以通过传递<code>scope</code>参数，来指定作用域。</p>
<h2 id="Service-Worker-最佳实践"><a href="#Service-Worker-最佳实践" class="headerlink" title="Service Worker 最佳实践"></a>Service Worker 最佳实践</h2><p>笔者爬了很久的坑，中途看了很多人的博客，包括张鑫旭老师的文章。但是实践的时候都出现了问题，直到读到了百度团队的文章才豁然开朗。</p>
<p>为了让<code>sw.js</code>的逻辑更清晰，这里仅仅展示最后总结出来的最优代码。如果想了解更多，可以跳到本章最后一个部分《参考链接》。</p>
<h3 id="sw-的生命周期"><a href="#sw-的生命周期" class="headerlink" title="sw 的生命周期"></a>sw 的生命周期</h3><p>对于 sw，它的生命周期有 3 个部分组成：install -&gt; waiting -&gt; activate。开发者常监听的生命周期是 install 和 activate。</p>
<p>这里需要注意的是：两个事件的回调监听函数的参数上都有<code>waitUntil</code>函数。<strong>开发者传递到它的<code>promise</code>可以让浏览器了解什么时候此状态完成</strong>。</p>
<p>如果难理解，可以看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VERSION = <span class="string">&quot;v1&quot;</span>;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&quot;install&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ServiceWoker注册后，立即添加缓存文件，</span></span><br><span class="line">  <span class="comment">// 当缓存文件被添加完后，才从install -&gt; waiting</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&quot;./index.html&quot;</span>, <span class="string">&quot;./image.png&quot;</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="更新-Service-Worker-代码"><a href="#更新-Service-Worker-代码" class="headerlink" title="更新 Service Worker 代码"></a>更新 Service Worker 代码</h3><p>对于缓存的更新，可以通过定义版本号的方式来标识，例如上方代码中的 VERSION 变量。但对于 ServiceWorker 本身的代码更新，需要别的机制。</p>
<p>简单来说，分为以下两步：</p>
<ol>
<li>在 install 阶段，调用 <code>self.skipWaiting()</code>  跳过 waiting 阶段，直接进入 activate 阶段</li>
<li>在 activate 阶段，调用 <code>self.clients.claim()</code>  更新客户端 ServiceWorker</li>
</ol>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VERSION = <span class="string">&quot;v1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加缓存</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;install&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 跳过 waiting 状态，然后会直接进入 activate 阶段</span></span><br><span class="line">  event.waitUntil(self.skipWaiting());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存更新</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;activate&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="params">cacheNames</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        <span class="comment">// 更新所有客户端 Service Worker</span></span><br><span class="line">        self.clients.claim(),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理旧版本</span></span><br><span class="line">        cacheNames.map(<span class="function"><span class="params">cacheName</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 如果当前版本和缓存版本不一样</span></span><br><span class="line">          <span class="keyword">if</span> (cacheName !== VERSION) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="再探更新"><a href="#再探更新" class="headerlink" title="再探更新"></a>再探更新</h3><p>上一部分说了更新 sw 的 2 个步骤，但是为什么这么做呢？</p>
<p>因为对于同一个 sw.js 文件，浏览器可以检测到它已经更新（假设旧代码是 sw1，新代码是 sw2）。由于 sw1 还在运行，以及默认只运行一个同名的 sw 代码，所以 sw2 处于 waiting 状态。<strong>所以需要强制跳过 waiting 状态</strong> 。</p>
<p>进入 activate 后，还需要取得“控制权”，并且弃用旧代码 sw1。上方的代码顺便清理了旧版本的缓存。</p>
<h3 id="资源拦截"><a href="#资源拦截" class="headerlink" title="资源拦截"></a>资源拦截</h3><p>在代码的最后，需要监听 <code>fetch</code>  事件，并且进行拦截。如果命中，返回缓存；如果未命中，放通请求，并且将请求后的资源缓存下来。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 Service Workder 有自己的返回</span></span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> request = event.request.clone();</span><br><span class="line">      <span class="keyword">return</span> fetch(request).then(<span class="function"><span class="params">httpRes</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// http请求的返回已被抓到，可以处置了。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求失败了，直接返回失败的结果就好了。。</span></span><br><span class="line">        <span class="keyword">if</span> (!httpRes || httpRes.status !== <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> httpRes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求成功的话，将请求缓存起来。</span></span><br><span class="line">        <span class="keyword">let</span> responseClone = httpRes.clone();</span><br><span class="line">        caches.open(VERSION).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">          cache.put(event.request, responseClone);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpRes;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>启动服务后，进入 <code>localhost</code> ，打开 devtools 面板。可以看到资源都通过 ServiceWorker 缓存加载进来了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554261787790-8516ca44-1872-4e8d-b063-25dab02682b7.png#align=left&display=inline&height=364&name=image.png&originHeight=455&originWidth=1608&size=81057&status=done&width=1286" alt="image.png"></p>
<p>现在，我们打开离线模式，</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554261882352-6ef567ff-b6c7-4916-aa5c-89fbbfc9d68f.png#align=left&display=inline&height=520&name=image.png&originHeight=650&originWidth=907&size=62316&status=done&width=726" alt="image.png"></p>
<p>离线模式下照样可以访问：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554261936715-57129714-6312-4e72-8679-7563ff529b83.png#align=left&display=inline&height=725&name=image.png&originHeight=906&originWidth=1920&size=401854&status=done&width=1536" alt="image.png"></p>
<p>最后，我们修改一下 html 的代码，并且更新一下 sw.js 中标识缓存版本的变量 VERSION：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554262033555-b36bfb5a-16ee-4079-a400-b2239a93ee9c.png#align=left&display=inline&height=733&name=image.png&originHeight=916&originWidth=1920&size=285955&status=done&width=1536" alt="image.png"></p>
<p>在第 2 次刷新后，通过上图可以看到，缓存版本内容已更新到 v2，并且左侧内容区已经被改变。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn">Service Worker 生命周期</a></li>
<li><a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/how-to-use-service-worker">百度团队：怎么使用 ServiceWorker</a></li>
<li><a href="https://www.villainhr.com/page/2016/08/22/Web%20Worker">Web Worker 开发模式</a></li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas学习和滤镜实现</title>
    <url>/2018/10/24/qian-duan-zhi-shi-ti-xi/03.html5/canvas-xue-xi-he-lu-jing-shi-xian/</url>
    <content><![CDATA[<blockquote>
<p>最近学习了 HTML5 中的重头戏–<code>canvas</code>。利用 canvas，前端人员可以很轻松地、进行图像处理。其 API 繁多，这次主要学习常用的 API，并且完成以下两个代码：</p>
<ol>
<li>实现去色滤镜：<br><img src="https://s2.ax1x.com/2019/12/23/l93oPU.png"></li>
<li>实现负色(反色)滤镜<br><img src="https://s2.ax1x.com/2019/12/23/l93HxJ.png"></li>
</ol>
</blockquote>
<h2 id="1-了解-canvas？"><a href="#1-了解-canvas？" class="headerlink" title="1 了解 canvas？"></a>1 了解 canvas？</h2><h3 id="1-1-什么是-canvas？"><a href="#1-1-什么是-canvas？" class="headerlink" title="1.1 什么是 canvas？"></a>1.1 什么是 canvas？</h3><p>这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。</p>
<h3 id="1-2-canvas-和-svg、vml-的区别？"><a href="#1-2-canvas-和-svg、vml-的区别？" class="headerlink" title="1.2 canvas 和 svg、vml 的区别？"></a>1.2 canvas 和 svg、vml 的区别？</h3><p><code>&lt;canvas&gt;</code> 标记和 SVG 以及 VML 之间的一个重要的不同是，<code>&lt;canvas&gt;</code> 有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。</p>
<h2 id="2-canvas-绘图学习"><a href="#2-canvas-绘图学习" class="headerlink" title="2 canvas 绘图学习"></a>2 canvas 绘图学习</h2><p>大多数 Canvas 绘图 API 都没有定义在 <code>&lt;canvas&gt;</code> 元素本身上，而是定义在通过画布的<code>getContext()</code>方法获得的一个“绘图环境”对象上。而<code>&lt;canvas&gt;</code>元素本身默认的宽高分别是 300px、150px。</p>
<h3 id="2-1-canvas-绘制矩形"><a href="#2-1-canvas-绘制矩形" class="headerlink" title="2.1 canvas 绘制矩形"></a>2.1 canvas 绘制矩形</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理canvas元素</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line">c.width = <span class="number">150</span>;</span><br><span class="line">c.height = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 指定canvas标签 上的context对象</span></span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">&quot;#FF0000&quot;</span>; <span class="comment">// 颜色</span></span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">75</span>); <span class="comment">// 形状</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-canvas-绘制路径"><a href="#2-2-canvas-绘制路径" class="headerlink" title="2.2 canvas 绘制路径"></a>2.2 canvas 绘制路径</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 开始坐标</span></span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 结束坐标</span></span><br><span class="line">ctx.stroke(); <span class="comment">// 立即绘制</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-canvas-绘制圆形"><a href="#2-3-canvas-绘制圆形" class="headerlink" title="2.3 canvas 绘制圆形"></a>2.3 canvas 绘制圆形</h3><p>对于<code>ctx.arc()</code>这个接口，5 个参数是:<code>(x,y,r,start,stop)</code>。其中，x 和 y 是圆心坐标，r 是半径。</p>
<p>而<code>start</code>和<code>stop</code>的单位是<strong>弧度制</strong>。不是长度，也不是 °。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">95</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-canvas-绘制文字"><a href="#2-4-canvas-绘制文字" class="headerlink" title="2.4 canvas 绘制文字"></a>2.4 canvas 绘制文字</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myCanvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.font = <span class="string">&quot;30px Arial&quot;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&quot;Hello World&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-canvas-图像处理学习"><a href="#3-canvas-图像处理学习" class="headerlink" title="3 canvas 图像处理学习"></a>3 canvas 图像处理学习</h2><h3 id="3-1-常用-API-接口"><a href="#3-1-常用-API-接口" class="headerlink" title="3.1 常用 API 接口"></a>3.1 常用 API 接口</h3><blockquote>
<p>关于图像处理的 API，主要有 4 个：</p>
<ul>
<li>绘制图像： <code>drawImage(img,x,y,width,height)</code> 或 <code>drawImage(img,sx,sy,swidth,sheight,x,y,width,height)</code></li>
<li>获取图像数据： <code>getImageData(x,y,width,height)</code></li>
<li>重写图像数据： <code>putImageData(imgData,x,y[,dirtyX,dirtyY,dirtyWidth,dirtyHeight])</code></li>
<li>导出图像： <code>toDataURL([type, encoderOptions])</code></li>
</ul>
</blockquote>
<p>更详细的 API 和参数说明请看：<a href="https://www.jb51.net/article/123995.htm">canvas 图像处理 API 参数讲解</a></p>
<h3 id="3-2-绘制图像"><a href="#3-2-绘制图像" class="headerlink" title="3.2 绘制图像"></a>3.2 绘制图像</h3><p>在此些 API 的基础上，我们就可以在<code>canvas</code>元素中绘制我们的图片。假设我们图片是<code>./img/photo.jpg</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image() <span class="comment">// 声明新的Image对象</span></span><br><span class="line">    img.src = <span class="string">&quot;./img/photo.jpg&quot;</span></span><br><span class="line">    <span class="comment">// 图片加载后</span></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据image大小，指定canvas大小</span></span><br><span class="line">      canvas.width = img.width</span><br><span class="line">      canvas.height = img.height</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 绘制图像</span></span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如下图所示，图片被画入了 canvas：<br><img src="https://s2.ax1x.com/2019/12/23/l93qM9.png"></p>
<h2 id="4-实现滤镜"><a href="#4-实现滤镜" class="headerlink" title="4 实现滤镜"></a>4 实现滤镜</h2><blockquote>
<p>这里我们主要借用<code>getImageData</code>函数，他返回每个像素的 RGBA 值。借助图像处理公式，操作像素进行相应的、数学运算即可。</p>
</blockquote>
<p><a href="http://www.css88.com/book/css/values/color/rgba.htm">什么是 RGBA？</a></p>
<p><a href="https://www.cnblogs.com/st-leslie/p/8317850.html?utm_source=debugrun&utm_medium=referral">更多滤镜实现</a></p>
<h3 id="4-1-去色效果"><a href="#4-1-去色效果" class="headerlink" title="4.1 去色效果"></a>4.1 去色效果</h3><p>去色效果相当于就是老旧相机拍出来的黑白照片。人们根据人眼的敏感程度，给出了如下公式：</p>
<p><code>gray = red * 0.3 + green * 0.59 + blue * 0.11</code></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    img.src = <span class="string">&quot;./img/photo.jpg&quot;</span></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">      canvas.width = img.width</span><br><span class="line">      canvas.height = img.height</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始滤镜处理</span></span><br><span class="line">      <span class="keyword">var</span> imgData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgData.data.length / <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">var</span> red = imgData.data[i * <span class="number">4</span>],</span><br><span class="line">          green = imgData.data[i * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">          blue = imgData.data[i * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">var</span> gray = <span class="number">0.3</span> * red + <span class="number">0.59</span> * green + <span class="number">0.11</span> * blue; <span class="comment">// 计算gray</span></span><br><span class="line">        <span class="comment">// 刷新RGB，注意：</span></span><br><span class="line">        <span class="comment">// imgData.data[i * 4 + 3]存放的是alpha，不需要改动</span></span><br><span class="line">        imgData.data[i * <span class="number">4</span>] = gray;</span><br><span class="line">        imgData.data[i * <span class="number">4</span> + <span class="number">1</span>] = gray;</span><br><span class="line">        imgData.data[i * <span class="number">4</span> + <span class="number">2</span>] = gray;</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.putImageData(imgData, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 重写图像数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下图所示：<br><img src="https://s2.ax1x.com/2019/12/23/l93oPU.png"></p>
<h3 id="4-2-负色效果"><a href="#4-2-负色效果" class="headerlink" title="4.2 负色效果"></a>4.2 负色效果</h3><p>负色效果就是用最大值减去当前值。而 getImageData 获得的 RGB 中的数值理论最大值是：255。所以，公式如下：</p>
<p><code>new_val = 255 - val</code></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    img.src = <span class="string">&quot;./img/photo.jpg&quot;</span></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">      canvas.width = img.width</span><br><span class="line">      canvas.height = img.height</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始滤镜处理</span></span><br><span class="line">      <span class="keyword">var</span> imgData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgData.data.length / <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">var</span> red = imgData.data[i * <span class="number">4</span>],</span><br><span class="line">          green = imgData.data[i * <span class="number">4</span> + <span class="number">1</span>],</span><br><span class="line">          blue = imgData.data[i * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 刷新RGB，注意：</span></span><br><span class="line">        <span class="comment">// imgData.data[i * 4 + 3]存放的是alpha，不需要改动</span></span><br><span class="line">        imgData.data[i * <span class="number">4</span>] = <span class="number">255</span> - imgData.data[i * <span class="number">4</span>];</span><br><span class="line">        imgData.data[i * <span class="number">4</span> + <span class="number">1</span>] = <span class="number">255</span> - imgData.data[i * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">        imgData.data[i * <span class="number">4</span> + <span class="number">2</span>] = <span class="number">255</span> - imgData.data[i * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.putImageData(imgData, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 重写图像数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果图如下：<br><img src="https://s2.ax1x.com/2019/12/23/l93xIK.png"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket学习和群聊实现</title>
    <url>/2019/05/20/qian-duan-zhi-shi-ti-xi/03.html5/websocket-xue-xi-he-qun-liao-shi-xian/</url>
    <content><![CDATA[<blockquote>
<p><code>WebSocket</code>协议可以实现前后端全双工通信，从而取代浪费资源的长轮询。在此协议的基础上，可以实现前后端数据、多端数据，真正的<strong>实时响应</strong>。在学习<code>WebSocket</code>的过程中，实现了一个简化版群聊，过程和代码详细记录在这篇文章中。</p>
</blockquote>
<p>简易版的实时群聊效果图如下：<br><img src="https://static.godbmw.com/images/JavaScript/websocket%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%BE%A4%E8%81%8A%E5%AE%9E%E7%8E%B0/1.png"></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-WebSocket-是什么？"><a href="#1-1-WebSocket-是什么？" class="headerlink" title="1.1 WebSocket 是什么？"></a>1.1 WebSocket 是什么？</h3><ol>
<li>建立在 TCP 协议之上的网络通信协议</li>
<li>全双工通信协议</li>
<li>没有同源限制</li>
<li>可以发送文本、二进制数据等</li>
</ol>
<h3 id="1-2-为什么需要-WebSocket？"><a href="#1-2-为什么需要-WebSocket？" class="headerlink" title="1.2 为什么需要 WebSocket？"></a>1.2 为什么需要 WebSocket？</h3><p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>
<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>
<p>因此，如果在客户端想实时监听服务器变化，必须使用 ajax 来进行轮询，效率低，浪费资源。</p>
<p>而 websocket 就可以使得<strong>前后端进行全双工通信（两方都可以向对方进行数据推送），是真正的平等对话</strong>。</p>
<h2 id="2-WebSocket-客户端"><a href="#2-WebSocket-客户端" class="headerlink" title="2 WebSocket 客户端"></a>2 WebSocket 客户端</h2><p>支持<code>HTML5</code>的浏览器支持 WebSocket 协议：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(url); <span class="comment">// 创建一个websocket对象</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-WebSocket-属性"><a href="#2-1-WebSocket-属性" class="headerlink" title="2.1 WebSocket 属性"></a>2.1 WebSocket 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ws.readyState</td>
<td>只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td>ws.bufferedAmount</td>
<td>只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody></table>
<h3 id="2-2-WebSocket-方法"><a href="#2-2-WebSocket-方法" class="headerlink" title="2.2 WebSocket 方法"></a>2.2 WebSocket 方法</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ws.send()</td>
<td>数据发送</td>
</tr>
<tr>
<td>ws.close()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<h3 id="2-3-Websocket-事件"><a href="#2-3-Websocket-事件" class="headerlink" title="2.3 Websocket 事件"></a>2.3 Websocket 事件</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>连接建立触发</td>
</tr>
<tr>
<td>message</td>
<td>通信时触发</td>
</tr>
<tr>
<td>error</td>
<td>出错触发</td>
</tr>
<tr>
<td>close</td>
<td>关闭连接触发</td>
</tr>
</tbody></table>
<h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><p>假设我们在本地<code>8080</code>端口打开了 websocket 服务，那么，下面代码可以在浏览器中实现和这个服务的通信：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080/&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 建立连接触发</span></span></span><br><span class="line"><span class="javascript">    ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      ws.send(<span class="string">&quot;open ws&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;open ws&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收服务端数据触发</span></span></span><br><span class="line"><span class="javascript">    ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = evt.data;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Data is &quot;</span>, data);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 断开连接触发</span></span></span><br><span class="line"><span class="javascript">    ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;close ws&quot;</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-WebSocket-服务端"><a href="#3-WebSocket-服务端" class="headerlink" title="3 WebSocket 服务端"></a>3 WebSocket 服务端</h2><blockquote>
<p>关于服务端实现，根据技术选型不同，可以选用不同的库和包。我这里使用的是<code>node</code>的<code>ws</code>库来 websocket 服务端。</p>
</blockquote>
<p>在<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的博文</a>提到的<code>socket.io</code>库，在浏览器端的写法不兼容原生 API，准确来说，它们自己实现了一套 websocket。所以，使用的时候前后端都应该引用第三方库。<strong>这样就造成了代码迁移性，严重下降。</strong></p>
<p>综上所述，<code>ws</code>库有以下优点：</p>
<ol>
<li>兼容性好，兼容浏览器原生 API</li>
<li>长期维护，效果稳定</li>
<li>使用方便（往下看就知道了）</li>
</ol>
<h2 id="4-实现群聊"><a href="#4-实现群聊" class="headerlink" title="4 实现群聊"></a>4 实现群聊</h2><h3 id="4-1-群聊-服务端实现"><a href="#4-1-群聊-服务端实现" class="headerlink" title="4.1 群聊 服务端实现"></a>4.1 群聊 服务端实现</h3><p>首先，在命令行中，安装<code>ws</code>库: <code>npm install ws --save</code></p>
<p>现在，利用<code>ws</code>来实现一个监听<code>8080</code>端口的 websocket 服务器，<strong>讲解都在代码注释里，一目了然</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>; <span class="comment">// 监听端口</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>); <span class="comment">// 引入 ws 库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: PORT &#125;); <span class="comment">// 声明wss对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向除了本身之外所有客户端发送消息，实现群聊功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>data 要发送的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>ws 客户端连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wss.broadcastToElse = <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">data, ws</span>) </span>&#123;</span><br><span class="line">  wss.clients.forEach(<span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123;</span><br><span class="line">      client.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 客户端接入，触发 connection */</span></span><br><span class="line">wss.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws, req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ip = req.connection.remoteAddress; <span class="comment">// 通过req对象可以获得客户端信息，比如：ip，headers等</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 客户端发送消息，触发 message */</span></span><br><span class="line">  ws.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    ws.send(message); <span class="comment">// 向客户端发送消息</span></span><br><span class="line">    wss.broadcastToElse(message, ws); <span class="comment">// 向 其他的 客户端发送消息，实现群聊效果</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-群聊-客户端实现"><a href="#4-2-群聊-客户端实现" class="headerlink" title="4.2 群聊 客户端实现"></a>4.2 群聊 客户端实现</h3><p>为了方便编写，这里引入了<code>jquery</code>和<code>bootstrap</code>这两个库，只需要关注 js 代码即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>群聊<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">textarea</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rows</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;show-area&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">placeholder</span>=<span class="string">&quot;请输入聊天内容&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;chat-input&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info&quot;</span> <span class="attr">id</span>=<span class="string">&quot;send-btn&quot;</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> userName = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000</span>, <span class="number">10</span>); <span class="comment">// 随机用户名, 以标识身份</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> sendBtn = $(<span class="string">&quot;#send-btn&quot;</span>), <span class="comment">// 发送信息按钮</span></span></span><br><span class="line"><span class="javascript">        chatInput = $(<span class="string">&quot;#chat-input&quot;</span>), <span class="comment">// 聊天信息输入框</span></span></span><br><span class="line"><span class="javascript">        showArea = $(<span class="string">&quot;#show-area&quot;</span>); <span class="comment">// 聊天信息展示框</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8080/&quot;</span>); <span class="comment">// 初始化WebSocket对象</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      sendBtn.on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content = chatInput.val();</span></span><br><span class="line">        if (content.length === 0) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> alert(<span class="string">&quot;请不要输入空白内容&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        content =</span><br><span class="line"><span class="javascript">          <span class="string">&quot;At &quot;</span> +</span></span><br><span class="line"><span class="javascript">          <span class="keyword">new</span> <span class="built_in">Date</span>().toString() +</span></span><br><span class="line"><span class="javascript">          <span class="string">&quot;\n&quot;</span> +</span></span><br><span class="line"><span class="javascript">          <span class="string">&quot;来自用户&quot;</span> +</span></span><br><span class="line">          userName +</span><br><span class="line"><span class="javascript">          <span class="string">&quot;\n&quot;</span> +</span></span><br><span class="line"><span class="javascript">          content; <span class="comment">// 拼接用户信息、时间信息和消息</span></span></span><br><span class="line"><span class="javascript">        ws.send(content); <span class="comment">// 发送消息</span></span></span><br><span class="line"><span class="javascript">        chatInput.val(<span class="string">&quot;&quot;</span>); <span class="comment">// 清空输入框</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;Conncet open&quot;</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = evt.data;</span></span><br><span class="line"><span class="javascript">        showArea.val(showArea.val() + data + <span class="string">&quot;\n\n&quot;</span>); <span class="comment">// 刷新聊天信息展示框：显示群聊信息</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;Connect close&quot;</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-群聊-效果展示"><a href="#4-3-群聊-效果展示" class="headerlink" title="4.3 群聊 效果展示"></a>4.3 群聊 效果展示</h3><p>首先启动我们的服务端代码：<code>node server.js</code> 。其中，<code>server.js</code>是放置服务端代码的文件。</p>
<p>然后，我们打开 2 次编写的<code>html</code>代码，这相当于，打开 2 个客户端。来检测群聊功能。</p>
<p><img src="https://static.godbmw.com/images/JavaScript/websocket%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%BE%A4%E8%81%8A%E5%AE%9E%E7%8E%B0/1.png"></p>
<h2 id="5-相关资料"><a href="#5-相关资料" class="headerlink" title="5. 相关资料"></a>5. 相关资料</h2><ul>
<li>概念解释：<ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></li>
<li><a href="https://www.cnblogs.com/jingmoxukong/p/7755643.html">https://www.cnblogs.com/jingmoxukong/p/7755643.html</a></li>
</ul>
</li>
<li><code>ws</code>文档：<a href="https://www.npmjs.com/package/ws">https://www.npmjs.com/package/ws</a></li>
</ul>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas离屏技术与放大镜实现</title>
    <url>/2018/08/27/qian-duan-zhi-shi-ti-xi/03.html5/canvas-chi-ping-ji-zhu-yu-fang-da-jing-shi-xian/</url>
    <content><![CDATA[<blockquote>
<p>利用<code>canvas</code>除了可以实现滤镜，还可以利用<strong>离屏技术</strong>放大镜功能。</p>
</blockquote>
<p>为了方便讲解，本文分为 2 个应用部分：</p>
<ol>
<li>实现水印和中心缩放</li>
<li>实现放大镜</li>
</ol>
<h3 id="1-什么是离屏技术？"><a href="#1-什么是离屏技术？" class="headerlink" title="1. 什么是离屏技术？"></a>1. 什么是离屏技术？</h3><p><a href="https://root-lucas.github.io/passages/2018-08-20-canvas-beauty-filter/">canvas 学习和滤镜实现</a>介绍过<code>drawImage</code>接口。除了绘制图像，这个接口还可以：<strong>将一个<code>canvas</code>对象绘制到另一个<code>canvas</code>对象上</strong>。这就是离屏技术。</p>
<h3 id="2-实现水印和中心缩放"><a href="#2-实现水印和中心缩放" class="headerlink" title="2. 实现水印和中心缩放"></a>2. 实现水印和中心缩放</h3><p>在代码中，有两个 canvas 标签。分别是可见与不可见。<strong>不可见的 canvas 对象上的 Context 对象，就是我们放置图像水印的地方。</strong></p>
<p>更多详解，请看代码注释：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learn Canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      canvas &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#222</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      input &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        margin: 20px auto;</span><br><span class="line">        width: 800px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;my-canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">max</span>=<span class="string">&quot;3.0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;0.1&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;watermark-canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> watermarkCanvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#watermark-canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> slider = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> scale = slider.value;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> watermarkCtx = watermarkCanvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">/* 给第二个canvas获取的Context对象添加水印 */</span></span></span><br><span class="line">        watermarkCanvas.width = 300;</span><br><span class="line">        watermarkCanvas.height = 100;</span><br><span class="line"><span class="javascript">        watermarkCtx.font = <span class="string">&quot;bold 20px Arial&quot;</span>;</span></span><br><span class="line"><span class="javascript">        watermarkCtx.lineWidth = <span class="string">&quot;1&quot;</span>;</span></span><br><span class="line"><span class="javascript">        watermarkCtx.fillStyle = <span class="string">&quot;rgba(255 , 255 , 255, 0.5)&quot;</span>;</span></span><br><span class="line"><span class="javascript">        watermarkCtx.fillText(<span class="string">&quot;=== yuanxin.me ===&quot;</span>, <span class="number">50</span>, <span class="number">50</span>);</span></span><br><span class="line">        /****************************************/</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">        img.src = <span class="string">&quot;./img/photo.jpg&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">/* 加载图片后执行操作 */</span></span></span><br><span class="line"><span class="javascript">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          canvas.width = img.width;</span><br><span class="line">          canvas.height = img.height;</span><br><span class="line">          drawImageByScale(canvas, ctx, img, scale, watermarkCanvas);</span><br><span class="line"><span class="javascript">          <span class="comment">// 监听input标签的mousemove事件</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 注意：mousemove实时监听值的变化，内存消耗较大</span></span></span><br><span class="line"><span class="javascript">          slider.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            scale = slider.value;</span><br><span class="line">            drawImageByScale(canvas, ctx, img, scale, watermarkCanvas);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        /******************/</span><br><span class="line">      &#125;;</span><br><span class="line">      /**</span><br><span class="line">       *</span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Object</span>&#125; canvas 画布对象</span></span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Object</span>&#125; ctx</span></span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Object</span>&#125; img</span></span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Number</span>&#125; scale 缩放比例</span></span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Object</span>&#125; watermark 水印对象</span></span><br><span class="line">       */</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">drawImageByScale</span>(<span class="params">canvas, ctx, img, scale, watermark</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 图像按照比例进行缩放</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> width = img.width * scale,</span></span><br><span class="line">          height = img.height * scale;</span><br><span class="line"><span class="javascript">        <span class="comment">// (dx, dy): 画布上绘制img的起始坐标</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> dx = canvas.width / <span class="number">2</span> - width / <span class="number">2</span>,</span></span><br><span class="line">          dy = canvas.height / 2 - height / 2;</span><br><span class="line"><span class="javascript">        ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); <span class="comment">// No1 清空画布</span></span></span><br><span class="line"><span class="javascript">        ctx.drawImage(img, dx, dy, width, height); <span class="comment">// No2 重新绘制图像</span></span></span><br><span class="line">        if (watermark) &#123;</span><br><span class="line"><span class="javascript">          <span class="comment">// No3 判断是否有水印: 有, 绘制水印</span></span></span><br><span class="line">          ctx.drawImage(</span><br><span class="line">            watermark,</span><br><span class="line">            canvas.width - watermark.width,</span><br><span class="line">            canvas.height - watermark.height</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现效果如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/12/23/l98ZIf.png"></p>
<p>拖动滑竿，即可放大和缩小图像。然后右键保存图像。保存后的图像，就有已经有了水印，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/12/23/l98uRg.png"></p>
<h3 id="3-实现放大镜"><a href="#3-实现放大镜" class="headerlink" title="3. 实现放大镜"></a>3. 实现放大镜</h3><p>在上述中心缩放的基础上，实现放大镜主需要注意以下 2 个部分：</p>
<ol>
<li>细化处理<code>canvas</code>的鼠标响应事件：滑入、滑出、点击和松开</li>
<li>重新计算离屏坐标（详细公式计算思路请见代码注释）</li>
<li>重新计算鼠标相对于 canvas 标签的坐标（详细公式计算思路请见代码注释）</li>
</ol>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      canvas &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#222</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;my-canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;off-canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> isMouseDown = <span class="literal">false</span>,</span></span><br><span class="line">        scale = 1.0;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#my-canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> offCanvas = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#off-canvas&quot;</span>); <span class="comment">// 离屏 canvas</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> offCtx = offCanvas.getContext(<span class="string">&quot;2d&quot;</span>); <span class="comment">// 离屏 canvas 的 Context对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        img.src = <span class="string">&quot;./img/photo.jpg&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">          canvas.width = img.width;</span><br><span class="line">          canvas.height = img.height;</span><br><span class="line"></span><br><span class="line">          offCanvas.width = img.width;</span><br><span class="line">          offCanvas.height = img.height;</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// 计算缩放比例</span></span></span><br><span class="line">          scale = offCanvas.width / canvas.width;</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// 初识状态下, 两个canvas均绘制Image</span></span></span><br><span class="line">          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);</span><br><span class="line">          offCtx.drawImage(img, 0, 0, canvas.width, canvas.height);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 鼠标按下</span></span></span><br><span class="line"><span class="javascript">        canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          event.preventDefault(); <span class="comment">// 禁用默认事件</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> point = windowToCanvas(event.clientX, event.clientY); <span class="comment">// 获取鼠标相对于 canvas 标签的坐标</span></span></span><br><span class="line"><span class="javascript">          isMouseDown = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">          drawCanvasWithMagnifier(<span class="literal">true</span>, point); <span class="comment">// 绘制在离屏canvas上绘制放大后的图像</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 鼠标移动</span></span></span><br><span class="line"><span class="javascript">        canvas.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          event.preventDefault(); <span class="comment">// 禁用默认事件</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (isMouseDown === <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> point = windowToCanvas(event.clientX, event.clientY);</span></span><br><span class="line"><span class="javascript">            drawCanvasWithMagnifier(<span class="literal">true</span>, point);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 鼠标松开</span></span></span><br><span class="line"><span class="javascript">        canvas.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          event.preventDefault(); <span class="comment">// 禁用默认事件</span></span></span><br><span class="line"><span class="javascript">          isMouseDown = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">          drawCanvasWithMagnifier(<span class="literal">false</span>); <span class="comment">// 不绘制离屏放大镜</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 鼠标移出canvas标签</span></span></span><br><span class="line"><span class="javascript">        canvas.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          event.preventDefault(); <span class="comment">// 禁用默认事件</span></span></span><br><span class="line"><span class="javascript">          isMouseDown = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">          drawCanvasWithMagnifier(<span class="literal">false</span>); <span class="comment">// 不绘制离屏放大镜</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * 返回鼠标相对于canvas左上角的坐标</span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Number</span>&#125; x 鼠标的屏幕坐标x</span></span><br><span class="line"><span class="javascript">       * @param &#123;<span class="built_in">Number</span>&#125; y 鼠标的屏幕坐标y</span></span><br><span class="line">       */</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">windowToCanvas</span>(<span class="params">x, y</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bbox = canvas.getBoundingClientRect(); <span class="comment">// bbox中存储的是canvas相对于屏幕的坐标</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">          x: x - bbox.x,</span><br><span class="line">          y: y - bbox.y</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">drawCanvasWithMagnifier</span>(<span class="params">isShow, point</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); <span class="comment">// 清空画布</span></span></span><br><span class="line"><span class="javascript">        ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height); <span class="comment">// 在画布上绘制图像</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">/* 利用离屏，绘制放大镜 */</span></span></span><br><span class="line">        if (isShow) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> &#123; x, y &#125; = point;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> mr = <span class="number">50</span>; <span class="comment">// 正方形放大镜边长</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// (sx, sy): 待放大图像的开始坐标</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> sx = x - mr / <span class="number">2</span>,</span></span><br><span class="line">            sy = y - mr / 2;</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// (dx, dy): 已放大图像的开始坐标</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> dx = x - mr,</span></span><br><span class="line">            dy = y - mr;</span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="comment">// 将offCanvas上的(sx,sy)开始的长宽均为mr的正方形区域</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 放大到</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// canvas上的(dx,dy)开始的长宽均为 2 * mr 的正方形可视区域</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 由此实现放大效果</span></span></span><br><span class="line">          ctx.drawImage(offCanvas, sx, sy, mr, mr, dx, dy, 2 * mr, 2 * mr);</span><br><span class="line">        &#125;</span><br><span class="line">        /*********************/</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>放大镜效果如下图所示(被红笔标出的区域就是我们的正方形放大镜)：</p>
<p><img src="https://s2.ax1x.com/2019/12/23/l981Ln.png"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试中常考的源码实现</title>
    <url>/2018/08/24/qian-duan-zhi-shi-ti-xi/04.offer/qian-duan-mian-shi-zhong-chang-kao-de-yuan-ma-shi-xian/</url>
    <content><![CDATA[<p>👇 内容速览 👇</p>
<ul>
<li>手动实现<code>call</code>/<code>apply</code>/<code>bind</code></li>
<li>实现深拷贝函数</li>
<li>基于<code>ES5</code>/<code>ES6</code>实现双向绑定</li>
<li><code>instanceof</code>原理与实现</li>
<li>实现支持绑定、解绑和派发的事件类</li>
</ul>
<h2 id="手动撸个-call-apply-bind"><a href="#手动撸个-call-apply-bind" class="headerlink" title="手动撸个 call/apply/bind"></a>手动撸个 call/apply/bind</h2><h3 id="实现-call"><a href="#实现-call" class="headerlink" title="实现 call"></a>实现 call</h3><p>来看下<code>call</code>的原生表现形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.call(</span><br><span class="line">  &#123;</span><br><span class="line">    a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    b: <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>好了，开始手动实现我们的<code>call2</code>。在实现的过程有个关键：</p>
<p><strong>如果一个函数作为一个对象的属性，那么通过对象的<code>.</code>运算符调用此函数，<code>this</code>就是此对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  b: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg1, arg2);</span><br><span class="line">    <span class="comment">// this.a 就是 a; this.b 就是 b</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.test(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>知道了实现关键，下面就是我们模拟的<code>call</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认上下文是window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 保存默认的fn</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fn &#125; = context;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面讲的关键，将函数本身作为对象context的属性调用，自动绑定this</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 恢复默认的fn</span></span><br><span class="line">  context.fn = fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.call2(</span><br><span class="line">  &#123;</span><br><span class="line">    a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    b: <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="实现-apply"><a href="#实现-apply" class="headerlink" title="实现 apply"></a>实现 apply</h3><p><code>apply</code>和<code>call</code>实现类似，只是传入的参数形式是数组形式，而不是逗号分隔的参数序列。</p>
<p>因此，借助 es6 提供的<code>...</code>运算符，就可以很方便的实现数组和参数序列的转化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; fn &#125; = context;</span><br><span class="line"></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="comment">// 通过...运算符将数组转换为用逗号分隔的参数序列</span></span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.fn = fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.apply2(</span><br><span class="line">  &#123;</span><br><span class="line">    a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    b: <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="实现-bind"><a href="#实现-bind" class="headerlink" title="实现 bind"></a>实现 bind</h3><p><code>bind</code>的实现有点意思，它有两个特点：</p>
<ul>
<li>本身返回一个新的函数，所以要考虑<code>new</code>的情况</li>
<li>可以“保留”参数，内部实现了参数的拼接</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 保留之前的参数，为了下面的参数拼接</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果被new创建实例，不会被改变上下文！</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> that(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// args.concat(...arguments): 拼接之前和现在的参数</span></span><br><span class="line">    <span class="comment">// 注意：arguments是个类Array的Object, 用解构运算符..., 直接拿值拼接</span></span><br><span class="line">    <span class="keyword">return</span> that.apply(context, args.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg1, arg2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, <span class="built_in">this</span>.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test2 = test.bind2(</span><br><span class="line">  &#123;</span><br><span class="line">    a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    b: <span class="string">&quot;b&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">); <span class="comment">// 参数 1</span></span><br><span class="line"></span><br><span class="line">test2(<span class="number">2</span>); <span class="comment">// 参数 2</span></span><br></pre></td></tr></table></figure>

<h2 id="实现深拷贝函数"><a href="#实现深拷贝函数" class="headerlink" title="实现深拷贝函数"></a>实现深拷贝函数</h2><p>实现一个对象的深拷贝函数，需要考虑对象的元素类型以及对应的解决方案：</p>
<ul>
<li>基础类型：这种最简单，直接赋值即可</li>
<li>对象类型：递归调用拷贝函数</li>
<li>数组类型：这种最难，因为数组中的元素可能是基础类型、对象还可能数组，因此要专门做一个函数来处理数组的深拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组的深拷贝函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">src</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneArr</span>(<span class="params">src, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      target.push(cloneArr(item, []));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      target.push(deepClone(item, &#123;&#125;));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象的深拷贝实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">src</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">src, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Reflect</span>.ownKeys(src);</span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    value = src[key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      target[key] = cloneArr(value, []);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是对象而且不是数组, 那么递归调用深拷贝</span></span><br><span class="line">      target[key] = deepClone(value, &#123;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是不是比网上看到的多了很多？因为考虑很周全，请看下面的测试用例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个对象a是一个囊括以上所有情况的对象</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">&quot;FE&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  schools: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&quot;shenda&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&quot;shiyan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  arr: [</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        value: <span class="string">&quot;1&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        value: <span class="string">&quot;2&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;;</span><br><span class="line">deepClone(a, b);</span><br><span class="line"></span><br><span class="line">a.jobs.first = <span class="string">&quot;native&quot;</span>;</span><br><span class="line">a.schools[<span class="number">0</span>].name = <span class="string">&quot;SZU&quot;</span>;</span><br><span class="line">a.arr[<span class="number">0</span>][<span class="number">0</span>].value = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.jobs.first, b.jobs.first); <span class="comment">// output: native FE</span></span><br><span class="line"><span class="built_in">console</span>.log(a.schools[<span class="number">0</span>], b.schools[<span class="number">0</span>]); <span class="comment">// output: &#123; name: &#x27;SZU&#x27; &#125; &#123; name: &#x27;shenda&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.arr[<span class="number">0</span>][<span class="number">0</span>].value, b.arr[<span class="number">0</span>][<span class="number">0</span>].value); <span class="comment">// output: 100 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(a.arr[<span class="number">0</span>])); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<p>看到测试用例，应该会有人奇怪为什么最后要输出<code>Array.isArray(a.arr[0])</code>。这主要是因为网上很多实现方法没有针对 array 做处理，直接将其当成 object，<strong>这样拷贝后虽然值没问题，但是 array 的元素会被转化为 object</strong>。这显然是错误的做法。</p>
<p>而上面所说的深拷贝函数就解决了这个问题。</p>
<h2 id="基于-ES5-ES6-实现“双向绑定”"><a href="#基于-ES5-ES6-实现“双向绑定”" class="headerlink" title="基于 ES5/ES6 实现“双向绑定”"></a>基于 ES5/ES6 实现“双向绑定”</h2><p>要想实现，就要先看看什么是“双向数据绑定”，它和“单向数据绑定”有什么区别？这样才能知道要实现什么效果嘛。</p>
<p><strong>双向绑定</strong>：视图（View）的变化能实时让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。</p>
<p><strong>单向数据绑定</strong>：只有从数据到视图这一方向的关系。</p>
<h3 id="ES5-的-Object-defineProperty"><a href="#ES5-的-Object-defineProperty" class="headerlink" title="ES5 的 Object.defineProperty"></a>ES5 的 Object.defineProperty</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">        value: <span class="string">&quot;&quot;</span></span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">onKeyUp</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">        obj.value = event.target.value;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 对 obj.value 进行拦截</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;value&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> value;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span></span><br><span class="line">          value = newValue;</span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">&quot;#value&quot;</span>).innerHTML = newValue; <span class="comment">// 更新视图层</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>).value = newValue; <span class="comment">// 数据模型改变</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>值是：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onkeyup</span>=<span class="string">&quot;onKeyUp(event)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-的-Proxy"><a href="#ES6-的-Proxy" class="headerlink" title="ES6 的 Proxy"></a>ES6 的 Proxy</h3><p>随着，vue3.0 放弃支持了 IE 浏览器。而且<code>Proxy</code>兼容性越来越好，能支持 13 种劫持操作。</p>
<p>因此，vue3.0 选择使用<code>Proxy</code>来实现双向数据绑定，而不再使用<code>Object.defineProperty</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;ie=edge&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">key === <span class="string">&#x27;value&#x27;</span></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#value&#x27;</span>).innerHTML = value</span><br><span class="line">          <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>).value = value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onKeyUp</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      newObj.value = event.target.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    值是：&lt;span id=<span class="string">&quot;value&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> onkeyup=<span class="string">&quot;onKeyUp(event)&quot;</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof-原理与实现"><a href="#instanceof-原理与实现" class="headerlink" title="instanceof 原理与实现"></a>instanceof 原理与实现</h2><p><code>instanceof</code>是通过原型链来进行判断的，所以只要不断地通过访问<code>__proto__</code>，就可以拿到构造函数的原型<code>prototype</code>。直到<code>null</code>停止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断left是不是right类型的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof2</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 沿着left的原型链, 看看是否有何prototype相等的节点</span></span><br><span class="line">  left = left.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instanceof2([], <span class="built_in">Array</span>)); <span class="comment">// output: true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(instanceof2(test, Test)); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<h2 id="实现支持绑定、解绑和派发的事件类"><a href="#实现支持绑定、解绑和派发的事件类" class="headerlink" title="实现支持绑定、解绑和派发的事件类"></a>实现支持绑定、解绑和派发的事件类</h2><p><strong>实现思路</strong>：这里涉及了“订阅/发布模式”的相关知识。参考<code>addEventListener(type, func)</code>和<code>removeEventListener(type, func)</code>的具体效果来实现即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组置空：</span></span><br><span class="line"><span class="comment">// arr = []; arr.length = 0; arr.splice(0, arr.length)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._cache = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册事件：如果不存在此种type，创建相关数组</span></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._cache[type] = <span class="built_in">this</span>._cache[type] || [];</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="built_in">this</span>._cache[type];</span><br><span class="line">    <span class="keyword">if</span> (fns.indexOf(callback) === -<span class="number">1</span>) &#123;</span><br><span class="line">      fns.push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件：对于一个type中的所有事件函数，均进行触发</span></span><br><span class="line">  <span class="function"><span class="title">trigger</span>(<span class="params">type, ...data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="built_in">this</span>._cache[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(...data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除事件：删除事件类型对应的array</span></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">type, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="built_in">this</span>._cache[type];</span><br><span class="line">    <span class="comment">// 检查是否存在type的事件绑定</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        <span class="comment">// 卸载指定的回调函数</span></span><br><span class="line">        <span class="keyword">let</span> index = fns.indexOf(callback);</span><br><span class="line">        <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">          fns.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 全部清空</span></span><br><span class="line">        fns = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是测试函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> Event();</span><br><span class="line">event</span><br><span class="line">  .on(<span class="string">&quot;test&quot;</span>, <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;)</span><br><span class="line">  .trigger(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器常见考点</title>
    <url>/2018/11/24/qian-duan-zhi-shi-ti-xi/04.offer/liu-lan-qi-chang-jian-kao-dian/</url>
    <content><![CDATA[<h2 id="1-加载页面和渲染过程"><a href="#1-加载页面和渲染过程" class="headerlink" title="1. 加载页面和渲染过程"></a>1. 加载页面和渲染过程</h2><blockquote>
<p>题目：浏览器从加载页面到渲染页面的过程。</p>
</blockquote>
<p><strong>① 加载过程</strong></p>
<p>要点如下：</p>
<ol>
<li><code>DNS</code>服务器解析域名的<code>IP</code>地址</li>
<li>建立<code>TCP</code>握手连接</li>
<li>向<code>IP</code>指向的服务器发送<code>HTTP</code>请求</li>
<li>服务器收到、处理并返回<code>HTTP</code>请求</li>
<li>浏览器获取返回内容</li>
</ol>
<p><strong>② 渲染过程</strong></p>
<p>要点如下：</p>
<ol>
<li>根据<code>HTML</code>代码生成<code>DOM</code>树</li>
<li>根据<code>CSS</code>生成<code>CSSDOM</code></li>
<li>将 DOM 树和 CSSOM 整合成 RenderTree</li>
<li>根据 RenderTree 开始渲染和展示</li>
<li>遇到<code>&lt;script&gt;</code>，会阻塞渲染</li>
</ol>
<p>这个过程要注意<code>&lt;link&gt;</code>标签位置，以及<code>&lt;script&gt;</code>标签位置和<code>HTML</code>提供的<code>async</code> <code>defer</code>属性</p>
<h2 id="2-渲染线程和-JS-引擎线程"><a href="#2-渲染线程和-JS-引擎线程" class="headerlink" title="2. 渲染线程和 JS 引擎线程"></a>2. 渲染线程和 JS 引擎线程</h2><p>浏览器中常见的线程有：渲染线程、JS 引擎线程、HTTP 线程等等。</p>
<p>例如，当我们打开一个 Ajax 请求的时候，就启动了一个 HTTP 线程。</p>
<p>同样地，我们可以用线程的只是解释：<strong>为什么直接操作 DOM 会变慢，性能损耗更大？因为 JS 引擎线程和渲染线程是互斥的</strong>。而直接操作 DOM 就会涉及到两个线程互斥之间的通信，所以开销更大。</p>
<p>除此之外，这还能解释为什么<code>&lt;script&gt;</code>标签为什么会阻塞 DOM 树渲染，毕竟 JS 是可以修改 DOM 的，<strong>如果 JS 执行的时候 UI 也工作，就有可能导致不安全的渲染</strong>。</p>
<h2 id="3-重绘和回流"><a href="#3-重绘和回流" class="headerlink" title="3. 重绘和回流"></a>3. 重绘和回流</h2><p>重绘（repaint）和回流（reflow）会在样式节点变动时候出现，回流所需要的成本更高，回流一定会引重绘。</p>
<p>重绘是只一些元素更新属性，这些属性只影响外观，不影响布局。比如背景颜色、字体颜色等等。</p>
<p>回流是元素的尺寸、布局、可见等属性发生改变。会导致渲染树重新构造。比如窗口字体大小变化、样式表改动、元素内容（尤其是输入控件）、css 伪类激活、offsetWidth 等属性计算。</p>
<h3 id="如何减少重绘回流？"><a href="#如何减少重绘回流？" class="headerlink" title="如何减少重绘回流？"></a>如何减少重绘回流？</h3><ul>
<li>避免逐项更改样式。<strong>一次性更改<code>style</code>属性，或者直接定义<code>class</code>属性</strong></li>
<li>避免直接插入<code>DOM</code>。<strong>在<code>documentFragment</code>上操作，然后再插入<code>document</code>中</strong></li>
<li>避免循环读取<code>offsetWidth</code>等属性。<strong>循环外存取</strong></li>
<li>避免复杂动画。<strong>利用绝对定位将其脱离文档流</strong></li>
<li>避免<code>CSS</code>选择符层级太多。<strong>尽量平级类名，参考 scss 中的<code>&amp;</code>的用法</strong></li>
<li>为频繁重绘或者回流的节点设置图层：<ul>
<li><code>iframe</code>、<code>video</code> 等节点自动变为图层</li>
<li>通过 3d 动画出发：<code>transform: translate3d(0, 0, 0)</code></li>
</ul>
</li>
<li>提前通知浏览器：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code> 属性</a></li>
</ul>
<h2 id="4-页面生命周期"><a href="#4-页面生命周期" class="headerlink" title="4. 页面生命周期"></a>4. 页面生命周期</h2><p><code>onload</code>和<code>DOMContentLoaded</code>触发的先后顺序是什么？</p>
<p>页面声明周期的变化，会触发<code>document</code>上的<code>readystatechange</code>事件，用户可以通过<code>document.readyState</code>拿到当前的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始时候的readyState</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);</span><br><span class="line"><span class="comment">// 每次改变都打印readyState</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;readystatechange&quot;</span>, <span class="function">() =&gt;</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的代码在 Chrome 中的输出是：</p>
<ol>
<li>loading：加载 document</li>
<li>interactive：document 加载成功，DOM 树构建完成</li>
<li>complete：图像，样式表和框架之类的子资源完成加载</li>
</ol>
<p><strong>所以，<code>DOMContentLoaded</code>是在<code>onload</code>前进行的</strong>。</p>
<ul>
<li><code>DOMContentLoaded</code>事件在 DOM 树构建完毕后被触发，我们可以在这个阶段使用 js 去访问元素。<ul>
<li><code>async</code>和<code>defer</code>的脚本可能还没有执行。</li>
<li>图片及其他资源文件可能还在下载中。</li>
</ul>
</li>
<li><code>load</code>事件在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。</li>
<li><code>beforeunload</code>在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。</li>
<li><del><code>unload</code>在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。</del></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DOMContentLoaded&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;load&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;will unload&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">window.addEventListener(&quot;unload&quot;, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">	console.log(&quot;unload&quot;);</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-property-和-attribute-区别"><a href="#5-property-和-attribute-区别" class="headerlink" title="5. property 和 attribute 区别"></a>5. property 和 attribute 区别</h2><p><strong>①property</strong></p>
<p>指的是属性：DOM 节点本质是 JS 对象，因此 property 可以理解成 JS 对象上的属性。而 property 改变，就是直接改变 JS 对象的属性。</p>
<p>比如<code>&lt;p&gt;</code>上有 style、className、nodeName 和 nodeType 等属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = $(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.style.width, p.className);</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName, p.nodeType);</span><br></pre></td></tr></table></figure>

<p><strong>②attribute</strong></p>
<p>attribute 是指 HTML 的属性，<strong>改变 attribute 就是针对 HTML 属性的 set 和 get</strong>，和 JS 对象无关。</p>
<p>常用的 API 就是：<code>getAttribute</code>和<code>setAttribute</code>。常见的用法是<code>setAttribute()</code>来设置元素的<code>style</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = $(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">p.setAttribute(<span class="string">&quot;data-name&quot;</span>, <span class="string">&quot;yuanxin&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.getAttribute(<span class="string">&quot;data-name&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="6-cookie、localStorage-以及-sessionStorage"><a href="#6-cookie、localStorage-以及-sessionStorage" class="headerlink" title="6. cookie、localStorage 以及 sessionStorage"></a>6. cookie、localStorage 以及 sessionStorage</h2><p><strong>cookie</strong>：</p>
<ul>
<li>大小限制为 4kb，主要用来保存登陆信息，一般会存储一段表示用户信息的数据。</li>
<li>生命周期上，一般是服务器设置失效时间；如果是浏览器生成，默认是关闭浏览器后失效。</li>
<li>每次会被携带在 http 头中，所以数据量过大的时候有性能问题。</li>
</ul>
<p><strong>localStorage</strong>：大小限制为 5MB，用于永久存储信息，也可以用于缓存 ajax 信息用于离线应用。它保存在浏览器，不参与与服务器的通信。</p>
<p><strong>sessionStorage</strong>：与 localStorage 类似，不同的是信息不是永久存储，仅在当前会话下有效。关闭标签或者浏览器，都会清除。</p>
<h2 id="7-AJAX"><a href="#7-AJAX" class="headerlink" title="7. AJAX"></a>7. AJAX</h2><h3 id="7-1-XMLHttpRequest"><a href="#7-1-XMLHttpRequest" class="headerlink" title="7.1 XMLHttpRequest"></a>7.1 XMLHttpRequest</h3><blockquote>
<p>题目：不借助任何库实现<code>XMLHttpRequest</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// readyState 为 4 和 status 为 200 的时候，是正常情况</span></span><br><span class="line"><span class="comment">// Step1: 监听状态</span></span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    xhr.status === <span class="number">200</span> &amp;&amp; <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// xhr.open(method: [get, post], url: string, async: [true, false])</span></span><br><span class="line"><span class="comment">// async: 默认是 true; 代表异步请求</span></span><br><span class="line"><span class="comment">// 如果async = false, 那么 xhr.send() 会阻塞</span></span><br><span class="line"><span class="comment">// Step2: 打开请求</span></span><br><span class="line">xhr.open(</span><br><span class="line">  <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="string">&quot;http://localhost:5050/search/song?key=周杰伦&amp;page=1&amp;limit=10&amp;vendor=qq&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// Step3: 发送请求</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h3 id="7-2-Fetch-API"><a href="#7-2-Fetch-API" class="headerlink" title="7.2 Fetch API"></a>7.2 Fetch API</h3><blockquote>
<p>题目：介绍和使用<code>fetch()</code></p>
</blockquote>
<p>淘汰了写法不舒服的<code>XMLHttpRequest</code>，本身支持<code>Promise</code>回调，是 ES6 下的最佳 AJAX 实践。但是浏览器兼容不是太好，但几年后，估计就只剩它了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="string">&quot;http://localhost:5050/search/song&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line">formData.append(<span class="string">&quot;page&quot;</span>, <span class="number">1</span>);</span><br><span class="line">formData.append(<span class="string">&quot;limit&quot;</span>, <span class="number">10</span>);</span><br><span class="line">formData.append(<span class="string">&quot;vendor&quot;</span>, <span class="string">&quot;qq&quot;</span>);</span><br><span class="line">fetch(api, &#123;</span><br><span class="line">  method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(json));</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>koabodyparser</code>不支持<code>FormData</code>解析（换用<code>koa-better-body</code>）。那么请用如下代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="string">&quot;http://localhost:5050/search/song&quot;</span>;</span><br><span class="line">fetch(api, &#123;</span><br><span class="line">  method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    key: <span class="string">&quot;周杰伦&quot;</span>,</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    limit: <span class="number">10</span>,</span><br><span class="line">    vendor: <span class="string">&quot;qq&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  headers: <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(json));</span><br></pre></td></tr></table></figure>

<h3 id="7-3-实现跨域"><a href="#7-3-实现跨域" class="headerlink" title="7.3 实现跨域"></a>7.3 实现跨域</h3><blockquote>
<p>题目：如何实现跨域？</p>
</blockquote>
<p>目前我已知的方法有三个：</p>
<ul>
<li>JSONP：通过<code>&lt;script&gt;</code>标签实现，但是只能实现<code>GET</code>请求</li>
<li>代理转发：Webpack 的 dev 模式，配合<code>proxy</code>选项，<strong>启动一个前端服务器</strong>，实现代理转发</li>
<li><strong>CORS</strong>：后端允许跨域资源共享，这是我最推荐的一种方法</li>
</ul>
<p>代理转发请见《webpack4 系列教程》，CORS 请见 Koa 部分。这里实现一下 JSONP。</p>
<p><strong>注意</strong>：<code>src</code>的<code>params</code>中<code>callback</code>属性，指定的是回调函数。实例的回调函数是：<code>handleResponse()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="keyword">const</span> handleResponse = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 &lt;script&gt; 标签</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src =</span><br><span class="line">  <span class="string">&quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向document中添加 &lt;script&gt; 标签，并且发送GET请求</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>axios全局代理实战</title>
    <url>/2019/04/16/qian-duan-zhi-shi-ti-xi/05.qi-ta-wen-zhang/axios-quan-ju-dai-li-shi-zhan/</url>
    <content><![CDATA[<p>在项目中，为了方便使用，对<code>axios</code>进行了二次封装，原因如下：</p>
<ol>
<li>由于内网服务器的安全策略，put、delete 等方法的请求无法发送到后台</li>
<li>为了方便快速对接后端服务器，api 接口的前缀、安全策略过期时间等通用配置应该抽离</li>
</ol>
<h3 id="公共配置抽离"><a href="#公共配置抽离" class="headerlink" title="公共配置抽离"></a>公共配置抽离</h3><p>假设后端 api 的前缀地址是：<code>//1.1.1.1/api/</code>，安全过期时间是 5000ms.</p>
<p>那么通用配置信息如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CONFIG = &#123;</span><br><span class="line">  baseURL: <span class="string">&quot;//1.1.1.1/api/&quot;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123; CONFIG &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure>

<h3 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a>编写拦截器</h3><p>“拦截器”的做法来源于设计模式中的“装饰器模式”，它能在不改变原有函数逻辑的情况下，添加其他业务逻辑。</p>
<p>低耦合的设计非常适用于参数过滤、中间层拦截等场景。</p>
<h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><p>考虑到业务场景，请求到后端的数据需要在 Headers 中带有认证数据。</p>
<p>同时，由于不支持 put、patch、delete 方法，只能在 headers 中通过添加字段来标识。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleRequest = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.headers.common[<span class="string">&quot;Authorization&quot;</span>] = token.get() || <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> method = config.method.toUpperCase();</span><br><span class="line">  <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PUT&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PATCH&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DELETE&quot;</span>:</span><br><span class="line">      <span class="comment">//方法转换</span></span><br><span class="line">      config.headers.common[<span class="string">&quot;X-Http-Method-Override&quot;</span>] = method;</span><br><span class="line">      config.method = <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance.interceptors.request.use(handleRequest, <span class="function"><span class="params">error</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="返回拦截器"><a href="#返回拦截器" class="headerlink" title="返回拦截器"></a>返回拦截器</h4><p>当数据从后端返回，出现错误的时候，也做一层数据过滤拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hanldeResponseError = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; response = &#123;&#125; &#125; = error;</span><br><span class="line">  <span class="keyword">switch</span> (response.status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">401</span>: <span class="comment">// 401:用户未登录需要先登录</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Unauthorized&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Forbidden&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">400</span>: <span class="comment">//操作失败</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">422</span>: <span class="comment">//表单验证失败</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">$&#123;response.data.message&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> response, hanldeResponseError);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>联调</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域学习</title>
    <url>/2019/10/24/qian-duan-zhi-shi-ti-xi/05.qi-ta-wen-zhang/qian-duan-kua-yu-xue-xi/</url>
    <content><![CDATA[<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul>
<li>什么是同源策略限制</li>
<li>前后端如何通信</li>
<li>如何创建Ajax</li>
<li>跨域通信的几种方式</li>
</ul>
<h3 id="一-什么是同源策略及限制"><a href="#一-什么是同源策略及限制" class="headerlink" title="一. 什么是同源策略及限制"></a>一. 什么是同源策略及限制</h3><p>同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，<strong>域名，协议，端口相同</strong>才能加载脚本，比如当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执。</p>
<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<p>一个<strong>源</strong>包括：<strong>协议</strong>、<strong>域名</strong>、**端口 ** : 这三个有一个不一样就是源不一样，就是我们所说的跨域了, 如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p>
<p><strong>限制：不是一个源的文档没有权利去操作另一个源的文档；</strong></p>
<p><strong>主要限制在几个方面</strong></p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取 （如我在自己的站点无法读取博客园用户的cookie）</li>
<li>DOM 无法获得</li>
<li>AJAX 请求不能发送<strong>（同源下的通信方式，但是可以通过方法规避这个限制）</strong>（Ajax只适合同源的通信）</li>
</ul>
<h3 id="二-前后端如何通信"><a href="#二-前后端如何通信" class="headerlink" title="二. 前后端如何通信"></a>二. 前后端如何通信</h3><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>Ajax  （同源下的通信方式）</li>
<li>WebSocket   （不受同源策略的限制）</li>
<li>CORS   （支持跨域通信，也支持同源通信）</li>
</ul>
<h3 id="三-如何创建Ajax"><a href="#三-如何创建Ajax" class="headerlink" title="三. 如何创建Ajax"></a>三. 如何创建Ajax</h3><ul>
<li>XMLHttpRequest对象的工作流程</li>
<li>兼容性处理</li>
<li>事件的触发条件</li>
<li>事件的触发顺序</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步，创建异步XMLHttpRequest对象</span></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">window</span>.XMLHttpRequest</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，注册回调函数</span></span><br><span class="line">xmlhttp.onreadystatechange = callback</span><br><span class="line"><span class="comment">//第三步，配置请求信息</span></span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;backend/api&quot;</span>,<span class="literal">false</span>);  <span class="comment">// 这里同步, 第三参数不写则为true(异步)</span></span><br><span class="line"><span class="comment">// 若是post请求下则需要配置请求头信息</span></span><br><span class="line"><span class="comment">// xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步，发送请求,</span></span><br><span class="line">xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//如果是post请求</span></span><br><span class="line"><span class="comment">//xmlHttp.send(&quot;methodName = GetAllComment&amp;str1=str1&amp;str2=str2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第五步,被执行回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">xmlhttp.readyState == <span class="number">200</span></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">xmlhttp.status == <span class="number">4</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是代码，那简单总结下如下，要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:</p>
<p>   (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>
<p>   (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>
<p>   (3)设置响应HTTP请求状态变化的函数.</p>
<p>   (4)发送HTTP请求.</p>
<p>   (5)获取异步调用返回的数据.</p>
<p>   (6)使用JavaScript和DOM实现局部刷新.</p>
<blockquote>
<p>Ajax通常用来与后端通信传输数据的 ，如<code>XML</code>和<code>json</code>数据</p>
</blockquote>
<h3 id="四-跨域通信的几种方式"><a href="#四-跨域通信的几种方式" class="headerlink" title="四.跨域通信的几种方式"></a>四.跨域通信的几种方式</h3><ul>
<li>JSONP</li>
<li>Hash</li>
<li>postMessage</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h4 id="1-JSONP跨域"><a href="#1-JSONP跨域" class="headerlink" title="1.JSONP跨域"></a>1.JSONP跨域</h4><p>在出现<code>postMessage、CORS</code>之前一直用JSONP做跨域通信的；</p>
<p><code>jsonp </code>利用script标签的异步加载来实现的，由于<code>script.src </code>不受同源策略的限制，所以可以动态的创建script标签，将要请求数据的域写在<code>src </code>中参数中附带回调的方法，服务器端返回回调函数的字符串，并带参数。</p>
<p>假如我们已经知道修改百度<code>url</code>地址链接<code>https://www.baidu.com/s?wd=你要搜索的值</code> 中改变<code>wd</code>对应后的值修改需求就能获得需求搜索相应的结果。当然百度在服务器也是对给数据开放<code>wd</code>数据接口的才行。</p>
<p>如我请求 <code>script.src=&quot;https://www.baidu.com/s?wd=要查找的名字&amp;callback=getInfoCallback</code>，服务器端将返回的数据是<code>&quot;name:root;age:22&quot;</code>，在客户端自定义好全局<code>getInfoCallBack()</code>接收函数，将获得数据并解析渲染更新HTML内容。 这种是最常见的方式。</p>
<p><strong>前端代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">admin&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">    script.src = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));   <span class="comment">// &#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>后端相应函数：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">callback(&#123;<span class="string">&quot;status&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><p>请看我早期文章 <a href="https://www.cnblogs.com/jing-tian/p/11006271.html#_label6">hash跨域</a></p>
<h4 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h4><p><code>postMessage</code>是<code>HTML5 XMLHttpRequest Level 2</code>中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p><strong>客户端发起：</strong></p>
<p>语法：<code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">otherWindow   其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</span><br><span class="line">message   	   要发送到的数据。</span><br><span class="line">targetOrigin   指定哪些窗口能接收到消息事件(其值可以是字符串<span class="string">&quot;*&quot;</span>（表示无限制）或者一个URI)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是http://www.domain1.com</span></span><br><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> style=<span class="string">&quot;display:none;&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = &#123;</span><br><span class="line">            name: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向domain2传送跨域数据</span></span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收从domain2返回的数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);	<span class="comment">// &#123;name:&quot;hello&quot;,number:16&#125;</span></span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p><strong>被跨域网站监听:</strong></p>
<p><code>message</code> 的属性有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data  从客户端传递过来的对象或数据。</span><br><span class="line">origin  发送方窗口的地址 origin . 这个字符串由 协议、“:&#x2F;&#x2F;“、域名、“ : 端口号”拼接而成。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是http://www.domain2.com</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 接收domain1的数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;	<span class="comment">// 监听分发的message</span></span><br><span class="line">        alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">       <span class="keyword">if</span> (e.origin == <span class="string">&quot;http://www.domain1.com:8080&quot;</span>)&#123;		<span class="comment">// 通过验证来源地址</span></span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                data.number = <span class="number">16</span>;</span><br><span class="line">                <span class="comment">// 处理后再发回domain1</span></span><br><span class="line">                <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。</strong> 这是一个完全万无一失的方式来避免安全问题。</p>
</blockquote>
<h4 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4.WebSocket"></a>4.WebSocket</h4><p><code>WebSocket protocol</code>也是HTML5一种新的协议。但它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。<strong>同时也允许跨域通讯</strong>，是server push技术的一种很好的实现。</p>
<p>原生WebSocket API使用起来不太方便，我们可以使用封装后的使用<code>Socket.io</code>模块。</p>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket">维基百科</a>）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; GET /chat HTTP/1.1</span><br><span class="line">&gt; Host: server.example.com</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">&gt; Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">&gt; Sec-WebSocket-Version: 13</span><br><span class="line">&gt; Origin: http://example.com</span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> HTTP/1.1 101 Switching Protocols</span><br><span class="line">&gt; Upgrade: websocket</span><br><span class="line">&gt; Connection: Upgrade</span><br><span class="line">&gt; Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">&gt; Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<p>具体用法<a href="https://www.cnblogs.com/jing-tian/p/11006271.html">参考文章</a></p>
<p>以及<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰的文章</a></p>
<h4 id="5-CORS"><a href="#5-CORS" class="headerlink" title="5.CORS"></a>5.CORS</h4><p><strong>Ajax一个变种，fetch实现CORS通信的–新出的通信标准，可以理解为支持跨域通信的Ajax</strong></p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>如何使用，请参考 <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">阮一峰文章</a></p>
<p>Ajax是不能发送跨域通信的，浏览器在识别你用Ajax发送了一个跨域请求的时候，<code>fetch</code>模块它会在你http头中加一个orgin，来允许跨域通信。如果不加这个头，就是一个普通的Ajax，遇到跨域通信，浏览器就会拦截了（非法的不允许请求）。</p>
<p>**CROS为什么就能支持跨域的这种通信？ **</p>
<p>浏览器会拦截ajax请求，如果它觉得这个ajax请求是跨域的，它会在http请求中，加一个<code>origin</code>字段（websocket就是如此）。</p>
<h4 id="6-nginx配置解决iconfont跨域"><a href="#6-nginx配置解决iconfont跨域" class="headerlink" title="6.nginx配置解决iconfont跨域"></a>6.nginx配置解决iconfont跨域</h4>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/01.zi-fu-chuan/01.ti-huan-kong-ge/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>请实现一个函数，把字符串中的每个空格替换成”%20”。</p>
<p>例如输入“We are happy.”，则输出“We%20are%20happy.”。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>一种是正则表达式：直接使用正则表达式全局替换，这种方法取巧一些。</p>
<p>另一种是先计算出来替换后的字符串长度，然后逐个填写字符。这种方法的时间复杂度是$O(N)$。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用正则表达式替换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repalceEmpty1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> re = <span class="regexp">/ /g</span></span><br><span class="line">    <span class="keyword">return</span> str.replace(re, <span class="string">&#x27;%20&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将空格替换为 %20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repalceEmpty2</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; ++i) &#123;</span><br><span class="line">        str[i] === <span class="string">&#x27; &#x27;</span> &amp;&amp; ++count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> length = str.length + count * <span class="number">2</span> <span class="comment">// 新的字符串的长度：%20比空格长度多2</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; result.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[j] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            result[i++] = <span class="string">&#x27;%&#x27;</span></span><br><span class="line">            result[i++] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">            result[i++] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = str[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(repalceEmpty1(<span class="string">&#x27;We are  happy&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(repalceEmpty2(<span class="string">&#x27;We are  happy&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端错误监控</title>
    <url>/2020/01/14/qian-duan-zhi-shi-ti-xi/05.qi-ta-wen-zhang/qian-duan-cuo-wu-jian-kong/</url>
    <content><![CDATA[<p>最近一直在做前端js错误监控的工作，在不断的打磨和完善中，发现里面还是知识点不少，现在就前端js错误监控做一些笔记和总结</p>
<h3 id="为什么要做前端错误监控"><a href="#为什么要做前端错误监控" class="headerlink" title="为什么要做前端错误监控?"></a>为什么要做前端错误监控?</h3><ol>
<li><p>为了保证产品的质量</p>
</li>
<li><p>有些问题只存在于线上特定的环境</p>
</li>
<li><p>后端错误有监控,前端错误没有监控</p>
</li>
</ol>
<p>下面会讲：</p>
<ul>
<li>前端错误的分类</li>
<li>错误的捕获方式</li>
<li>上报错误的基本原理</li>
</ul>
<h3 id="一-前端错误的分类"><a href="#一-前端错误的分类" class="headerlink" title="一. 前端错误的分类"></a>一. 前端错误的分类</h3><ol>
<li>即时运行错误：代码错误</li>
<li>资源加载错误：（js、css、图片加载失败）</li>
</ol>
<h3 id="二-错误的捕获方式"><a href="#二-错误的捕获方式" class="headerlink" title="二. 错误的捕获方式"></a>二. 错误的捕获方式</h3><ul>
<li>即时运行错误的捕获方式<ul>
<li>try….catch</li>
<li>window.onerror</li>
</ul>
</li>
<li>资源加载错误的捕获方式<ul>
<li>object.onerror </li>
<li>performance.getEntries</li>
<li>Error事件捕获</li>
</ul>
</li>
</ul>
<p><strong>1.即时运行错误的捕获方式</strong></p>
<h4 id="1-try…catch"><a href="#1-try…catch" class="headerlink" title="1.try…catch"></a>1.try…catch</h4><p>通过try…catch我们能够知道出错的信息,并且也有堆栈信息可以知道在哪个文件第几行第几列发生错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 代码段</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err.message)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点:</strong></p>
<ol>
<li>没法捕捉try,catch块，当前代码块有语法错误，JS解释器压根都不会执行当前这个代码块，所以也就没办法被catch住；</li>
<li>没法捕捉到全局的错误事件，也即是只有try,catch的块里边运行出错才会被你捕捉到，这里的块你要理解成一个函数块</li>
</ol>
<h4 id="2-window-onerror"><a href="#2-window-onerror" class="headerlink" title="2.window.onerror"></a>2.window.onerror</h4><p>全局捕获。<code>window.onerror</code>会在页面发生js错误时被调用可以收集到错误字符串信息、发生错误的js文件，错误所在的行数、列数、和Error对象（里面会有调用堆栈信息等）,还可以在window.onerror最后return true让浏览器不输出错误信息到控制台</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * @param message&#123;String&#125;：错误消息</span></span><br><span class="line"><span class="comment">         * @param source&#123;String&#125;：引发错误的脚本的URL</span></span><br><span class="line"><span class="comment">         * @param lineno&#123;Number&#125;：发生错误的代码行</span></span><br><span class="line"><span class="comment">         * @param colno&#123;Number&#125;：发生错误的代码列</span></span><br><span class="line"><span class="comment">         * @param error&#123;object&#125;：错误对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, line, colunm, error</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 返回 true 则错误消息不显示在控制台，返回 false，则错误消息将会展示在控制台</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-object-onerror"><a href="#3-object-onerror" class="headerlink" title="3.object.onerror"></a>3.object.onerror</h4><p>img、script标签都可以添加onerror事件,当资源请求失败的时候,都会触发该事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.onerror=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;出错啦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-performance-getEntries"><a href="#4-performance-getEntries" class="headerlink" title="4.performance.getEntries"></a>4.performance.getEntries</h4><p>performance是h5的新特性之一,使用该方法能获取到当前页面已经加载到的资源,返回的是一个数组对象。</p>
<p><strong>例子获取页面中没有成功加载的图片资源?</strong>   </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [],</span><br><span class="line">    imgList=<span class="literal">null</span>,</span><br><span class="line">    num=<span class="number">0</span>,</span><br><span class="line">    reg = (<span class="regexp">/\.jpg$|\.jpeg$|.png$|\.gif$/i</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.通过performance.getEntries()获取已经加载了的图片资源</span></span><br><span class="line">performance.getEntries().forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reg.test(item.name)) &#123;</span><br><span class="line">        arr.push(item.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.获取页面中所有的img标签</span></span><br><span class="line">imgList=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"><span class="comment">// 3.利用获取到的img的长度减去已经加载到的长度,如果大于0的部分,就是加载失败的</span></span><br><span class="line">num=imgList.length-arr.length; </span><br></pre></td></tr></table></figure>



<p><strong>控制台使用：</strong>  <code>var arr=[]; performance.getEntries().forEach((item,i)=&gt;&#123;console.log(arr[i]=item.name)&#125;)</code> 打印出网站中成功加载的所有资源。  </p>
<p>通过<code> document.getElementsByTagName(&#39;img&#39;).length</code>减去上面的成功加载就能得出报错的图片资源数量了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回网站内所有成功加载的png文件数量</span></span><br><span class="line"><span class="keyword">var</span> arr=[]; </span><br><span class="line">performance.getEntries().forEach(<span class="function">(<span class="params">item,i</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(arr[i]=item.name)&#125;)</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> search1 = arr[index];</span><br><span class="line">    <span class="keyword">return</span> search1.includes(<span class="string">&#x27;.png&#x27;</span>,search1.length-<span class="number">4</span>) != <span class="literal">false</span>;</span><br><span class="line">&#125;).length;</span><br></pre></td></tr></table></figure>

<h4 id="5-Error事件捕获"><a href="#5-Error事件捕获" class="headerlink" title="5. Error事件捕获"></a>5. Error事件捕获</h4><p>资源加载错误，虽然会阻止冒泡，但是不会阻止捕获。true:捕获，false:冒泡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// window.addEventListener第三个参数是true的时候是捕获的过程,false是冒泡的过程 </span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;捕获&quot;</span>,e)</span><br><span class="line">    &#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>



<h4 id="6-延伸"><a href="#6-延伸" class="headerlink" title="6.延伸"></a>6.延伸</h4><p>为了提升web性能,大部分web产品都有CDN部署,将资源部署到不同的域名上,但是我们都知道浏览器是有同源策略的,当加载不同域名的脚本发生错误时,语法错误的细节不会报告,仅返回”Script error”</p>
<p><strong>既然跨域JS运行错误可以捕获，错误提示是什么，应该怎么处理？</strong></p>
<img src="https://s2.ax1x.com/2020/01/14/lbnxTH.png" alt="捕获跨域错误" style="zoom:50%;">

<p>必须做俩件事：</p>
<ul>
<li>客户端：在请求资源的<code>script</code>标签中增加<code>crossorigin</code>属性</li>
<li>服务端：设置 <code>js</code>资源响应头<code>Access-Control-Origin:*</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;http://domain.com/a.js&quot;</span>  crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="三-上报错误的方式"><a href="#三-上报错误的方式" class="headerlink" title="三. 上报错误的方式"></a>三. 上报错误的方式</h3><p>开发 Web 应用程序过程中的一种常见的做法，就是集中保存错误日志，以便查找重要错误的原因。那么我们怎么将js的错误信息记录到服务器数据库库中呢。</p>
<ul>
<li>采用Ajax通信的方式上报 （所有的错误监控都不是通过这种方式来做的；）</li>
<li>利用Image对象上报（所有的监控体系都是这样做的，如谷歌）</li>
</ul>
<h4 id="1-采用Ajax通信的方式上报"><a href="#1-采用Ajax通信的方式上报" class="headerlink" title="1. 采用Ajax通信的方式上报"></a>1. 采用Ajax通信的方式上报</h4><p><strong>ajax来实现的弊端</strong></p>
<ul>
<li><p>不支持跨域操作，因为很多情况下是一台服务器要负责处理多台服务器的错误；</p>
</li>
<li><p>大多数Ajax通信都是通过javascript库提供的包装函数来处理，如果库代码本身就有问题， 而你还在依赖该库记录信息，可想而知，错误消息是不肯能得到记录的。</p>
</li>
</ul>
<p>怎么办？我们可以使用Image对象巧妙的解决这个问题</p>
<h4 id="2-利用Image对象上报"><a href="#2-利用Image对象上报" class="headerlink" title="2.利用Image对象上报"></a>2.利用Image对象上报</h4><p><strong>Image对象的优点:</strong></p>
<ul>
<li><p>所有浏览器都支持 Image 对象，包括那些不支持<code>XMLHttpRequest</code>对象的浏览器。</p>
</li>
<li><p>可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误，而这种情况下使用 <code>XMLHttpRequest </code>是不行的。</p>
</li>
<li><p>在记录错误的过程中出问题的概率比较低。大多数 Ajax 通信都是由 JavaScript 库提供的包装函 数来处理的，如果库代码本身有问题，而你还在依赖该库记录错误，可想而知，错误消息是不 可能得到记录的。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法1 */</span></span><br><span class="line"><span class="comment">//利用这种方式发送一个请求非常简单，比Ajax简单，不需要借助任何第三方库；</span></span><br><span class="line">(<span class="keyword">new</span> Image()).src=<span class="string">&quot;http://baidu.com/test?r=error&quot;</span>;</span><br><span class="line"><span class="comment">//一行代码实现一个资源向上报；/test?这个是上报路径；r=error加信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法2 配合try...catch 更佳*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">sev, msg</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> img = <span class="keyword">new</span> Image(); </span><br><span class="line">     img.src = <span class="string">&quot;log.php?sev=&quot;</span> + <span class="built_in">encodeURIComponent</span>(sev) + <span class="string">&quot;&amp;msg=&quot;</span> + <span class="built_in">encodeURIComponent</span>(msg);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=mods.length; i &lt; len; i++)&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">            mods[i].init(); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">            logError(<span class="string">&quot;nonfatal&quot;</span>, <span class="string">&quot;Module init failed: &quot;</span> + ex.message); </span><br><span class="line">      &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror">参考文章1</a></p>
<p><a href="https://www.cnblogs.com/cythia/p/11093231.html">参考文章2</a></p>
<p><a href="https://www.cnblogs.com/websharehome/p/8607668.html">参考文章3</a></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的全排列</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/01.zi-fu-chuan/02.zi-fu-chuan-de-quan-pai-lie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a、b、c 所能排列出来的所有字符串 abc、acb、bac、bca、cab 和 cba。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>把集合看成 2 个部分，第一部分是第一个元素，第二部分是后面剩余元素。所有字符都要与当前集合的第一个元素交换，交换后的元素是固定的，也就是一种情况。</p>
<p>每次交换，都继续处理后面剩余元素，它们又可以分成 2 部分，和之前讲述的一样。就这样一直递归下去，直到最后一个元素，那么就排出了其中一种情况。所有情况放在一起，就是全排列的结果。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组指定坐标的2个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">i</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">j</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    ;[arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测arr[start, end)中, 是否有和arr[end]相等的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">start</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">end</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[end] === arr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>arr 元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>n 起始位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span>(<span class="params">arr = [], n = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">if</span> (length === n) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr.join(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(arr, n, i)) &#123;</span><br><span class="line">            swap(arr, n, i)</span><br><span class="line">            perm(arr, n + <span class="number">1</span>)</span><br><span class="line">            swap(arr, n, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">perm([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;*&#x27;</span>.repeat(<span class="number">10</span>))</span><br><span class="line">perm([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/01.zi-fu-chuan/03.fan-zhuan-dan-ci-shun-xu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</p>
<p>为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>进行 2 次不同层次的翻转。第一个层次的翻转，是对整体字符串进行翻转。第二个层次的翻转，是对翻转后字符串中的单词进行翻转。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p><strong>注意</strong>：因为 js 按位重写字符，所以第一次整体字符串翻转后的每个字符，都放入了数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">sentence</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseSentence</span>(<span class="params">sentence</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次翻转：每个字符</span></span><br><span class="line">    <span class="keyword">const</span> chars = sentence.split(<span class="string">&#x27;&#x27;</span>).reverse()</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        last = [] <span class="comment">// 保存上一个空格到当前空格之间的所有字符</span></span><br><span class="line"></span><br><span class="line">    chars.forEach(<span class="function">(<span class="params">ch</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 遇到空格，说明之前的字符组成了单词</span></span><br><span class="line">        <span class="comment">// 进行第二次翻转：单词</span></span><br><span class="line">        <span class="keyword">if</span> (ch === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            result += last.reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            last.length = <span class="number">0</span> <span class="comment">// 清空上一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last.push(ch)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    result += last.reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码，输出：</span></span><br><span class="line"><span class="comment"> * student.a am I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(reverseSentence(<span class="string">&#x27;I am a student.&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实现atoi</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/01.zi-fu-chuan/04.shi-xian-atoi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>请你来实现一个  atoi  函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为  [−2^31,  2^31 − 1]。如果数值超过这个范围，qing 返回  INT_MAX (2^31 − 1) 或  INT_MIN (−2^31) 。</p>
<p>题目来自 <a href="https://leetcode-cn.com/problems/string-to-integer-atoi">LeetCode</a>，可以直接前往这个网址查看题目各种情况下要求的输出。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>这种题目主要就是考察细心，要主动处理所有情况。所以一步步来即可：</p>
<ol>
<li>找出第一个非空字符，判断是不是符号或者数字</li>
<li>如果是符号，那么判断正负号</li>
<li>如果符号后面跟的不是数字，那么就是非法的，返回 0</li>
<li>确定连续数字字符的起始边界</li>
<li>计算数字字符的代表的数字大小，并且判断是否越界</li>
<li>返回结果的时候注意符号</li>
</ol>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>代码通过了 leetcode 的测试，成绩还不错，如下图：</p>
<p><img src="https://static.godbmw.com/img/2019-06-23-str-atoi/1.png"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MIN_INT_ABS = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line"><span class="keyword">const</span> MAX_INT = MIN_INT_ABS - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断char是否是符号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">char</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymbol</span>(<span class="params">char</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> char === <span class="string">&#x27;-&#x27;</span> || char === <span class="string">&#x27;+&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断char是否是数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">char</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">char</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> char &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟atoi(str)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAtoi</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = str.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出第一个非空字符，判断是不是符号或者数字</span></span><br><span class="line">    <span class="keyword">let</span> firstNotEmptyIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (; firstNotEmptyIndex &lt; length &amp;&amp; str[firstNotEmptyIndex] === <span class="string">&#x27; &#x27;</span>; ++firstNotEmptyIndex) &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (!isSymbol(str[firstNotEmptyIndex]) &amp;&amp; !isNumber(str[firstNotEmptyIndex])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是符号，那么判断正负号</span></span><br><span class="line">    <span class="keyword">let</span> positive = <span class="literal">true</span>,</span><br><span class="line">        firstNumberIndex = firstNotEmptyIndex</span><br><span class="line">    <span class="keyword">if</span> (isSymbol(str[firstNotEmptyIndex])) &#123;</span><br><span class="line">        positive = str[firstNotEmptyIndex] === <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        firstNumberIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果符号后面跟的不是数字，那么就是非法的，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!isNumber(str[firstNumberIndex])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定连续数字字符的起始边界</span></span><br><span class="line">    <span class="keyword">let</span> endNumberIndex = firstNumberIndex</span><br><span class="line">    <span class="keyword">while</span> (endNumberIndex &lt; length &amp;&amp; isNumber(str[endNumberIndex + <span class="number">1</span>])) &#123;</span><br><span class="line">        ++endNumberIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数字字符的代表的数字大小</span></span><br><span class="line">    <span class="comment">// 并且判断是否越界</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = firstNumberIndex; i &lt;= endNumberIndex; ++i) &#123;</span><br><span class="line">        result = result * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (positive &amp;&amp; result &gt; MAX_INT) &#123;</span><br><span class="line">            <span class="keyword">return</span> MAX_INT</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!positive &amp;&amp; result &gt; MIN_INT_ABS) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> * MIN_INT_ABS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的时候注意符号</span></span><br><span class="line">    <span class="keyword">return</span> positive ? result : -<span class="number">1</span> * result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myAtoi(<span class="string">&#x27; +1.123sfsdfsd&#x27;</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(myAtoi(<span class="string">&#x27; -42&#x27;</span>)) <span class="comment">// -42</span></span><br><span class="line"><span class="built_in">console</span>.log(myAtoi(<span class="string">&#x27;words and 987&#x27;</span>)) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(myAtoi(<span class="string">&#x27;-91283472332&#x27;</span>)) <span class="comment">// -2147483648</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组最小的数字</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/02.cha-zhao/01.xuan-zhuan-shu-zu-zui-xiao-de-shu-zi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>最简单的肯定是从头到尾遍历，复杂度是 $O(N)$。<strong>这种方法没有利用“旋转数组”的特性</strong>。</p>
<p>借助二分查找的思想，时间复杂度可以降低到 $O(log(N))$。</p>
<p>可以通过以下方法确定最小值元素的位置，然后移动指针，缩小范围：</p>
<ul>
<li>  中间指针对应的元素 ≥ 左侧元素, 那么中间元素位于原递增数组中, 最小值在右侧</li>
<li>  中间指针对应的元素 ≤ 右侧元素, 那么中间元素位于被移动的递增数组中，最小值在左侧</li>
</ul>
<p>特殊情况，如果三者相等，那么无法判断最小值元素的位置，就退化为普通遍历即可。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>先上一段二分查找和实现思路：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">elem</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = arr.length - <span class="number">1</span>,</span><br><span class="line">        mid = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 注意是≤：考虑只剩1个元素的情况</span></span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] === elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elem &lt; arr[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>], <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>], -<span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(binarySearch([<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>借助二分查找的思想，写出本题代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在arr[left, right]中顺序查找最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderSearchMin</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> min = arr[left]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">        arr[i] &lt; min &amp;&amp; (min = arr[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在旋转数组arr中用二分法查找最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binSearchMin</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !arr.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;Empty Array&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = arr.length - <span class="number">1</span>,</span><br><span class="line">        mid = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right === <span class="number">1</span> + left) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[right]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] === arr[left] &amp;&amp; arr[mid] === arr[right]) &#123;</span><br><span class="line">            <span class="comment">// 无法判断最小值位置</span></span><br><span class="line">            <span class="keyword">return</span> orderSearchMin(arr, left, right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= arr[left]) &#123;</span><br><span class="line">            <span class="comment">// 最小值在右边</span></span><br><span class="line">            left = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= arr[right]) &#123;</span><br><span class="line">            <span class="comment">// 最小值在左边</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr[right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binSearchMin([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(binSearchMin([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(binSearchMin([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(binSearchMin([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数字在排序数组中出现的次数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/02.cha-zhao/02.shu-zi-zai-pai-xu-shu-zu-zhong-chu-xian-de-ci-shu/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="2-思路解析"><a href="#2-思路解析" class="headerlink" title="2. 思路解析"></a>2. 思路解析</h2><p>题目说是排序数组，所以可以使用“二分查找”的思想。</p>
<p>一种思路是查找到指定数字，然后向前向后遍历，复杂度是 O(N)。</p>
<p>另一种是不需要遍历所有的数字，只需要找到数字在数组中的左右边界即可，做差即可得到出现次数。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找指定数字的左 / 右边界</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>mode left | right 寻找左 | 右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findBoundary</span>(<span class="params">nums, target, mode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = nums.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (right + left) &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="string">&#x27;left&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// nums[mid] === target</span></span><br><span class="line">            <span class="comment">// 如果下标是0或者前一个元素不等于target</span></span><br><span class="line">            <span class="comment">// 那么mid就是左边界</span></span><br><span class="line">            <span class="keyword">if</span> (mid === <span class="number">0</span> || nums[mid - <span class="number">1</span>] !== target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，继续在左部分遍历</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="string">&#x27;right&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// nums[mid] === target</span></span><br><span class="line">            <span class="comment">// 如果下标是最后一位 或者 后一个元素不等于target</span></span><br><span class="line">            <span class="comment">// 那么mid就是右边界</span></span><br><span class="line">            <span class="keyword">if</span> (mid === nums.length - <span class="number">1</span> || nums[mid + <span class="number">1</span>] !== target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，继续在右部分遍历</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left === right</span></span><br><span class="line">    <span class="keyword">if</span> (nums[left] === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找指定数字的出现次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTotalTimes</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = nums.length</span><br><span class="line">    <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findBoundary(nums, target, <span class="string">&#x27;right&#x27;</span>) - findBoundary(nums, target, <span class="string">&#x27;left&#x27;</span>) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(getTotalTimes(nums, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/01.cong-wei-dao-tou-da-yin-lian-biao/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>可以从头到尾遍历一遍链表，将节点放入栈中，然后依次取出打印（后入先出）。</p>
<p>优化就是借助“递归”，先向下查找再打印输出，也可实现这种“后入先出”。可以类比二叉树的后序遍历。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>用 JS 实现了简单实现了链表这种数据结构，这不是重点。</p>
<p>重点在<code>printFromTailToHead</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">next</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从0开始计算，找到包括head在内的位于index的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向index位置插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">insert</span>(<span class="params">value, index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = <span class="built_in">this</span>.find(index)</span><br><span class="line">        <span class="keyword">const</span> next = <span class="keyword">new</span> Node(value, prev.next)</span><br><span class="line">        prev.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆序打印链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">node</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFromTailToHead</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next) &#123;</span><br><span class="line">        printFromTailToHead(node.next)</span><br><span class="line">    &#125;</span><br><span class="line">    node.value &amp;&amp; <span class="built_in">console</span>.log(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> List()</span><br><span class="line">list.insert(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">list.insert(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">list.insert(<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">printFromTailToHead(list.head)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速删除链表节点</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/02.kuai-su-shan-chu-lian-biao-jie-dian/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>给定单向链表的头指针和一个结点指针，定义一个函数在 $O(1)$ 时间删除该结点。</p>
<h2 id="2-思路描述"><a href="#2-思路描述" class="headerlink" title="2. 思路描述"></a>2. 思路描述</h2><p>正常的做法肯定是在 $O(N)$ 时间内删除节点。而这么过分的要求，显然是通过“重新赋值”才能做到。</p>
<p>比如要删除节点 a，那么就将 a.next 的 value 和 next 赋值给节点 a，然后删除 a.next。</p>
<p>表面“看起来”像是删除了节点 a，其实是将其后节点的信息转移到了它自己身上。</p>
<p>除此之外，对于最后一个节点，还是要退化成 $O(N)$ 的复杂度。而整体分析一下复杂度：</p>
<p>$$<br>O(T) = (O(N) + O(1) * (n - 1)) / n = O(1)<br>$$</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">next</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">toDelete</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteNode</span>(<span class="params">head, toDelete</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head === toDelete || !toDelete || !head) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextNode = toDelete.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextNode) &#123;</span><br><span class="line">        <span class="comment">// 尾节点</span></span><br><span class="line">        <span class="keyword">let</span> node = head</span><br><span class="line">        <span class="keyword">while</span> (node.next !== toDelete) &#123;</span><br><span class="line">            node = node.next</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = <span class="literal">null</span></span><br><span class="line">        toDelete = <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        toDelete.value = nextNode.value</span><br><span class="line">        toDelete.next = nextNode.next</span><br><span class="line">        nextNode = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>),</span><br><span class="line">    node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, node3),</span><br><span class="line">    node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, node2),</span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="literal">null</span>, node1)</span><br><span class="line"></span><br><span class="line">deleteNode(head, node2)</span><br><span class="line"><span class="keyword">let</span> node = head.next</span><br><span class="line"><span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    node = node.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表倒数第k节点</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/03.lian-biao-dao-shu-di-k-jie-dian/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个单链表，输出该链表中倒数第 k 个结点。</p>
<h2 id="2-思路描述"><a href="#2-思路描述" class="headerlink" title="2. 思路描述"></a>2. 思路描述</h2><p><strong>思路一</strong>：从头到尾遍历一遍，统计长度<code>length</code>。再从头遍历，直到<code>length - k</code>个节点停止，这就是倒数第 k 个节点。</p>
<p><strong>思路二</strong>：只需要遍历一遍。准备 2 个指针<code>a</code>和<code>b</code>均指向第一个节点，<code>a</code>先移动<code>k</code>个位置；然后<code>a</code>和<code>b</code>一起向后移动，此时两个只指针的位置差为<code>k</code>；直到<code>a</code>移动到尾结点停止，此时<code>b</code>指向的节点就是倒数第 k 个节点。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>下面是“思路二”的实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找倒数第k个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> </span>head 初始节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>k 顺序(倒数)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthFromTail</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = head,</span><br><span class="line">        b = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        a = a.next</span><br><span class="line">        <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        b = b.next</span><br><span class="line">        a = a.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码, 分别输出倒数第2、3和5个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>),</span><br><span class="line">    node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, node3),</span><br><span class="line">    node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, node2),</span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="number">0</span>, node1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(findKthFromTail(head, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/04.fan-zhuan-lian-biao/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<h2 id="2-思路描述"><a href="#2-思路描述" class="headerlink" title="2. 思路描述"></a>2. 思路描述</h2><p><strong>思路一</strong>：经典的“链表头插法”，时间复杂度是 $O(N)$，但是空间复杂度也是 $O(N)$</p>
<p><strong>思路二</strong>：链表原地操作，时间复杂度是 $O(N)$，但是空间复杂度只有 $O(1)$。</p>
<ol>
<li>保存当前节点<code>node</code>的上一个节点<code>pre</code></li>
<li>节点<code>node</code>的<code>next</code>指向<code>pre</code></li>
<li>分别将<code>pre</code>和<code>node</code>向后移动 1 个位置</li>
</ol>
<ul>
<li>  如果<code>node</code>为 null，链表翻转完毕，此时<code>pre</code>指向新的头节点，返回即可</li>
<li>  否则，回到第 1 步继续执行</li>
</ul>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> </span>head 未翻转链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Node&#125;</span> </span>翻转链表后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = head,</span><br><span class="line">        pre = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">let</span> next = node.next</span><br><span class="line"></span><br><span class="line">        node.next = pre</span><br><span class="line"></span><br><span class="line">        pre = node</span><br><span class="line">        node = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码, 分别输出倒数第2、3和5个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>),</span><br><span class="line">    node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, node3),</span><br><span class="line">    node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, node2),</span><br><span class="line">    head = <span class="keyword">new</span> Node(<span class="number">0</span>, node1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newHead = reverseList(head)</span><br><span class="line"><span class="keyword">while</span> (newHead) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newHead)</span><br><span class="line">    newHead = newHead.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/05.he-bing-liang-ge-you-xu-lian-biao/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>准备一个指针<code>node</code>，假设指向两个链表的中节点的指针分别是：<code>p1</code>和<code>p2</code>。</p>
<ol>
<li>比较<code>p1</code>和<code>p2</code>的<code>value</code>大小</li>
</ol>
<ul>
<li>  如果，p1.value 小于 p2.value, node.next 指向 p1, p1 向后移动</li>
<li>  否则，node.next 指向 p2, p2 向后移动</li>
</ul>
<ol start="2">
<li>重复第 1 步，直到其中一个链表遍历完</li>
<li>跳出循环，将 node.next 指向未遍历完的链表的剩余部分</li>
</ol>
<p>整个过程的时间复杂度是 O(N), 空间复杂度是 O(1)</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value = <span class="literal">null</span>, next = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并2个有序单链表成为1个新的有序单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">        <span class="keyword">return</span> p2</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head = <span class="keyword">new</span> Node(),</span><br><span class="line">        node = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.value &lt; p2.value) &#123;</span><br><span class="line">            node.next = p1</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = p2</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">        node.next = p2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!p2) &#123;</span><br><span class="line">        node.next = p1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="keyword">new</span> Node(<span class="number">7</span>, <span class="literal">null</span>))))</span><br><span class="line"><span class="keyword">let</span> list2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="keyword">new</span> Node(<span class="number">6</span>, <span class="keyword">new</span> Node(<span class="number">8</span>, <span class="literal">null</span>))))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> head = merge(list1, list2)</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(head.value)</span><br><span class="line">    head = head.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/06.fu-za-lian-biao-de-fu-zhi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>请实现函数<code>ComplexListNode *Clone（ComplexListNode* pHead）</code>，复制一个复杂链表。在复杂链表中，每个结点除了有一个 next 指针指向下一个结点外，还有一个 sibling 指向链表中的任意结点或者 NULL。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>按照正常的思路，首先从头到尾遍历链表，拷贝每个节点的 value 和 next 指针。然后从头再次遍历，第二次遍历的目的在于拷贝每个节点的 sibling 指针。</p>
<p>然而即使找到原节点的 sibling 指针，还是得为了找到复制节点对应的 sibling 指针而再遍历一遍。那么对于 n 个要寻找 sibling 指针的节点，复杂度就是 O(N*N)。</p>
<p>显然，为了降低复杂度，必须从第二次遍历着手。这里采用的方法是，在第一次遍历的时候，把 <code>(原节点, 复制节点)</code> 作为映射保存在表中。那么第二次遍历的时候，就能在 O(1) 的复杂度下立即找到原链上 sibling 指针在复制链上对应的映射。</p>
<h2 id="3-代码分析"><a href="#3-代码分析" class="headerlink" title="3. 代码分析"></a>3. 代码分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next = <span class="literal">null</span>, sibling = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">        <span class="built_in">this</span>.sibling = sibling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制复杂链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">first</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneNodes</span>(<span class="params">first</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> copyFirst = <span class="keyword">new</span> Node(first.value),</span><br><span class="line">        node = first.next, <span class="comment">// 被copy链的当前节点</span></span><br><span class="line">        last = copyFirst <span class="comment">// copy链的当前节点, 此节点相对于被copy链短位移少1位</span></span><br><span class="line"></span><br><span class="line">    map.set(first, copyFirst)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        last.next = <span class="keyword">new</span> Node(node.value)</span><br><span class="line">        last = last.next</span><br><span class="line">        map.set(node, last)</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次遍历, 迁移sibling</span></span><br><span class="line">    node = first</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        map.get(node) &amp;&amp; (map.get(node).sibling = map.get(node.sibling))</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copyFirst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> Node(<span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">    node2 = <span class="keyword">new</span> Node(<span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">    node3 = <span class="keyword">new</span> Node(<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">    node4 = <span class="keyword">new</span> Node(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">node1.next = node2</span><br><span class="line">node2.next = node3</span><br><span class="line">node3.next = node4</span><br><span class="line"></span><br><span class="line">node1.sibling = node3</span><br><span class="line">node4.sibling = node2</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> copyNode = cloneNodes(node1)</span><br><span class="line"><span class="keyword">while</span> (copyNode) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(copyNode)</span><br><span class="line">    copyNode = copyNode.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表中的第一个公共节点</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/03.lian-biao/07.liang-ge-lian-biao-zhong-de-di-yi-ge-gong-gong-jie-dian/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><h3 id="2-1-思路一：栈实现"><a href="#2-1-思路一：栈实现" class="headerlink" title="2.1 思路一：栈实现"></a>2.1 思路一：栈实现</h3><p>在第一个公共节点前的节点都是不相同的，因此只要倒序遍历两个链表，找出最后一个出现的相同节点即可。</p>
<p>因为链表不能倒序遍历，所以借助栈实现。</p>
<h3 id="2-2-思路二：快慢指针"><a href="#2-2-思路二：快慢指针" class="headerlink" title="2.2 思路二：快慢指针"></a>2.2 思路二：快慢指针</h3><p>假设链表 A 长度大于链表 B 长度，它们的长度差为 diff。</p>
<p>让 A 的指针先移动 diff 的位移，然后 A 和 B 的指针再同时向后移动，每次比较节点，选出第一个出现的相同节点。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>为了方便，先简单实现节点数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, next</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.next = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-思路一：栈实现"><a href="#3-1-思路一：栈实现" class="headerlink" title="3.1 思路一：栈实现"></a>3.1 思路一：栈实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路一：利用栈实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack1 = [],</span><br><span class="line">        stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = list1</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        stack1.push(node)</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = list2</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        stack2.push(node)</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (stack1.length &amp;&amp; stack2.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> top1 = stack1.pop(),</span><br><span class="line">            top2 = stack2.pop()</span><br><span class="line">        <span class="keyword">if</span> (top1 === top2) &#123;</span><br><span class="line">            node = top1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-思路二：快慢指针"><a href="#3-2-思路二：快慢指针" class="headerlink" title="3.2 思路二：快慢指针"></a>3.2 思路二：快慢指针</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路二：快慢指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">list1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">list2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length1 = <span class="number">0</span>,</span><br><span class="line">        length2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = list1</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        ++length1</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node = list2</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        ++length2</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> diff = <span class="built_in">Math</span>.abs(length1 - length2),</span><br><span class="line">        longList = <span class="literal">null</span>,</span><br><span class="line">        shortList = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (length1 &gt; length2) &#123;</span><br><span class="line">        longList = list1</span><br><span class="line">        shortList = list2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        longList = list2</span><br><span class="line">        shortList = list1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        longList = longList.next</span><br><span class="line">        --diff</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (longList &amp;&amp; shortList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longList === shortList) &#123;</span><br><span class="line">            <span class="keyword">return</span> longList</span><br><span class="line">        &#125;</span><br><span class="line">        longList = longList.next</span><br><span class="line">        shortList = shortList.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-测试代码"><a href="#3-3-测试代码" class="headerlink" title="3.3 测试代码"></a>3.3 测试代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node4th = <span class="keyword">new</span> Node(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> node3th = <span class="keyword">new</span> Node(<span class="number">3</span>, node4th)</span><br><span class="line"><span class="keyword">const</span> list1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">new</span> Node(<span class="number">3</span>, node3th)))</span><br><span class="line"><span class="keyword">const</span> list2 = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="keyword">new</span> Node(<span class="number">6</span>, node3th))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(method2(list1, list2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/04.shu-zu/01.er-wei-shu-zu-zhong-de-cha-zhao/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>时间复杂度是 $O(N)$，空间复杂度是$O(1)$</p>
<p><strong>利用数组的排序性质</strong>：如果要查找的元素小于当前元素，那么一定不在当前元素左边的列；如果要查找的元素大于当前元素，那么一定在当前元素下面的行。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目答案</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">elem</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findElem</span>(<span class="params">arr, elem</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> row = arr.length - <span class="number">1</span>,</span><br><span class="line">        col = arr[<span class="number">0</span>].length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = col</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= row &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] === elem) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elem &gt; arr[i][j]) &#123;</span><br><span class="line">            ++i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findElem(arr, <span class="number">8</span>))</span><br><span class="line"><span class="built_in">console</span>.log(findElem(arr, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(findElem(arr, <span class="number">145</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组顺序调整</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/04.shu-zu/02.shu-zu-shun-xu-diao-zheng/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h2 id="2-思路描述"><a href="#2-思路描述" class="headerlink" title="2. 思路描述"></a>2. 思路描述</h2><p>这题进一步抽象就是满足一定条件的元素都移动到数组的前面，不满足的移动到后面。所以，需要有一个参数用来传递<strong>判断函数</strong>。</p>
<p>最优解法就是数组两头分别有一个指针，然后向中间靠拢。符合条件，就一直向中间移动；不符合条件，就停下来指针，交换两个元素；然后继续移动，直到两个指针相遇。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>函数<code>change</code>运用了设计模式中的“<a href="https://godbmw.com/passages/2019-01-19-bridge-pattern/">桥接模式</a>”，判断条件由用户自己定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">i</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">j</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> ([arr[i], arr[j]] = [arr[j], arr[i]])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将符合compareFn要求的数据排在前半部分，不符合要求的排在后半部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">brr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> <span class="variable">compareFn</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">brr, compareFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [...brr],</span><br><span class="line">        length = brr.length</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length &amp;&amp; compareFn(arr[i])) ++i</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; !compareFn(arr[j])) --j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(arr, i, j)</span><br><span class="line">            ++i</span><br><span class="line">            --j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isOdd = <span class="function">(<span class="params">num</span>) =&gt;</span> (num &amp; <span class="number">1</span>) === <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(change([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], isOdd))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/04.shu-zu/03.ba-shu-zu-pai-cheng-zui-xiao-de-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>因为涉及拼接，所以可以将其看做字符串，同时规避了大数溢出的问题，而且字符串的比较规则和数字相同。</p>
<p>借助自定义排序，可以快速比较两个数的大小。比如只看{3, 32}这两个数字。它们可以拼接成 332 和 323，按照题目要求，这里应该取 323。也就是说，此处自定义函数应该返回-1。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMinNumber</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    numbers.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s1 = x + <span class="string">&#x27;&#x27;</span> + y,</span><br><span class="line">            s2 = y + <span class="string">&#x27;&#x27;</span> + x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1 &lt; s2) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (s1 &gt; s2) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(numbers.join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">printMinNumber([<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/04.shu-zu/04.shu-zu-zhong-de-ni-xu-dui/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个数组,求出这个数组中的逆序对的总数。</p>
<p>例如在数组{7，5，6，4}中，一共存在 5 个逆序对，分别是(7,6), (7, 5), (7,4), (6,4), (5,4)。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>暴力法的时间复杂度是 O(N^2)。利用归并排序的思路，可以将时间复杂度降低到 O(NlogN)。</p>
<p>比如对于 7、5、6、4 来说，会被分成 5、7 和 4、6 两组。</p>
<p>准备两个指针指向两组最后元素，当左边数组指针的对应元素小于右边指针对应元素，结果可以加上从左指针到右指针之间的元素个数（都是逆序的）。</p>
<p>依次移动指针，直到达到边界。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>代码最后输出了数组，经过归并，数组已经是有序的了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">start</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">end</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findInversePairNum</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start === end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> copy = <span class="keyword">new</span> <span class="built_in">Array</span>(end - start + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> length = (end - start) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> leftNum = findInversePairNum(arr, start, start + length)</span><br><span class="line">    <span class="keyword">const</span> rightNum = findInversePairNum(arr, start + length + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = start + length, <span class="comment">// 左子数组的最后一个下标</span></span><br><span class="line">        j = end, <span class="comment">// 右子数组的最后一个下标</span></span><br><span class="line">        count = leftNum + rightNum,</span><br><span class="line">        copyIndex = end - start <span class="comment">// copy数组中的最后一个下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以参考数据集合：[2, 3, 1, 4]</span></span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= start &amp;&amp; j &gt;= start + length + <span class="number">1</span>; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">            copy[copyIndex--] = arr[i--]</span><br><span class="line">            count += j - start - length</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            copy[copyIndex--] = arr[j--]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= start; --i) &#123;</span><br><span class="line">        copy[copyIndex--] = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= start + length + <span class="number">1</span>; --j) &#123;</span><br><span class="line">        copy[copyIndex--] = arr[j]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序号的数据放到原数组中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end - start + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        arr[i + start] = copy[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear</span></span><br><span class="line">    copy.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(findInversePairNum(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)) <span class="comment">// output: 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// output: [4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/05.zhan-he-dui-lie/01.yong-liang-ge-zhan-shi-xian-dui-lie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>用两个栈实现一个队列。队列的声明如下:</p>
<p>请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>一个栈用来存储插入队列数据，一个栈用来从队列中取出数据。</p>
<p>从第一个栈向第二个栈转移数据的过程中：数据的性质已经从后入先出变成了先入先出。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack1 = []</span><br><span class="line">        <span class="built_in">this</span>.stack2 = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">appendTail</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 新插入队列的数据都放在 stack1</span></span><br><span class="line">        <span class="built_in">this</span>.stack1.splice(<span class="number">0</span>, <span class="number">0</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">deleteHead</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 将要取出的值都从stack2中取</span></span><br><span class="line">        <span class="comment">// 如果stack2为空，那么将 stack1 中的元素都转移过来</span></span><br><span class="line">        <span class="comment">// 此时，stack2中的元素顺序已经被改变了，满足队列的条件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stack2.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> length = <span class="built_in">this</span>.stack1.length</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stack2.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.stack1.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stack2.length === <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>.stack2.shift()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">queue.appendTail(<span class="number">1</span>)</span><br><span class="line">queue.appendTail(<span class="number">2</span>)</span><br><span class="line">queue.appendTail(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.deleteHead())</span><br><span class="line">queue.appendTail(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.deleteHead())</span><br><span class="line"><span class="built_in">console</span>.log(queue.deleteHead())</span><br><span class="line"><span class="built_in">console</span>.log(queue.deleteHead())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/05.zhan-he-dui-lie/02.bao-han-min-han-shu-de-zhan/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是 O（1）。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>有关栈的题目，可以考虑使用“辅助栈”，即利用空间换时间的方法。</p>
<p>这道题就是借助“辅助栈”来实现。当有新元素被 push 进普通栈的时候，<strong>程序比较新元素和辅助栈中的原有元素，选出最小的元素，将其放入辅助栈</strong>。</p>
<p>根据栈的特点和操作思路，辅助栈顶的元素就是最小元素。并且辅助栈的元素和普通栈的元素是“一一对应”的。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包含Min函数的栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = [] <span class="comment">// 数据栈</span></span><br><span class="line">        <span class="built_in">this</span>.minStack = [] <span class="comment">// 辅助栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">push</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> minLength = <span class="built_in">this</span>.minStack.length</span><br><span class="line">        <span class="built_in">this</span>.stack.push(item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minLength === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始情况: 直接放入</span></span><br><span class="line">            <span class="built_in">this</span>.minStack.push(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item &lt; <span class="built_in">this</span>.minStack[minLength - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 新元素 ＜ 辅助栈的最小元素: 将新元素放入</span></span><br><span class="line">                <span class="built_in">this</span>.minStack.push(item)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则,为了保持2个栈的对应关系，放入辅助栈最小元素</span></span><br><span class="line">                <span class="built_in">this</span>.minStack.push(<span class="built_in">this</span>.minStack[minLength - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stack.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.minStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">min</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> minLength = <span class="built_in">this</span>.minStack.length</span><br><span class="line">        <span class="keyword">if</span> (minLength === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.minStack[minLength - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minStack = <span class="keyword">new</span> MinStack()</span><br><span class="line"></span><br><span class="line">minStack.push(<span class="number">3</span>)</span><br><span class="line">minStack.push(<span class="number">4</span>)</span><br><span class="line">minStack.push(<span class="number">2</span>)</span><br><span class="line">minStack.push(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(minStack.minStack, minStack.min()) <span class="comment">// output: [ 3, 3, 2, 1 ] 1</span></span><br><span class="line"></span><br><span class="line">minStack.pop()</span><br><span class="line">minStack.pop()</span><br><span class="line">minStack.push(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(minStack.minStack, minStack.min()) <span class="comment">// output: [ 3, 3, 0 ] 0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入弹出序列</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/05.zhan-he-dui-lie/03.zhan-de-ya-ru-dan-chu-xu-lie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列 1、2、3、4、5 是某栈的压栈序列，序列 4、5、3、2、1 是该压栈序列对应的一个弹出序列，但 4、3、5、1、2 就不可能是该压栈序列的弹出序列。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>栈的题目还是借助“辅助栈”。大体思路如下：</p>
<ol>
<li>将入栈序列的元素依次入辅助栈</li>
<li>检查辅助栈顶元素和弹栈序列栈顶元素是否一致：</li>
</ol>
<ul>
<li>  元素一致，弹出辅助栈元素，弹栈序列指针后移</li>
<li>  不一致，回到第一步</li>
</ul>
<p>需要注意的是，过程中的边界条件检查（多试试几种情况）。除此之外，由于 js 不提供指针运算，所以用标记下标的方法代替指针。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">stack</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStackTop</span>(<span class="params">stack</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(stack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stack.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二个参数是否是该栈的弹出顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">pushOrder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">popOrder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">pushOrder, popOrder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pushOrder.length || !popOrder.length || pushOrder.length !== popOrder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stack = [] <span class="comment">// 辅助栈</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span> <span class="comment">// i: 压入序列指针; j: 弹出序列指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; popOrder.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; pushOrder.length &amp;&amp; popOrder[j] !== getStackTop(stack); ++i) &#123;</span><br><span class="line">            stack.push(pushOrder[i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (popOrder[j] !== getStackTop(stack)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.pop()</span><br><span class="line">        ++j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(check([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(check([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(check([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/01.qing-wa-tiao-tai-jie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>跳到 n 阶假设有 f(n)种方法。</p>
<p>往前倒退，如果青蛙最后一次是跳了 2 阶，那么之前有 f(n-2)种跳法; 如果最后一次跳了 1 阶，那么之前有 f(n-1)种跳法。</p>
<p>所以：f(n) = f(n-1) + f(n-2)。就是斐波那契数列。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>这里利用缓存模式（又称备忘录模式）实现了代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mem = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    mem.set(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    mem.set(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _fibonacci = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unvalid param&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem.has(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> mem.get(n)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mem.set(n, _fibonacci(n - <span class="number">1</span>) + _fibonacci(n - <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> mem.get(n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _fibonacci</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),</span><br><span class="line">    end = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">fibonacci(<span class="number">8000</span>)</span><br><span class="line">end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`耗时为<span class="subst">$&#123;end - start&#125;</span>ms`</span>)</span><br><span class="line"></span><br><span class="line">start = end</span><br><span class="line">fibonacci(<span class="number">8000</span>)</span><br><span class="line">end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`耗时为<span class="subst">$&#123;end - start&#125;</span>ms`</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整次方</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/02.shu-zhi-de-zheng-ci-fang/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>题目：实现函数 double Power（double base, intexponent），求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p><strong>简单思路</strong>：最简单的做法是循环，但是要考虑异常值的检验。比如指数是负数，底数为 0。</p>
<p><strong>优化思路</strong>：书上提供了一种复杂度为 $O(logN)$ 的做法。比如我们要求 32 次方，那么只要求出 16 次方再平方即可。依次类推，是递归函数的结构。</p>
<p>递推公式如下：</p>
<p>$$<br>a^n=\left{<br>\begin{aligned}<br>a^{n/2}*a^{n/2} ; n为偶数\<br>a^{(n - 1)/2}*a^{(n - 1)/2} ; n为奇数<br>\end{aligned}<br>\right.<br>$$</p>
<p>需要注意的是，如果幂是奇数，例如 5 次方，可以先计算 2 次方，结果平方后（4 次方），再乘以自身（5 次方）。按照此思路处理。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">base</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">exp</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">base, exp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规定0的任何次方均为0</span></span><br><span class="line">    <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>,</span><br><span class="line">        absExp = <span class="built_in">Math</span>.abs(exp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; absExp; ++i) &#123;</span><br><span class="line">        result *= base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于指数小于0的情况，求其倒数</span></span><br><span class="line">    <span class="keyword">if</span> (exp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = <span class="number">1</span> / result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, -<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">0</span>, -<span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>在 Js 中整数除 2 不会自动取整，可以使用<code>Math.floor()</code>。但更好的做法是使用<code>&gt;&gt;</code>位运算。</p>
<p>判断奇数可以用<code>%2</code>判断。但更好的做法是和<code>1</code>进行<code>&amp;</code>运算后（除了最后 1 位，都被置 0 了），判断是不是 1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求base 的 exp次幂，其中exp永远是正数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">base</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">exp</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsignedPow</span>(<span class="params">base, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exp === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exp === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = pow(base, exp &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    result *= result</span><br><span class="line">    <span class="keyword">if</span> (exp &amp; (<span class="number">1</span> === <span class="number">1</span>)) &#123;</span><br><span class="line">        result *= base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求 base的exp次幂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">base</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">exp</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">base, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> absExp = <span class="built_in">Math</span>.abs(exp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exp &lt; <span class="number">0</span> ? <span class="number">1</span> / unsignedPow(base, absExp) : unsignedPow(base, absExp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">0</span>, -<span class="number">9</span>))</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, -<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>打印从1到最大的n位数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/03.da-yin-cong-1-dao-zui-da-de-n-wei-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>题目：输入数字 n，按顺序打印出从 1 最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>主要的坑点在：大数的溢出。当然，es6 提供了<code>BigInt</code>数据类型，可以直接相加不用担心溢出。</p>
<p>除此之外，这题显然是要我们模拟“大数相加”：将最低位加 1，然后每次检查是否进位，如果不进位，直接退出循环；如果进位，需要保留进上来的 1，然后加到下一位，直到不进位或者超出了我们规定的范围。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>js 中不方便操作字符串中指定位置的字符，因此用数组对象来模拟。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组模拟大数相加操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Boolean&#125;</span> </span>true, 超出arr.length位最大整数; false, 没有超出arr.length位最大整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        over = <span class="number">0</span> <span class="comment">// 记录前一位相加后的进位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        arr[i] = arr[i] + over</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i === length - <span class="number">1</span>) &#123;</span><br><span class="line">            arr[i] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第n位进位，说明超出了n位最大数字</span></span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[i] = arr[i] - <span class="number">10</span></span><br><span class="line">            over = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMaxDigits</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (!increase(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">printMaxDigits(<span class="number">2</span>)</span><br><span class="line">printMaxDigits(<span class="number">3</span>)</span><br><span class="line">printMaxDigits(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/04.shun-shi-zhen-da-yin-ju-zhen/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>既然是顺时针打印，其实就是<strong>由外向内一圈圈打印</strong>，将过程分为 2 步：</p>
<p>第一步：<code>printMatrix</code>函数，确定要打印的圈的左上角坐标（比较简单）</p>
<p>第二步：<code>printMatrixInCircle</code>函数，根据左上角坐标，顺时针打印这一圈的信息。这个过程又分为四步：左上 -&gt; 右上 -&gt; 右下 -&gt; 左下 -&gt; 左上。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>如果觉得，函数<code>printMatrixInCircle</code>的条件判断不清楚，可以配合下面这张图一起看：</p>
<p><img src="https://i.loli.net/2019/06/09/5cfcfe24760b637950.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印从 (start, start) 与 (endX, endY) 围成的一圈矩形</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">cols</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">rows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">start</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMatrixInCircle</span>(<span class="params">arr, cols, rows, start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> endX = cols - start - <span class="number">1</span>,</span><br><span class="line">        endY = rows - start - <span class="number">1</span>,</span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 左上 到 右上 打印一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= endX; ++i) &#123;</span><br><span class="line">        result = result + <span class="string">&#x27; &#x27;</span> + arr[start][i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 右上 到 右下 打印一行</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endY) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start + <span class="number">1</span>; i &lt;= endY; ++i) &#123;</span><br><span class="line">            result = result + <span class="string">&#x27; &#x27;</span> + arr[i][endX]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 右下 到 左下 打印一行</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = endX - <span class="number">1</span>; i &gt;= start; --i) &#123;</span><br><span class="line">            result = result + <span class="string">&#x27; &#x27;</span> + arr[endY][i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 左下 到 左上 打印一行</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            result = result + <span class="string">&#x27; &#x27;</span> + arr[i][start]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印的外层函数, 主要用于控制要打印的圈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMatrix</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr) || !<span class="built_in">Array</span>.isArray(arr[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        cols = arr[<span class="number">0</span>].length,</span><br><span class="line">        rows = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cols &gt; start * <span class="number">2</span> &amp;&amp; rows &gt; start * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123;start + <span class="number">1</span>&#125;</span>层: `</span>)</span><br><span class="line">        printMatrixInCircle(arr, cols, rows, start)</span><br><span class="line">        ++start</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">printMatrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">printMatrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/05.shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组{1,2,3,2,2,2,5,4,2}。</p>
<p>由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>数组中有一个数字出现的次数超过数组长度的一半，<strong>说明它出现的次数比其他所有数字出现次数的和还要多</strong>。</p>
<p>在遍历的过程中保存两个变量：一个数字 + 一个次数。遍历到每个元素都会更新次数，元素 = 数字，加次数；否则，减次数；如果次数为 0，当前元素赋值给数字。</p>
<p>需要注意的是，最后结果不一定符合条件，比如数组 <code>[1, 2, 3]</code>，结果是 3。所以要再统计一下最后数字的次数，是否有一半那么多。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查指定元素的次数是否大于等于长度一半</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMoreThanHalf</span>(<span class="params">nums = [], target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span></span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> num === target &amp;&amp; ++times)</span><br><span class="line">    <span class="keyword">return</span> times * <span class="number">2</span> &gt;= nums.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moreThanHalfNum</span>(<span class="params">nums = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(nums) || !nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">1</span>,</span><br><span class="line">        result = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times === <span class="number">0</span>) &#123;</span><br><span class="line">            times = <span class="number">1</span></span><br><span class="line">            result = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result === nums[i]) &#123;</span><br><span class="line">            ++times</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --times</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checkMoreThanHalf(nums, result) ? result : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moreThanHalfNum([<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>])) <span class="comment">// output: null</span></span><br><span class="line"><span class="built_in">console</span>.log(moreThanHalfNum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>])) <span class="comment">// output: 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/06.zui-xiao-de-k-ge-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入 n 个整数，找出其中最小的 k 个数。例如输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>利用“快速排序”的中的 partition 操作：返回 index，小于 index 对应元素的元素都放在了左边，大于 index 对应元素的元素都放在右边。</p>
<p>利用这个特性，只要我们的 partition 返回值是 k - 1，那么数组中前 k 个元素已经被摆放到了正确位置，直接遍历输出即可。</p>
<p>由于不需要排序全部，整体的时间复杂度是 O(N)。但美中不足的是：要在原数组操作，除非用 O(N)的空间来做拷贝。除此之外，针对海量动态增加的数据，也不能很好处理。这种情况需要用到“最大堆”，请前往《堆》章节查看。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partiton</span>(<span class="params">arr = [], start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> v = arr[start],</span><br><span class="line">        left = start + <span class="number">1</span>,</span><br><span class="line">        right = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= end &amp;&amp; arr[left] &lt;= v) ++left</span><br><span class="line">        <span class="keyword">while</span> (right &gt;= start + <span class="number">1</span> &amp;&amp; arr[right] &gt;= v) --right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ;[arr[left], arr[right]] = [arr[right], arr[left]]</span><br><span class="line">        ++left</span><br><span class="line">        --right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;[arr[right], arr[start]] = [arr[start], arr[right]]</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKthNumbers</span>(<span class="params">nums = [], k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = nums.length</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(k)</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        end = length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> index = partiton(nums, start, end)</span><br><span class="line">    <span class="keyword">while</span> (index !== k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 前k个元素在 [start, index] 下标范围内</span></span><br><span class="line">            <span class="comment">// 要进一步处理，缩小区间</span></span><br><span class="line">            end = index - <span class="number">1</span></span><br><span class="line">            index = partiton(nums, start, end)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// [start, index]都属于小于k的元素，但不是全部</span></span><br><span class="line">            <span class="comment">// 剩下要处理的区间是 [index + 1, end]</span></span><br><span class="line">            start = index + <span class="number">1</span></span><br><span class="line">            index = partiton(nums, start, end)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        result[i] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getKthNumbers([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>], <span class="number">4</span>)) <span class="comment">// output: [2, 3, 1, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(getKthNumbers([<span class="number">10</span>, <span class="number">2</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的两个数字</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/07.he-wei-s-de-liang-ge-shu-zi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，输出任意一对即可。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>如果这个数组不是递增的，就得用哈希表来解决，空间复杂度是 O(N)。</p>
<p>但是题目条件是“递增数组”，因此可以使用“双指针”的思路来实现：即一个指针指向开头，另一个指向结尾。</p>
<p>比较指针对应的 2 个元素的和与给定数组 s：</p>
<ul>
<li>  元素和 &gt; s: 后指针向前移动</li>
<li>  元素和 &lt; s: 前指针向后移动</li>
<li>  元素和 = s: 返回指针对应的 2 个元素</li>
</ul>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">sum</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findNumsWithSum</span>(<span class="params">data, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(data) || data.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">        j = data.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">let</span> now = data[i] + data[j]</span><br><span class="line">        <span class="keyword">if</span> (now === sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> [data[i], data[j]]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; sum) &#123;</span><br><span class="line">            --j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：[ 4, 11 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(findNumsWithSum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">15</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/08.he-wei-s-de-lian-xu-zheng-shu-xu-lie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个正数 s，打印出所有和为 s 的连续正数序列（至少含有两个数）。例如输入 15，由于 1 ＋ 2 ＋ 3 ＋ 4 ＋ 5 ＝ 4 ＋ 5 ＋ 6 ＝ 7 ＋ 8 ＝ 15，所以结果打印出 3 个连续序列 1 ～ 5、4 ～ 6 和 7 ～ 8。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>和前面题目很相似，这里也是“双指针”的思路。不同的地方有 2 个点：</p>
<ul>
<li>  指针是从第 0 个和第 1 个位置开始的（下面称为 a 和 b）</li>
<li>  这里要计算指针范围内的所有元素和（题目要求是“连续序列”）</li>
</ul>
<p>每次移动 a、b 之前，都要计算一下当前<code>[a,b]</code>范围内的所有元素和。如果等于 s，打印并且 b 右移；如果小于 s，b 右移；如果大于 s，a 右移。</p>
<p>至于为什么相等的时候 b 右移而不是 a 右移？因为 a 右移会漏掉情况，而且指针可能重叠。比如对于数组 <code>[1, 2, 2]</code>，给定 s 是 3。</p>
<h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印指定数组的起始下标内的所有元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>data 打印数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>seq [start, end] 数组打印元素的起始下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">data, seq</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [start, end] = seq</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">        process.stdout.write(data[i] + <span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    process.stdout.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印出递增数组中，所有和为s的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>data 递增数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>sum 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSequenceWithSum</span>(<span class="params">data, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> small = <span class="number">0</span>,</span><br><span class="line">        big = <span class="number">1</span>,</span><br><span class="line">        cur = data[small] + data[big]</span><br><span class="line">    <span class="keyword">const</span> middle = (data.length + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (small &lt; middle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= sum) &#123;</span><br><span class="line">            cur === sum &amp;&amp; print(data, [small, big])</span><br><span class="line">            ++big</span><br><span class="line">            cur += data[big]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur -= data[small]</span><br><span class="line">            ++small</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2, 3, 4,</span></span><br><span class="line"><span class="comment">// 4, 5,</span></span><br><span class="line">findSequenceWithSum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>n个骰子的点数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/09.n-ge-tou-zi-de-dian-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>递归的思路就是组合出所有情况，然后每种情况记录出现次数，最后除以 6^n 即可。其中，6^n 就是所有情况的总数。</p>
<p>书中提出的方法是<strong>使用循环来优化递归</strong>，递归是自顶向下，循环是自底向上，思考起来有难度。</p>
<p>技巧性很强，准备 2 个数组，假想每次投掷一个骰子，出现和为 n 的次数，就是之前骰子和为 n-1, n-2, …, n-6 的次数和。依次类推，每次存储结果都和之前的数组不同。</p>
<h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h2><p>注释中都有详细说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gMaxValue = <span class="number">6</span> <span class="comment">// 每个骰子的最大点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>number 骰子的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printProbability</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> probabilities = [<span class="keyword">new</span> <span class="built_in">Array</span>(gMaxValue * number + <span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">Array</span>(gMaxValue * number + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gMaxValue * number + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        probabilities[<span class="number">0</span>][i] = probabilities[<span class="number">1</span>][i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次掷骰子，出现的和只有有 gMaxValue 种情况，每种和的次数为 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= gMaxValue; ++i) &#123;</span><br><span class="line">        probabilities[flag][i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后是从第 2 ~ number 次掷骰子</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">2</span>; k &lt;= number; ++k) &#123;</span><br><span class="line">        <span class="comment">// 第k次掷骰子，那么最小值就是k</span></span><br><span class="line">        <span class="comment">// 不可能出现比k小的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            probabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能出现的和的范围就是 [k, gMaxValue * k + 1)</span></span><br><span class="line">        <span class="comment">// 此时和为i的出现次数，就是上次循环中骰子点数和为</span></span><br><span class="line">        <span class="comment">// i - 1, i - 2, ..., i - 6 的次数总和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt; gMaxValue * k + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            probabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 这里的j是指：本骰子掷出的结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; j &lt;= gMaxValue; ++j) &#123;</span><br><span class="line">                probabilities[<span class="number">1</span> - flag][i] += probabilities[flag][i - j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">1</span> - flag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部情况的总数</span></span><br><span class="line">    <span class="keyword">const</span> total = <span class="built_in">Math</span>.pow(gMaxValue, number)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = number; i &lt; gMaxValue * number + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`sum is <span class="subst">$&#123;i&#125;</span>, ratio is <span class="subst">$&#123;probabilities[flag][i] / total&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> * 6个骰子，所有和出现的可能性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">printProbability(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌的顺子</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/10.bu-ke-pai-de-shun-zi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。</p>
<p>2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王可以看成任意数字。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>难度不大，可以将大小王看成数字 0，可以在任何不连续的两个数字之间做填充。</p>
<p>首先将原数组排序，然后统计任意数字（0）的出现次数。再遍历之后的数字，找出不相邻数字之间总共差多少个数字。</p>
<p>最后比较 0 的出现次数和总共差多少个数字，两者的大小关系。</p>
<p><strong>注意</strong>：连续两个相同的数字是对子，不符合要求。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isContinuous</span>(<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    numbers.sort()</span><br><span class="line">    <span class="keyword">const</span> length = numbers.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> zeroNum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; !numbers[i]; ++i) &#123;</span><br><span class="line">        ++zeroNum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> interval = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = zeroNum + <span class="number">1</span>; i &lt; length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] === numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        interval += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> interval &lt;= zeroNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(isContinuous([<span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(isContinuous([<span class="number">8</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/06.di-gui-yu-xun-huan/11.yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>0,1,…,n-1 这 n 个数字排成一个圆圈，从数字 0 开始每次从这个圆圈里删除第 m 个数字。求出这个圆圈里剩下的最后一个数字。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>这个其实是经典的“约瑟夫环”问题。常用解法就是“循环取余”。每次都把下标移动 m 个位置，然后移除当前元素。直到只剩最后一个元素。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>n 0, 1, 2, ..., n-1 一共n个数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>m 被删除的第m个数字(从0计算)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastRemain</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 [0, 1, ... , n-1] 的列表</span></span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        nums[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐步移除第m个数字</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        start = (start + m) % nums.length</span><br><span class="line">        nums.splice(start, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums.shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(lastRemain(<span class="number">5</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/01.chong-jian-er-cha-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><ol>
<li>前序遍历的第一个元素一定是树的根结点</li>
<li>在中序遍历中找到此节点，左边是左子树，右边是右子树</li>
<li>根据左右子树的长度，再次划分两个序列，进一步递归</li>
</ol>
<p><img src="https://i.loli.net/2019/06/09/5cfcfdba0879632882.png"></p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前序遍历和中序遍历重构二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstruct</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!preorder.length || !inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] === preorder[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过变量i可以确定在 前序遍历 / 中序遍历中 确定 左 / 右子树的长度</span></span><br><span class="line">    node.left = reConstruct(preorder.slice(<span class="number">1</span>, i + <span class="number">1</span>), inorder.slice(<span class="number">0</span>, i))</span><br><span class="line">    node.right = reConstruct(preorder.slice(i + <span class="number">1</span>), inorder.slice(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> preArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">const</span> midArr = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> binTree = reConstruct(preArr, midArr)</span><br><span class="line"><span class="built_in">console</span>.log(binTree)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否子树</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/02.pan-duan-shi-fou-zi-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p>
<p>树的节点定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>假设判断的是<code>p2</code>是不是<code>p1</code>的子树，实现分为 2 个部分：</p>
<ol>
<li>遍历树的函数<code>hasSubTree</code>：遍历 p1 的每个节点，如果当前节点的 value 和 p2 根节点的 value 相同，立即进入判断函数（下一个函数）；否则继续遍历</li>
<li>判断子树的函数<code>doesTree1HaveTree2</code>：比较当前节点的值，再递归比较 p1 和 p2 的左右节点的值</li>
</ol>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * p2是否是p1的子树, 参数特点是: p1和p2的根节点value相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesTree1HaveTree2</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// p2遍历完了，说明p2包含在p1中</span></span><br><span class="line">    <span class="keyword">if</span> (!p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1提前遍历完 || 两个节点不同, 说明p2不包含在p1中</span></span><br><span class="line">    <span class="keyword">if</span> (!p1 || p1.value !== p2.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doesTree1HaveTree2(p1.left, p2.left) &amp;&amp; doesTree1HaveTree2(p1.right, p2.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断p1是否包含p2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">p2</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasSubTree</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">        <span class="comment">// 节点值相同, 进一步比较</span></span><br><span class="line">        <span class="keyword">if</span> (p1.value === p2.value) &#123;</span><br><span class="line">            result = doesTree1HaveTree2(p1, p2)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往左找</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = hasSubTree(p1.left, p2)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往右找</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            result = hasSubTree(p1.right, p2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree1 = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">3</span>)), <span class="keyword">new</span> Node(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree2 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasSubTree(tree1, tree2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/03.er-cha-shu-de-jing-xiang/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>书上给了一个示意图：</p>
<p><img src="https://i.loli.net/2019/06/09/5cfcfdba2e61382505.png"></p>
<p>显而易见，从根节点开始，交换左右子树的位置；再照这个思路向下处理子树节点。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树镜像函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mirrorBinaryTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换左右节点</span></span><br><span class="line">    <span class="keyword">let</span> left = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = left</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续处理左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        mirrorBinaryTree(root.left)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        mirrorBinaryTree(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">3</span>)), <span class="keyword">new</span> Node(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">mirrorBinaryTree(root)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/04.er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="2-思路描述"><a href="#2-思路描述" class="headerlink" title="2. 思路描述"></a>2. 思路描述</h2><p>因为是后序遍历，所以根节点是最后一个元素。然后前面序列分为 2 部分，有一部分是左子树，有一部分是右子树。</p>
<p>根据二叉搜索树的性质，左子树的元素一定小于最后一个元素，右子树的元素一定大于最后一个元素。</p>
<p>根据这个思路，一直递归下去即可。只要所有部分都满足二叉搜索树的性质，那么符合条件。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是二叉搜索树的后序遍历结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>tailOrder 后序遍历顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBST</span>(<span class="params">tailOrder</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 空序列代表空树, 这里认为是BST</span></span><br><span class="line">    <span class="keyword">if</span> (tailOrder.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = tailOrder.length</span><br><span class="line">    <span class="keyword">let</span> root = tailOrder[length - <span class="number">1</span>],</span><br><span class="line">        i,</span><br><span class="line">        j</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到左子树</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span> &amp;&amp; tailOrder[i] &lt; root; ++i);</span><br><span class="line">    <span class="comment">// 找到右子树</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; length - <span class="number">1</span> &amp;&amp; tailOrder[j] &gt; root; ++j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有遍历完, 说明不是左边部分小，右边部分大的分布</span></span><br><span class="line">    <span class="comment">// 显然，不符合后序遍历的定义</span></span><br><span class="line">    <span class="keyword">if</span> (j !== length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理左右子树</span></span><br><span class="line">    <span class="keyword">let</span> left = isBST(tailOrder.slice(<span class="number">0</span>, i))</span><br><span class="line">    <span class="keyword">let</span> right = isBST(tailOrder.slice(i, length - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(isBST([<span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">8</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isBST([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isBST([<span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/05.er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<strong>从树的根结点开始往下一直到叶结点</strong>所经过的结点形成一条路径。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><ol>
<li>每次来到新的节点，记录新节点信息</li>
<li>检查新节点是否是叶子节点，如果是，判断路径上的节点值总和是否符合条件；如果不是，继续递归处理左右子树，回到第 1 步</li>
<li>最后需要将新节点的信息移除</li>
</ol>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value = <span class="number">0</span>, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPath</span>(<span class="params">root, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paths = [] <span class="comment">// 存放所有满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span> <span class="comment">// 路径上的节点值的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_findPath</span>(<span class="params">node, path</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前节点放入路径中</span></span><br><span class="line">        sum = sum + node.value</span><br><span class="line">        path.push(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> isLeaf = node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是叶节点, 并且路径上的节点和满足条件, 记录这条路径</span></span><br><span class="line">        <span class="keyword">if</span> (isLeaf &amp;&amp; sum === target) &#123;</span><br><span class="line">            paths.push([...path])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点有左子树, 向左子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">            _findPath(node.left, path)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点有右子树, 向右子树递归</span></span><br><span class="line">        <span class="keyword">if</span> (node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">            _findPath(node.right, path)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把当前节点从路径中移除</span></span><br><span class="line">        sum = sum - node.value</span><br><span class="line">        path.pop(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _findPath(root, [])</span><br><span class="line">    <span class="keyword">return</span> paths</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">2</span>), <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>, <span class="keyword">new</span> Node(-<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findPath(root, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树层序遍历</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/06.er-cha-shu-ceng-xu-bian-li/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>借助队列这种“先入先出”的线性数据结构即可。每次访问队列中的元素的时候，输出它的值，并且将其非空左右节点放入队列中。直到队列为空，停止输出，结束函数循环即可。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层级遍历二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelTravel</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queue = [root]</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> first = queue.shift()</span><br><span class="line">        <span class="built_in">console</span>.log(first.value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first.left) &#123;</span><br><span class="line">            queue.push(first.left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first.right) &#123;</span><br><span class="line">            queue.push(first.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="number">10</span>, <span class="keyword">new</span> TreeNode(<span class="number">6</span>, <span class="keyword">new</span> TreeNode(<span class="number">4</span>), <span class="keyword">new</span> TreeNode(<span class="number">8</span>)), <span class="keyword">new</span> TreeNode(<span class="number">14</span>, <span class="keyword">new</span> TreeNode(<span class="number">12</span>), <span class="keyword">new</span> TreeNode(<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line">levelTravel(root)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树转双向链表</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/07.er-cha-shu-zhuan-shuang-xiang-lian-biao/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>在搜索二叉树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在转换成排序双向链表时，<strong>原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点指针</strong>。</p>
<p>因为要遍历树，所以要选取遍历算法。<strong>为了保证遍历的有序性，采用中序遍历</strong>。在 convertNode 函数实现中，注意 lastNodeInList 语意，剩下的按照思路写出来即可。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将node和左右子树转化为双向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> </span>node 待转化的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> </span>lastNodeInList 已转换好的双向链表的尾结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertNode</span>(<span class="params">node, lastNodeInList = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先处理左子树</span></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">        lastNodeInList = convertNode(node.left, lastNodeInList)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点与原双向链表拼接</span></span><br><span class="line">    node.left = lastNodeInList</span><br><span class="line">    <span class="keyword">if</span> (lastNodeInList) &#123;</span><br><span class="line">        lastNodeInList.right = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理右子树</span></span><br><span class="line">    lastNodeInList = node</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">        lastNodeInList = convertNode(node.right, lastNodeInList)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新链表的尾节点</span></span><br><span class="line">    <span class="keyword">return</span> lastNodeInList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertTreeToList</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastNodeInList = convertNode(root)</span><br><span class="line">    <span class="keyword">let</span> headOfList = lastNodeInList</span><br><span class="line">    <span class="comment">// 返回转化好的双向链表的头节点</span></span><br><span class="line">    <span class="keyword">while</span> (headOfList &amp;&amp; headOfList.left) &#123;</span><br><span class="line">        headOfList = headOfList.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headOfList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> TreeNode(<span class="number">10</span>, <span class="keyword">new</span> TreeNode(<span class="number">6</span>, <span class="keyword">new</span> TreeNode(<span class="number">4</span>), <span class="keyword">new</span> TreeNode(<span class="number">8</span>)), <span class="keyword">new</span> TreeNode(<span class="number">14</span>, <span class="keyword">new</span> TreeNode(<span class="number">12</span>), <span class="keyword">new</span> TreeNode(<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nodeOfList = convertTreeToList(root)</span><br><span class="line"><span class="keyword">while</span> (nodeOfList) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nodeOfList.value)</span><br><span class="line">    nodeOfList = nodeOfList.right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断是否是平衡二叉树</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/07.shu/08.pan-duan-shi-fou-shi-ping-heng-er-cha-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>判断一棵树是不是平衡二叉树。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>思路一：计算出左右子树的深度，然后检查差。递归继续判断左子树和右子树是不是平衡二叉树。</p>
<p>思路二：先计算左子树和右子树是不是平衡二叉树，然后再计算本身是不是平衡二叉树。</p>
<p>关于思路二为什么能比思路一更好，请看代码。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-树的深度"><a href="#3-1-树的深度" class="headerlink" title="3.1 树的深度"></a>3.1 树的深度</h3><p>先递归实现树的深度函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value, left, right</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="built_in">this</span>.left = left</span><br><span class="line">        <span class="built_in">this</span>.right = right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取二叉树的深度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> leftDepth = treeDepth(root.left)</span><br><span class="line">    <span class="keyword">const</span> rightDepth = treeDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> leftDepth &gt; rightDepth ? leftDepth + <span class="number">1</span> : rightDepth + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-思路一"><a href="#3-2-思路一" class="headerlink" title="3.2 思路一"></a>3.2 思路一</h3><p>这种思路慢是因为：节点被重复计算了。得出 <code>leftDepth</code> 计算了一遍 <code>root.left</code> ，最后还要再调用自身计算 <code>root.left</code>。尤其是叶子节点，会造成很多的计算浪费。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是平衡二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanced</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> leftDepth = treeDepth(root.left)</span><br><span class="line">    <span class="keyword">const</span> rightDepth = treeDepth(root.right)</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="built_in">Math</span>.abs(leftDepth - rightDepth)</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-思路二"><a href="#3-3-思路二" class="headerlink" title="3.3 思路二"></a>3.3 思路二</h3><p>先遍历和计算左右子树，最后计算本身。不需要重复计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优化：判断是否是平衡二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Node&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">obj</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanced2</span>(<span class="params">root, obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        obj.depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> left = &#123;&#125;,</span><br><span class="line">        right = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (isBalanced2(root.left, left) &amp;&amp; isBalanced2(root.right, right)) &#123;</span><br><span class="line">        <span class="keyword">const</span> diff = <span class="built_in">Math</span>.abs(left.depth - right.depth)</span><br><span class="line">        <span class="keyword">if</span> (diff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj.depth = <span class="number">1</span> + (left.depth &gt; right.depth ? left.depth : right.depth)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">new</span> Node(<span class="number">4</span>), <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="keyword">new</span> Node(<span class="number">7</span>))), <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="literal">null</span>, <span class="keyword">new</span> Node(<span class="number">6</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试树的深度</span></span><br><span class="line"><span class="built_in">console</span>.log(treeDepth(root)) <span class="comment">// output: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是平衡二叉树</span></span><br><span class="line"><span class="built_in">console</span>.time()</span><br><span class="line"><span class="built_in">console</span>.log(isBalanced(root)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd() <span class="comment">// 0.594ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化算法：判断是否是平衡二叉树</span></span><br><span class="line"><span class="built_in">console</span>.time()</span><br><span class="line"><span class="built_in">console</span>.log(isBalanced2(root)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd() <span class="comment">// 0.242ms</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/08.wei-yun-suan/01.er-jin-zhi-zhong-1-de-ge-shu/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如把 9 表示成二进制是 1001，有 2 位是 1。因此如果输入 9，该函数输出 2。</p>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>注意到，如果要判断一个二进制数指定位数是否为 1，比如这个二进制数是 1011。那么只需要构造除了这个位为 1，其他位为 0 的二进制即可，这个例子是 0100。</p>
<p>两者进行<code>&amp;</code>运算，如果结果为 0，那么指定位数不为 1；否则为 1。</p>
<p>现在事情就简单了，只要准备数字<code>1</code>，每次与原数进行<code>&amp;</code>操作，然后左移<code>1</code>；<br>重复前面的步骤，就能逐步比较出每一位是不是<code>1</code>。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberOf1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag &amp; n) &#123;</span><br><span class="line">            ++count</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberOf1(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：有更好的实现思路，请见“02-二进制中 1 的个数进阶版”。</p>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数进阶版</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/08.wei-yun-suan/02.er-jin-zhi-zhong-1-de-ge-shu-jin-jie-ban/</url>
    <content><![CDATA[<h2 id="1-优化做法"><a href="#1-优化做法" class="headerlink" title="1. 优化做法"></a>1. 优化做法</h2><p>有个不错的规律，对于一个整数<code>n</code>，运算结果<code>n &amp; (n - 1)</code>可以消除而今中从右向左出现的第一个<code>1</code>。比如二进制数<code>011</code>，减去 1 是<code>010</code>，做与运算的结果就是<code>010</code>。</p>
<p>利用这个性质，可以逐步剔除原数二进制中的<code>1</code>。每次剔除，统计量<code>count</code>都加 1；直到所有的<code>1</code>都被移除，原数变成<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberOf1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++count</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberOf1(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h2 id="2-如何判断-2-的整次方"><a href="#2-如何判断-2-的整次方" class="headerlink" title="2. 如何判断 2 的整次方"></a>2. 如何判断 2 的整次方</h2><p>如果一个数是 2 的整次方，那么只有一个二进制位为 1。所以，<code>n &amp; (n - 1)</code>如果不是 1，说明二进制表示中有多个 1，那么就不是 2 的整次方；否则，就是得。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是2的整次方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is2Power</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unvalid param&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !(n &amp; (n - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(is2Power(<span class="number">128</span>))</span><br></pre></td></tr></table></figure>

<h2 id="3-求多少个不同的二进制位"><a href="#3-求多少个不同的二进制位" class="headerlink" title="3. 求多少个不同的二进制位"></a>3. 求多少个不同的二进制位</h2><p>题目：输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n。翻译过来就是：m 和 n 二进制位上有多少个不同的数。</p>
<p>思路：</p>
<ol>
<li>m 和 n 进行异或操作，不同的位都变成了 1</li>
<li>利用前面的思路统计 1 的个数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解二进制表示中有多少位不相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">a</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">b</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDiffBytes</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">        n = a ^ b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++count</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getDiffBytes(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getDiffBytes(<span class="number">3</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中只出现一次的数字</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/08.wei-yun-suan/03.shu-zu-zhong-zhi-chu-xian-yi-ci-de-shu-zi/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>一个整型数组中，除了 2 个数字之外，其他数字都出现了 2 次。要求找出来这 2 个数字，时间复杂度 O(N)，空间复杂度 O(1)</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>因为空间复杂度限制，所以没法用哈希表。</p>
<p>如果只有 1 个数字出现 1 次，那么可以使用“异或”运算，最后的结果就是这个数字。</p>
<p>但题目中有 2 个数字，要考虑分组问题。将这两个数字分到 2 组中，然后再每组内分别异或：</p>
<ol>
<li>全部异或，最终结果是 2 个数字异或结果</li>
<li>找到结果中第一个 1 出现的位数</li>
<li>按照此位是不是 1，将原数据分成 2 组</li>
<li>组内分别异或</li>
</ol>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到num二进制表示中第一个1的位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstBitIsOne</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> indexBit = <span class="number">0</span>,</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (flag &amp;&amp; (flag &amp; num) === <span class="number">0</span>) &#123;</span><br><span class="line">        ++indexBit</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indexBit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断num的第index二进制位是否为1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">num</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIndexBitIsOne</span>(<span class="params">num, index</span>) </span>&#123;</span><br><span class="line">    num = num &gt;&gt; index</span><br><span class="line">    <span class="keyword">return</span> !!(num &amp; <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findNumsAppearOnce</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> orResult = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        orResult ^= num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> indexOfOne = findFirstBitIsOne(orResult)</span><br><span class="line">    <span class="keyword">let</span> num1 = <span class="number">0</span>,</span><br><span class="line">        num2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkIndexBitIsOne(num, indexOfOne)) &#123;</span><br><span class="line">            num1 ^= num</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num2 ^= num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [num1, num2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findNumsAppearOnce([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="4-拓展阅读"><a href="#4-拓展阅读" class="headerlink" title="4. 拓展阅读"></a>4. 拓展阅读</h2><p>在实现的过程中遇到一个好玩的问题：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ 1 &lt;&lt; <span class="string">32 # 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ 1 &lt;&lt; 31 # -2147483648</span></span><br><span class="line"><span class="string">$ -2147483648 &lt;&lt; 1 # 0</span></span><br></pre></td></tr></table></figure>

<p>同样是 1 移动了 32 位，但是结果不同。这是因为在位移操作中，原数和位移数都是 32 位有符号位表示。</p>
<p>为了防止越界，js 会“自作聪明”地帮你把位移数做运算：<code>shiftNum &amp; 0x1f</code>。</p>
<p>所以，<code>1 &lt;&lt; 32</code> 就相当于 <code>1 &lt;&lt; (32 &amp; 0x1f)</code>，即：<code>1 &lt;&lt; 0</code>。</p>
<p>参考：<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.7.1">ECMA 官方定义</a></p>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/09.ha-xi-biao/01.chou-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 1500 个丑数。</p>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>根据定义，将给定的数不断除 2、3、5，看看能不能除尽即可。然后从 1 遍历到 1500。</p>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>前面速度慢是因为计算了太多非丑数。根据丑数定义，<strong>每一个丑数都是根据前面一个丑数乘以 2、3 或者 5 得到的</strong>。</p>
<p>在确保顺序的情况下，逐步计算即可。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><h3 id="3-1-思路一实现"><a href="#3-1-思路一实现" class="headerlink" title="3.1 思路一实现"></a>3.1 思路一实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否符合丑数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUgly</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (number % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number === <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出 [1, index) 之中的所有丑数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUglyNumber</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">0</span>,</span><br><span class="line">        uglyFound = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (uglyFound &lt; index) &#123;</span><br><span class="line">        ++number</span><br><span class="line">        <span class="keyword">if</span> (isUgly(number)) &#123;</span><br><span class="line">            ++uglyFound</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-思路二实现"><a href="#3-2-思路二实现" class="headerlink" title="3.2 思路二实现"></a>3.2 思路二实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUglyNumber</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uglyNum = [<span class="number">1</span>] <span class="comment">// 存放丑数</span></span><br><span class="line">    <span class="comment">// 2，3，5 三个因子各自的指针</span></span><br><span class="line">    <span class="keyword">let</span> pointer2 = <span class="number">0</span>,</span><br><span class="line">        pointer3 = <span class="number">0</span>,</span><br><span class="line">        pointer5 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找出下一个丑数，确保顺序</span></span><br><span class="line">        uglyNum[i] = <span class="built_in">Math</span>.min(uglyNum[pointer2] * <span class="number">2</span>, uglyNum[pointer3] * <span class="number">3</span>, uglyNum[pointer5] * <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 如果结果相同，移动指针，防止下次重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (uglyNum[i] == uglyNum[pointer2] * <span class="number">2</span>) ++pointer2</span><br><span class="line">        <span class="keyword">if</span> (uglyNum[i] == uglyNum[pointer3] * <span class="number">3</span>) ++pointer3</span><br><span class="line">        <span class="keyword">if</span> (uglyNum[i] == uglyNum[pointer5] * <span class="number">5</span>) ++pointer5</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uglyNum[index - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getUglyNumber(<span class="number">1500</span>)) <span class="comment">// 859963392</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次只出现一次的字符</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/09.ha-xi-biao/02.di-yi-ci-zhi-chu-xian-yi-ci-de-zi-fu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在字符串中找到第一个只出现一次的字符。</p>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h2><p>从头到尾遍历一遍，统计每个字符的出现次数，保存到哈希表中。</p>
<p>再重新遍历一遍，每次都检查哈希表中的次数是不是 1，是 1，直接返回，这就是第一个字符。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">str</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstNoRepeatChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> chars = str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> chars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (char <span class="keyword">in</span> map) &#123;</span><br><span class="line">            map[char] += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[char] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> chars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[char] === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> char</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findFirstNoRepeatChar(<span class="string">&#x27;abaccdeff&#x27;</span>)) <span class="comment">// output: &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/2019/06/23/jian-zhi-offer-shua-ti-bi-ji/10.dui/01.zui-xiao-de-k-ge-shu/</url>
    <content><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入 n 个整数，找出其中最小的 k 个数。例如输入 4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p>
<h2 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="2. 思路分析"></a>2. 思路分析</h2><p>这里创建一个容量为 k 的最大堆。遍历给定数据集合，每次和堆顶元素进行比较，如果小于堆顶元素，则弹出堆顶元素，然后将当前元素放入堆。</p>
<p>由于堆大小为 k，所以弹出、推入操作复杂度为：O(logK)。因为有 n 个，总体复杂度为：O(nLogK)。</p>
<p>对比快排 partition 的思路，这种思路优点如下：</p>
<ol>
<li>不会变动原数组</li>
<li>适合处理海量数据，尤其对于不是一次性读取的数据</li>
</ol>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>请先执行：<code>yarn add heap</code> 或者 <code>npm install heap</code></p>
<p>代码如下；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Heap = <span class="built_in">require</span>(<span class="string">&#x27;heap&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKthNumbers</span>(<span class="params">nums = [], k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> heap = <span class="keyword">new</span> Heap(compare)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; k) &#123;</span><br><span class="line">            heap.push(num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> top = heap.pop()</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= top) &#123;</span><br><span class="line">                heap.push(num)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heap.push(top)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heap.toArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getKthNumbers([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>], <span class="number">4</span>)) <span class="comment">// output: [ 4, 3, 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(getKthNumbers([<span class="number">10</span>, <span class="number">2</span>], <span class="number">1</span>)) <span class="comment">// output: [ 2 ]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前端简单使用MySQL</title>
    <url>/2019/07/11/shu-ju-ku/01.mysql/01.qian-duan-jian-dan-shi-yong-mysql/</url>
    <content><![CDATA[<h2 id="数据库的五个概念"><a href="#数据库的五个概念" class="headerlink" title="数据库的五个概念"></a>数据库的五个概念</h2><ol>
<li> 数据库服务器</li>
<li> 数据库</li>
<li> 数据表</li>
<li> 数据字段</li>
<li> 数据行</li>
</ol>
<p>那么这里下面既是对上面几个概念进行基本的日常操作。</p>
<h2 id="数据库引擎使用"><a href="#数据库引擎使用" class="headerlink" title="数据库引擎使用"></a>数据库引擎使用</h2><p>这里仅仅只介绍常用的两种引擎,而InnoDB是从MySQL 5.6.版本以后InnoDB就是作为默认启动使用的存储引擎。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(1) InnoDB</span><br><span class="line">        a,支持ACID，简单地说就是支持事务完整性、一致性；</span><br><span class="line">        b,支持行锁，以及类似ORACLE的一致性读，多用户并发；</span><br><span class="line">        c,独有的聚集索引主键设计方式，可大幅提升并发读写性能；</span><br><span class="line">        d,支持外键；</span><br><span class="line">        e,支持崩溃数据自修复；</span><br><span class="line">        InnoDB设计目标是处理大容量数据库系统，它的CPU利用率是其它基于磁盘的关系数据库引擎所不能比的。</span><br><span class="line">         它是一个可靠地事务处理引擎，不支持全文本搜索</span><br><span class="line"></span><br><span class="line">(2) MyISAM</span><br><span class="line">        a,不支持 每次查询具有原子性</span><br><span class="line">        b,只支持表所</span><br><span class="line">        c,强调的是性能，其执行数 度比InnoDB类型更快，但是不提供事务支持</span><br><span class="line">        d,如果执行大量的SELECT，MyISAM是更好的选择</span><br><span class="line">        e,缺点：就是不能在表损坏后恢复数据。（是不能主动恢复）</span><br></pre></td></tr></table></figure>

<p>既然知道了这俩种引擎的优缺点，那么写一下几个常用的API操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;   <span class="comment">--显示所有可用的引擎</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> myDB;   <span class="comment">--查看myDB数据库下的所有表使用的引擎</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;         <span class="comment">--指定查看表名的所有段名以及引擎</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>)) <span class="keyword">engine</span>=MyISAM; <span class="comment">--建表的时候指定引擎   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">Engine</span>= MyISAM; <span class="comment">--建完表后修改引擎为MyISAM</span></span><br></pre></td></tr></table></figure>
<p>当然，也可以通过修改配置文件<code>my.ini</code>在[mysqld]最后添加为上default-storage-engine=InnoDB，重启服务，数据库默认的引擎修改为InnoDB。</p>
<h2 id="Node使用mysql示例"><a href="#Node使用mysql示例" class="headerlink" title="Node使用mysql示例"></a>Node使用mysql示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql  = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;     </span><br><span class="line">  host     : <span class="string">&#x27;localhost&#x27;</span>,       </span><br><span class="line">  user     : <span class="string">&#x27;root&#x27;</span>,              </span><br><span class="line">  password : <span class="string">&#x27;123456&#x27;</span>,       </span><br><span class="line">  port: <span class="string">&#x27;3306&#x27;</span>,                   </span><br><span class="line">  database: <span class="string">&#x27;test&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  sql = <span class="string">&#x27;SELECT * FROM websites&#x27;</span>;</span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">connection.query(sql,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;[SELECT ERROR] - &#x27;</span>,err.message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;--------------------------SELECT----------------------------&#x27;</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(result);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;------------------------------------------------------------\n\n&#x27;</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>query方法第一个参数是sql语句,第二参数是callback</p>
</blockquote>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;net start mysql  //启动数据库和停止net stop mysql</span><br><span class="line"></span><br><span class="line">&gt;mysql -u root -p   //默认登陆本机(-h是主机地址)</span><br><span class="line"></span><br><span class="line">&gt;SELECT USER();   //显示当前用户</span><br><span class="line"></span><br><span class="line">&gt;create database 数据库名;    //创建数据库</span><br><span class="line"></span><br><span class="line">&gt;SELECT DATABASE();   //显示当前使用数据库</span><br><span class="line"></span><br><span class="line">&gt;SHOW DATABASES        //显示所有数据库列表</span><br><span class="line"></span><br><span class="line">&gt;USE DATABASE 库名;     //使用该数据库</span><br><span class="line"></span><br><span class="line">&gt;DROP DATABASE 库名   //删除数据库</span><br><span class="line"></span><br><span class="line">&gt;CMD终端：mysqladmin -u用户名 -p旧密码 password 新密码   //修改密码</span><br><span class="line"></span><br><span class="line">&gt;mysql语句：set password for 用户名@localhost = password(&#x27;新密码&#x27;); </span><br></pre></td></tr></table></figure>

<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;SHOW TABLES;   //列出库中所有的表</span><br><span class="line"></span><br><span class="line">&gt;DESCRIBE table1;  //查看表结构</span><br><span class="line"></span><br><span class="line">&gt;show columns from 数据表;   //显示表的所有段名以及类型</span><br><span class="line"></span><br><span class="line">&gt;CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1)); //增加数据表和字段名</span><br><span class="line"></span><br><span class="line">&gt;DROP TABLE 表名;  //删除表</span><br><span class="line"></span><br><span class="line">&gt;alter table stu rename as students;  //将旧表明stu改为新表明students。</span><br></pre></td></tr></table></figure>
<h2 id="表字段操作"><a href="#表字段操作" class="headerlink" title="表字段操作"></a>表字段操作</h2><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> 字段名 字段类型 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">示例：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dictionary <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> calss <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">-- dictionary是表名</span></span><br></pre></td></tr></table></figure>

<h3 id="修改字段名称"><a href="#修改字段名称" class="headerlink" title="修改字段名称"></a>修改字段名称</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 旧字段名 新字段名 新字段类型 <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">示例：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dictionary <span class="keyword">CHANGE</span> calss <span class="keyword">class</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 字段名</span><br><span class="line"></span><br><span class="line">示例：<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> dictionary <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> calss;</span><br></pre></td></tr></table></figure>

<h3 id="批量增加字段"><a href="#批量增加字段" class="headerlink" title="批量增加字段"></a>批量增加字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">bagin;                                           //事务开始</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> em_day_data <span class="keyword">add</span> f_day_house7 <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> em_day_data <span class="keyword">add</span> f_day_house8 <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> em_day_data <span class="keyword">add</span> f_day_house9 <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> em_day_data <span class="keyword">add</span> f_day_house10 <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">commit</span>;                                             //提交事务，事务结束</span><br></pre></td></tr></table></figure>


<h2 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a>数据增删改查</h2><p>MySQL语句忽略大小写的。每张数据表只能存在一个主键。</p>
<p><strong>Tip:</strong> 由于数据表的首个字段名(就是主键,假如是id)是不能重复命名的(建议使用id,因为每张表只能存在一个主键),所以建议删除的时候使用(where id=1)键名来定位匹配更好。</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var  sql = &#x27;<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> websites<span class="string">&#x27;;   --查询整个websites表所有数据</span></span><br><span class="line"><span class="string">var  sql = &#x27;</span><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> websites<span class="string">&#x27;;  --查询整个websites表name字段数据</span></span><br></pre></td></tr></table></figure>

<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- websites表必须存在(Id,name,url,alexa,country)这些字段名</span></span><br><span class="line">var  addSql = &#x27;<span class="keyword">INSERT</span> <span class="keyword">INTO</span> websites(<span class="keyword">Id</span>,<span class="keyword">name</span>,<span class="keyword">url</span>,alexa,country) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&quot;taobao&quot;</span>,<span class="string">&quot;http://wwww.taobao.com&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;CN&quot;</span>)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">insert into table1(id,name,url,country) values(6,&quot;lucas&quot;,&quot;https://wwww.lucas.com&quot;,&quot;CN&quot;);</span></span><br></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- where是定位到上面的增加数据(可以使用任何&quot;字段名=值&quot;来匹配),并更改俩个数据</span></span><br><span class="line">var modSql = &#x27;<span class="keyword">UPDATE</span> websites <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">&quot;facebook&quot;</span>,<span class="keyword">url</span> = <span class="string">&quot;http://www.facebook.com&quot;</span> <span class="keyword">WHERE</span> <span class="keyword">Id</span> = <span class="number">2</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var modSql = &#x27;</span><span class="keyword">update</span> websites <span class="keyword">SET</span> alexa=<span class="string">&quot;12&quot;</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">&quot;taobao&quot;</span><span class="string">&#x27;;  --定位name字段为taobao并更新了alexa字段的值</span></span><br></pre></td></tr></table></figure>

<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var delSql = &#x27;<span class="keyword">DELETE</span> <span class="keyword">FROM</span> websites <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span><span class="string">&#x27;;  -- 删除id=2的数据(当然)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 删除name=lucas的数据(建议使用id,因为每张表只能存在一个主键),因为他会将表中所有name=lucas的值全部删除</span></span><br><span class="line"><span class="string">delete from websites where name=&quot;lucas&quot;;   </span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据库应用</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之单例模式</title>
    <url>/2018/10/23/she-ji-mo-shi-shou-ce/01.chuang-jian-xing-mo-shi/01.dan-li-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是单例模式？"><a href="#1-什么是单例模式？" class="headerlink" title="1. 什么是单例模式？"></a>1. 什么是单例模式？</h2><blockquote>
<p>单例模式定义：保证一个类仅有一个实例，并提供访问此实例的全局访问点。</p>
</blockquote>
<h2 id="2-单例模式用途"><a href="#2-单例模式用途" class="headerlink" title="2. 单例模式用途"></a>2. 单例模式用途</h2><p>如果一个类负责连接数据库的线程池、日志记录逻辑等等，<strong>此时需要单例模式来保证对象不被重复创建，以达到降低开销的目的。</strong></p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><blockquote>
<p>需要指明的是，<strong>以下实现的单例模式均为“惰性单例”：只有在用户需要的时候才会创建对象实例。</strong></p>
</blockquote>
<h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">  <span class="comment"># 将实例作为静态变量</span></span><br><span class="line">  __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span>():</span></span><br><span class="line">    <span class="keyword">if</span> Singleton.__instance == <span class="literal">None</span>:</span><br><span class="line">      <span class="comment"># 如果没有初始化实例，则调用初始化函数</span></span><br><span class="line">      <span class="comment"># 为Singleton生成 instance 实例</span></span><br><span class="line">      Singleton()</span><br><span class="line">    <span class="keyword">return</span> Singleton.__instance</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> Singleton.__instance != <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">raise</span> Exception(<span class="string">&quot;请通过get_instance()获得实例&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 为Singleton生成 instance 实例</span></span><br><span class="line">      Singleton.__instance = self</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">  s1 = Singleton.get_instance()</span><br><span class="line">  s2 = Singleton.get_instance()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 查看内存地址是否相同</span></span><br><span class="line">  print(<span class="built_in">id</span>(s1) == <span class="built_in">id</span>(s2))</span><br></pre></td></tr></table></figure>

<h3 id="3-2-javascript-实现"><a href="#3-2-javascript-实现" class="headerlink" title="3.2 javascript 实现"></a>3.2 javascript 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 由于es6没有静态类型,故闭包: 函数外部无法访问 instance</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否存在实例</span></span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = Singleton.getInstance()</span><br><span class="line"><span class="keyword">let</span> s2 = Singleton.getInstance()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之工厂模式</title>
    <url>/2019/03/31/she-ji-mo-shi-shou-ce/01.chuang-jian-xing-mo-shi/02.gong-han-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是工厂模式？"><a href="#1-什么是工厂模式？" class="headerlink" title="1. 什么是工厂模式？"></a>1. 什么是工厂模式？</h2><p>工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”</p>
<p>简单来说：<strong>就是把<code>new</code>对象的操作包裹一层，对外提供一个可以根据不同参数创建不同对象的函数</strong>。</p>
<h2 id="2-工厂模式的优缺点"><a href="#2-工厂模式的优缺点" class="headerlink" title="2. 工厂模式的优缺点"></a>2. 工厂模式的优缺点</h2><p>优点显而易见，可以隐藏原始类，方便之后的代码迁移。调用者只需要记住类的代名词即可。</p>
<p>由于多了层封装，会造成类的数目过多，系统复杂度增加。</p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><h3 id="ES6-实现"><a href="#ES6-实现" class="headerlink" title="ES6 实现"></a>ES6 实现</h3><p>调用者通过向工厂类传递参数，来获取对应的实体。在这个过程中，具体实体类的创建过程，由工厂类全权负责。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类：Dog、Cat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;狗&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;猫&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类：Animal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        name = name.toLocaleLowerCase()</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dog()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;cat&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Cat()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;class name wrong&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Animal(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line">cat.run()</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line">dog.run()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之抽象工厂模式</title>
    <url>/2019/04/01/she-ji-mo-shi-shou-ce/01.chuang-jian-xing-mo-shi/03.chou-xiang-gong-han-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是抽象工厂模式？"><a href="#1-什么是抽象工厂模式？" class="headerlink" title="1. 什么是抽象工厂模式？"></a>1. 什么是抽象工厂模式？</h2><p>抽象工厂模式就是：围绕一个超级工厂类，创建其他工厂类；再围绕工厂类，创建实体类。</p>
<p>相较于传统的工厂模式，它多出了一个<strong>超级工厂类</strong>。</p>
<p>它的优缺点与工厂模式类似，这里不再冗赘它的优缺点，下面直接谈一下实现吧。</p>
<h2 id="2-如何实现抽象工厂模式？"><a href="#2-如何实现抽象工厂模式？" class="headerlink" title="2. 如何实现抽象工厂模式？"></a>2. 如何实现抽象工厂模式？</h2><p>为了让目标更清晰，就实现下面的示意图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1554116727371-b8cd40a6-628f-4546-9fa0-99ac494facf7.png#align=left&display=inline&height=287&name=image.png&originHeight=287&originWidth=527&size=266071&status=done&width=527" alt="image.png"></p>
<h3 id="准备实体类"><a href="#准备实体类" class="headerlink" title="准备实体类"></a>准备实体类</h3><p>按照之前的做法，这里我们实现几个实体类：Cat 和 Dog 一组、Male 和 Female 一组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;狗&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;猫&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;男性&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;女性&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="准备工厂类"><a href="#准备工厂类" class="headerlink" title="准备工厂类"></a>准备工厂类</h3><p>假设 Cat 和 Dog，属于 Animal 工厂的产品；Male 和 Female 属于 Person 工厂的产品。所以需要实现 2 个工厂类：Animal 和 Person。</p>
<p>由于工厂类上面还有个超级工厂，为了方便工厂类生产实体，工厂类应该提供生产实体的方法接口。</p>
<p>为了更好的约束工厂类的实现，先实现一个抽象工厂类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getPerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类请实现接口&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getAnimal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;子类请实现接口&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，Animal 和 Dog 实现抽象工厂类(AbstractFactory)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getPerson</span>(<span class="params">person</span>)</span> &#123;</span><br><span class="line">        person = person.toLocaleLowerCase()</span><br><span class="line">        <span class="keyword">switch</span> (person) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;male&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Male()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;female&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Female()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getAnimal</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getPerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getAnimal</span>(<span class="params">animal</span>)</span> &#123;</span><br><span class="line">        animal = animal.toLocaleLowerCase()</span><br><span class="line">        <span class="keyword">switch</span> (animal) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;cat&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Cat()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dog()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现“超级工厂”"><a href="#实现“超级工厂”" class="headerlink" title="实现“超级工厂”"></a>实现“超级工厂”</h3><p>超级工厂的实现没什么困难，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">choice</span>)</span> &#123;</span><br><span class="line">        choice = choice.toLocaleLowerCase()</span><br><span class="line">        <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;person&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PersonFactory()</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;animal&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AnimalFactory()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="看看怎么使用超级工厂"><a href="#看看怎么使用超级工厂" class="headerlink" title="看看怎么使用超级工厂"></a>看看怎么使用超级工厂</h3><p>实现了那么多，还是要看用例才能更好理解“超级工厂”的用法和设计理念：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下是测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建person工厂</span></span><br><span class="line"><span class="keyword">const</span> personFactory = <span class="keyword">new</span> Factory(<span class="string">&#x27;person&#x27;</span>)</span><br><span class="line"><span class="comment">// 从person工厂中创建 male 和 female 实体</span></span><br><span class="line"><span class="keyword">const</span> male = personFactory.getPerson(<span class="string">&#x27;male&#x27;</span>),</span><br><span class="line">    female = personFactory.getPerson(<span class="string">&#x27;female&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出测试</span></span><br><span class="line">male.run()</span><br><span class="line">female.run()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建animal工厂</span></span><br><span class="line"><span class="keyword">const</span> animalFactory = <span class="keyword">new</span> Factory(<span class="string">&#x27;animal&#x27;</span>)</span><br><span class="line"><span class="comment">// 从animal工厂中创建 dog 和 cat 实体</span></span><br><span class="line"><span class="keyword">const</span> dog = animalFactory.getAnimal(<span class="string">&#x27;dog&#x27;</span>),</span><br><span class="line">    cat = animalFactory.getAnimal(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line"><span class="comment">// 输出测试</span></span><br><span class="line">dog.run()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之享元模式</title>
    <url>/2018/12/16/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/01.xiang-yuan-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“享元模式”？"><a href="#1-什么是“享元模式”？" class="headerlink" title="1. 什么是“享元模式”？"></a>1. 什么是“享元模式”？</h2><blockquote>
<p>享元模式：运用共享技术来减少创建对象的数量，从而减少内存占用、提高性能。</p>
</blockquote>
<ol>
<li>享元模式提醒我们将一个<strong>对象的属性划分为内部和外部状态</strong>。<ul>
<li>内部状态：可以被对象集合共享，通常不会改变</li>
<li>外部状态：根据应用场景经常改变</li>
</ul>
</li>
<li>享元模式是<strong>利用时间换取空间</strong>的优化模式。</li>
</ol>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>享元模式虽然名字听起来比较高深，但是实际使用非常容易：<strong>只要是需要大量创建重复的类的代码块，均可以使用享元模式抽离内部/外部状态</strong>，减少重复类的创建。</p>
<p>为了显示它的强大，下面的代码是简单地实现了大家耳熟能详的“对象池”，以彰显这种设计模式的魅力。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>这里利用<code>python</code>和<code>javascript</code>实现了一个“<strong>通用对象池</strong>”类–<code>ObjectPool</code>。这个类管理一个装载空闲对象的数组，<strong>如果外部需要一个对象，直接从对象池中获取，而不是通过<code>new</code>操作</strong>。</p>
<p>对象池可以大量减少重复创建相同的对象，从而节省了系统内存，提高运行效率。</p>
<p>为了形象说明“享元模式”在“对象池”实现和应用，特别准备了模拟了<code>File</code>类，并且模拟了“文件下载”操作。</p>
<p>通过阅读下方代码可以发现：**对于<code>File</code>类，内部状态是<code>pool</code>属性和<code>download</code>方法；外部状态是<code>name</code>和<code>src</code>(文件名和文件链接)**。借助对象池，实现了<code>File</code>类的复用。</p>
<p><em>注：为了方便演示，<code>Javascript</code>实现的是并发操作，<code>Python</code>实现的是串行操作。输出结果略有不同。</em></p>
<h3 id="3-1-Python3-实现"><a href="#3-1-Python3-实现" class="headerlink" title="3.1 Python3 实现"></a>3.1 Python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectPool</span>:</span>  <span class="comment"># 通用对象池</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__pool = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, Obj</span>):</span></span><br><span class="line">        <span class="comment"># 对象池中没有空闲对象，则创建一个新的对象</span></span><br><span class="line">        <span class="comment"># 对象池中有空闲对象，直接取出，无需再次创建</span></span><br><span class="line">        <span class="keyword">return</span> self.__pool.pop() <span class="keyword">if</span> <span class="built_in">len</span>(self.__pool) &gt; <span class="number">0</span> <span class="keyword">else</span> Obj(self)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对象回收</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__pool.append(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对象池大小</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__pool)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span>  <span class="comment"># 模拟文件对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, pool</span>):</span></span><br><span class="line">        self.__pool = pool</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span>  <span class="comment"># 模拟下载操作</span></span><br><span class="line">        print(<span class="string">&#x27;+ 从&#x27;</span>, self.src, <span class="string">&#x27;开始下载&#x27;</span>, self.name)</span><br><span class="line">        sleep(<span class="number">0.1</span>)</span><br><span class="line">        print(<span class="string">&#x27;-&#x27;</span>, self.name, <span class="string">&#x27;下载完成&#x27;</span>)</span><br><span class="line">        <span class="comment"># 下载完毕后，将对象重新放入对象池</span></span><br><span class="line">        self.__pool.recover(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    obj_pool = ObjectPool()</span><br><span class="line"></span><br><span class="line">    file1 = obj_pool.create(File)</span><br><span class="line">    file1.name = <span class="string">&#x27;文件1&#x27;</span></span><br><span class="line">    file1.src = <span class="string">&#x27;https://download1.com&#x27;</span></span><br><span class="line">    file1.download()</span><br><span class="line"></span><br><span class="line">    file2 = obj_pool.create(File)</span><br><span class="line">    file2.name = <span class="string">&#x27;文件2&#x27;</span></span><br><span class="line">    file2.src = <span class="string">&#x27;https://download2.com&#x27;</span></span><br><span class="line">    file2.download()</span><br><span class="line"></span><br><span class="line">    file3 = obj_pool.create(File)</span><br><span class="line">    file3.name = <span class="string">&#x27;文件3&#x27;</span></span><br><span class="line">    file3.src = <span class="string">&#x27;https://download3.com&#x27;</span></span><br><span class="line">    file3.download()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;*&#x27;</span> * <span class="number">20</span>)</span><br><span class="line">    print(<span class="string">&#x27;下载了3个文件, 但其实只创建了&#x27;</span>, obj_pool.size(), <span class="string">&#x27;个对象&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果(这里为了方便演示直接使用了<code>sleep</code>方法，没有再用多线程模拟）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 从 https:&#x2F;&#x2F;download1.com 开始下载 文件1</span><br><span class="line">- 文件1 下载完成</span><br><span class="line">+ 从 https:&#x2F;&#x2F;download2.com 开始下载 文件2</span><br><span class="line">- 文件2 下载完成</span><br><span class="line">+ 从 https:&#x2F;&#x2F;download3.com 开始下载 文件3</span><br><span class="line">- 文件3 下载完成</span><br><span class="line">********************</span><br><span class="line">下载了3个文件, 但其实只创建了 1 个对象</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ES6-实现"><a href="#3-2-ES6-实现" class="headerlink" title="3.2 ES6 实现"></a>3.2 ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象池</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._pool = [] <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function"><span class="title">create</span>(<span class="params">Obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._pool.length === <span class="number">0</span></span><br><span class="line">            ? <span class="keyword">new</span> Obj(<span class="built_in">this</span>) <span class="comment">// 对象池中没有空闲对象，则创建一个新的对象</span></span><br><span class="line">            : <span class="built_in">this</span>._pool.shift() <span class="comment">// 对象池中有空闲对象，直接取出，无需再次创建</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象回收</span></span><br><span class="line">    <span class="function"><span class="title">recover</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._pool.push(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象池大小</span></span><br><span class="line">    <span class="function"><span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._pool.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟文件对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">pool</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟下载操作</span></span><br><span class="line">    <span class="function"><span class="title">download</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`+ 从 <span class="subst">$&#123;<span class="built_in">this</span>.src&#125;</span> 开始下载 <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`- <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 下载完毕`</span>) <span class="comment">// 下载完毕后, 将对象重新放入对象池</span></span><br><span class="line">            <span class="built_in">this</span>.pool.recover(<span class="built_in">this</span>)</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************** 以下是测试函数 **********************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objPool = <span class="keyword">new</span> ObjectPool()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file1 = objPool.create(File)</span><br><span class="line">file1.name = <span class="string">&#x27;文件1&#x27;</span></span><br><span class="line">file1.src = <span class="string">&#x27;https://download1.com&#x27;</span></span><br><span class="line">file1.download()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file2 = objPool.create(File)</span><br><span class="line">file2.name = <span class="string">&#x27;文件2&#x27;</span></span><br><span class="line">file2.src = <span class="string">&#x27;https://download2.com&#x27;</span></span><br><span class="line">file2.download()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> file3 = objPool.create(File)</span><br><span class="line">    file3.name = <span class="string">&#x27;文件3&#x27;</span></span><br><span class="line">    file3.src = <span class="string">&#x27;https://download3.com&#x27;</span></span><br><span class="line">    file3.download()</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="string">&#x27;*&#x27;</span>.repeat(<span class="number">50</span>)&#125;</span>\n下载了3个文件，但其实只创建了<span class="subst">$&#123;objPool.size()&#125;</span>个对象`</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 从 https:&#x2F;&#x2F;download1.com 开始下载 文件1</span><br><span class="line">+ 从 https:&#x2F;&#x2F;download2.com 开始下载 文件2</span><br><span class="line">- 文件1 下载完毕</span><br><span class="line">- 文件2 下载完毕</span><br><span class="line">+ 从 https:&#x2F;&#x2F;download3.com 开始下载 文件3</span><br><span class="line">- 文件3 下载完毕</span><br><span class="line">**************************************************</span><br><span class="line">下载了3个文件，但其实只创建了2个对象</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  《JavaScript 设计模式和开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之代理模式</title>
    <url>/2018/11/01/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/02.dai-li-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是代理模式？"><a href="#1-什么是代理模式？" class="headerlink" title="1. 什么是代理模式？"></a>1. 什么是代理模式？</h2><blockquote>
<p>代理模式的定义：为一个对象提供一种代理以方便对它的访问。</p>
</blockquote>
<p><strong>代理模式可以解决避免对一些对象的直接访问</strong>，以此为基础，常见的有保护代理和虚拟代理。保护代理可以在代理中直接拒绝对对象的访问；虚拟代理可以延迟访问到真正需要的时候，以节省程序开销。</p>
<h2 id="2-代理模式优缺点"><a href="#2-代理模式优缺点" class="headerlink" title="2. 代理模式优缺点"></a>2. 代理模式优缺点</h2><p>代理模式有高度解耦、对象保护、易修改等优点。</p>
<p>同样地，因为是通过“代理”访问对象，因此开销会更大，时间也会更慢。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">    self.filename = filename</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_img</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;finish load &quot;</span> + self.filename)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;display &quot;</span> + self.filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助继承来实现代理模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageProxy</span>(<span class="params">Image</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(filename)</span><br><span class="line">    self.loaded = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_img</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.loaded == <span class="literal">False</span>:</span><br><span class="line">      <span class="built_in">super</span>().load_img()</span><br><span class="line">    self.loaded = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().display()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  proxyImg = ImageProxy(<span class="string">&quot;./js/image.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 只加载一次，其它均被代理拦截</span></span><br><span class="line">  <span class="comment"># 达到节省资源的目的</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">    proxyImg.load_img()</span><br><span class="line"></span><br><span class="line">  proxyImg.display()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-javascript-实现"><a href="#3-2-javascript-实现" class="headerlink" title="3.2 javascript 实现"></a>3.2 javascript 实现</h3><p><strong><code>main.js</code> :</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> myImg = &#123;</span><br><span class="line">    <span class="function"><span class="title">setSrc</span>(<span class="params">imgNode, src</span>)</span> &#123;</span><br><span class="line">        imgNode.src = src</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用代理模式实现图片懒加载</span></span><br><span class="line"><span class="keyword">const</span> proxyImg = &#123;</span><br><span class="line">    <span class="function"><span class="title">setSrc</span>(<span class="params">imgNode, src</span>)</span> &#123;</span><br><span class="line">        myImg.setSrc(imgNode, <span class="string">&#x27;./image.png&#x27;</span>) <span class="comment">// NO1. 加载占位图片并且将图片放入&lt;img&gt;元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            myImg.setSrc(imgNode, src) <span class="comment">// NO3. 完成加载后, 更新 &lt;img&gt; 元素中的图片</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src <span class="comment">// NO2. 加载真正需要的图片</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>),</span><br><span class="line">    imgSrc =</span><br><span class="line">        <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/5486602-5cab95ba00b272bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(imgNode)</span><br><span class="line"></span><br><span class="line">proxyImg.setSrc(imgNode, imgSrc)</span><br></pre></td></tr></table></figure>

<p><strong><code>main.html</code> :</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- main.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>每天一个设计模式 · 代理模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://www.runoob.com/design-pattern/proxy-pattern.html">代理模式</a></li>
<li>  《JavaScript 设计模式和开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之桥接模式</title>
    <url>/2019/01/19/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/03.qiao-jie-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是桥接模式"><a href="#1-什么是桥接模式" class="headerlink" title="1. 什么是桥接模式"></a>1. 什么是桥接模式</h2><blockquote>
<p>桥接模式将抽象部分和具体实现部分<strong>分离</strong>，两者可独立变化，也可以一起工作。</p>
</blockquote>
<p>在这种模式的实现上，需要一个对象担任<strong>桥</strong>的角色，起到连接的作用。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>在封装开源库的组件时候，经常会用到这种设计模式。</p>
<p>例如，对外提供暴露一个<code>afterFinish</code>函数,<br>如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。</p>
<p>这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。</p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p>JavaScript 中桥接模式的典型应用是：<code>Array</code>对象上的<code>forEach</code>函数。</p>
<p>此函数负责循环遍历数组每个元素，是抽象部分；<br>而回调函数<code>callback</code>就是具体实现部分。</p>
<p>下方是模拟<code>forEach</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> forEach = <span class="function">(<span class="params">arr, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        callback(arr[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是测试代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">forEach(arr, <span class="function">(<span class="params">el, index</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;元素是&#x27;</span>, el, <span class="string">&#x27;位于&#x27;</span>, index))</span><br></pre></td></tr></table></figure>

<h3 id="3-2-python3-实现"><a href="#3-2-python3-实现" class="headerlink" title="3.2 python3 实现"></a>3.2 python3 实现</h3><p>和 Js 一样，这里也是模拟一个<code>for_each</code>函数：<br>它会循环遍历所有的元素，并且对每个元素执行指定的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> isfunction</span><br><span class="line"></span><br><span class="line"><span class="comment"># for_each 起到了“桥”的作用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_each</span>(<span class="params">arr, callback</span>):</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(arr, <span class="built_in">list</span>) == <span class="literal">False</span> <span class="keyword">or</span> isfunction(callback) == <span class="literal">False</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index, item) <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">    callback(item, index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体实现部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">item, index</span>):</span></span><br><span class="line">  print(<span class="string">&#x27;元素是&#x27;</span>, item, <span class="string">&#x27;; 它的位置是&#x27;</span>, index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  for_each(arr, callback)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之组合模式</title>
    <url>/2018/12/12/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/04.zu-he-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“组合模式”？"><a href="#1-什么是“组合模式”？" class="headerlink" title="1. 什么是“组合模式”？"></a>1. 什么是“组合模式”？</h2><blockquote>
<p>组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。</p>
</blockquote>
<ol>
<li>用小的子对象构造更大的父对象，而这些子对象也由更小的子对象构成</li>
<li><strong>单个对象和组合对象对于用户暴露的接口具有一致性</strong>，而同种接口不同表现形式亦体现了多态性</li>
</ol>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>组合模式可以在需要针对“树形结构”进行操作的应用中使用，例如扫描文件夹、渲染网站导航结构等等。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>这里用代码<strong>模拟文件扫描功能</strong>，封装了<code>File</code>和<code>Folder</code>两个类。在组合模式下，用户可以向<code>Folder</code>类嵌套<code>File</code>或者<code>Folder</code>来模拟真实的“文件目录”的树结构。</p>
<p>同时，两个类都对外提供了<code>scan</code>接口，<code>File</code>下的<code>scan</code>是扫描文件，<code>Folder</code>下的<code>scan</code>是调用子文件夹和子文件的<code>scan</code>方法。整个过程采用的是<strong>深度优先</strong>。</p>
<h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span>  <span class="comment"># 文件类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;扫描文件：&#x27;</span> + self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span>:</span>  <span class="comment"># 文件夹类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.files = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, file</span>):</span></span><br><span class="line">        self.files.append(file)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;扫描文件夹: &#x27;</span> + self.name)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.files:</span><br><span class="line">            item.scan()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    home = Folder(<span class="string">&quot;用户根目录&quot;</span>)</span><br><span class="line"></span><br><span class="line">    folder1 = Folder(<span class="string">&quot;第一个文件夹&quot;</span>)</span><br><span class="line">    folder2 = Folder(<span class="string">&quot;第二个文件夹&quot;</span>)</span><br><span class="line"></span><br><span class="line">    file1 = File(<span class="string">&quot;1号文件&quot;</span>)</span><br><span class="line">    file2 = File(<span class="string">&quot;2号文件&quot;</span>)</span><br><span class="line">    file3 = File(<span class="string">&quot;3号文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将文件添加到对应文件夹中</span></span><br><span class="line">    folder1.add(file1)</span><br><span class="line"></span><br><span class="line">    folder2.add(file2)</span><br><span class="line">    folder2.add(file3)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将文件夹添加到更高级的目录文件夹中</span></span><br><span class="line">    home.add(folder1)</span><br><span class="line">    home.add(folder2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 扫描目录文件夹</span></span><br><span class="line">    home.scan()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>$ python main.py</code>, 最终输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">扫描文件夹: 用户根目录</span><br><span class="line">扫描文件夹: 第一个文件夹</span><br><span class="line">扫描文件：1号文件</span><br><span class="line">扫描文件夹: 第二个文件夹</span><br><span class="line">扫描文件：2号文件</span><br><span class="line">扫描文件：3号文件</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ES6-实现"><a href="#3-2-ES6-实现" class="headerlink" title="3.2 ES6 实现"></a>3.2 ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&#x27;File&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;文件夹下面不能添加文件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;扫描文件: &#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件夹类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name || <span class="string">&#x27;Folder&#x27;</span></span><br><span class="line">        <span class="built_in">this</span>.files = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.files.push(file)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">scan</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;扫描文件夹: &#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> <span class="built_in">this</span>.files) &#123;</span><br><span class="line">            file.scan()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = <span class="keyword">new</span> Folder(<span class="string">&#x27;用户根目录&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> folder1 = <span class="keyword">new</span> Folder(<span class="string">&#x27;第一个文件夹&#x27;</span>),</span><br><span class="line">    folder2 = <span class="keyword">new</span> Folder(<span class="string">&#x27;第二个文件夹&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> file1 = <span class="keyword">new</span> File(<span class="string">&#x27;1号文件&#x27;</span>),</span><br><span class="line">    file2 = <span class="keyword">new</span> File(<span class="string">&#x27;2号文件&#x27;</span>),</span><br><span class="line">    file3 = <span class="keyword">new</span> File(<span class="string">&#x27;3号文件&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件添加到对应文件夹中</span></span><br><span class="line">folder1.add(file1)</span><br><span class="line"></span><br><span class="line">folder2.add(file2)</span><br><span class="line">folder2.add(file3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件夹添加到更高级的目录文件夹中</span></span><br><span class="line">home.add(folder1)</span><br><span class="line">home.add(folder2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描目录文件夹</span></span><br><span class="line">home.scan()</span><br></pre></td></tr></table></figure>

<p>执行<code>$ node main.js</code>，最终输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">扫描文件夹: 用户根目录</span><br><span class="line">扫描文件夹: 第一个文件夹</span><br><span class="line">扫描文件: 1号文件</span><br><span class="line">扫描文件夹: 第二个文件夹</span><br><span class="line">扫描文件: 2号文件</span><br><span class="line">扫描文件: 3号文件</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  《JavaScript 设计模式和开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之装饰者模式</title>
    <url>/2019/01/12/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/05.zhuang-shi-zhe-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“装饰者模式”？"><a href="#1-什么是“装饰者模式”？" class="headerlink" title="1. 什么是“装饰者模式”？"></a>1. 什么是“装饰者模式”？</h2><blockquote>
<p>装饰者模式：在<strong>不改变</strong>对象自身的基础上，<strong>动态</strong>地添加功能代码。</p>
</blockquote>
<p>根据描述，装饰者显然比继承等方式更灵活，而且<strong>不污染</strong>原来的代码，代码逻辑松耦合。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>装饰者模式由于松耦合，多用于一开始不确定对象的功能、或者对象功能经常变动的时候。<br>尤其是在<strong>参数检查</strong>、<strong>参数拦截</strong>等场景。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p>ES6 的装饰器语法规范只是在“提案阶段”，而且<strong>不能</strong>装饰普通函数或者箭头函数。</p>
<p>下面的代码，<code>addDecorator</code>可以为指定函数增加装饰器。</p>
<p>其中，装饰器的触发可以在函数运行之前，也可以在函数运行之后。</p>
<p><strong>注意</strong>：装饰器需要保存函数的运行结果，并且返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addDecorator = <span class="function">(<span class="params">fn, before, after</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isFn = <span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isFn(fn)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result</span><br><span class="line">        <span class="comment">// 按照顺序执行“装饰函数”</span></span><br><span class="line">        isFn(before) &amp;&amp; before(...args)</span><br><span class="line">        <span class="comment">// 保存返回函数结果</span></span><br><span class="line">        isFn(fn) &amp;&amp; (result = fn(...args))</span><br><span class="line">        isFn(after) &amp;&amp; after(...args)</span><br><span class="line">        <span class="comment">// 最后返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************以下是测试代码******************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> beforeHello = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Before Hello, args are <span class="subst">$&#123;args&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name = <span class="string">&#x27;user&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> afterHello = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`After Hello, args are <span class="subst">$&#123;args&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrappedHello = addDecorator(hello, beforeHello, afterHello)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = wrappedHello(<span class="string">&#x27;godbmw.com&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Python3-实现"><a href="#3-2-Python3-实现" class="headerlink" title="3.2 Python3 实现"></a>3.2 Python3 实现</h3><p>python 直接提供装饰器的语法支持。用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_without_args</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        print(<span class="string">&quot;args are %s, %s&quot;</span> % (args, kw))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_with_args</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            print(<span class="string">&quot;decorator&#x27;s arg is %s&quot;</span> % text)</span><br><span class="line">            print(<span class="string">&quot;args are %s, %s&quot;</span> % (args, kw))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_without_args</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call function now without args&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_with_args(&#x27;execute&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now2</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call function now2 with args&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    now1()</span><br><span class="line">    now2()</span><br></pre></td></tr></table></figure>

<p>其实 python 中的装饰器的实现，也是通过“闭包”实现的。</p>
<p>以上述代码中的<code>now1</code>函数为例，装饰器与下列语法等价：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ....</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;call function now without args&#x27;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">now_without_args = log_without_args(now1) <span class="comment"># 返回被装饰后的 now1 函数</span></span><br><span class="line">now_without_args() <span class="comment"># 输出与前面代码相同</span></span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://www.sitepoint.com/javascript-decorators-what-they-are/">JavaScript Decorators: What They Are and When to Use Them</a></li>
<li>  <a href="http://es6.ruanyifeng.com/#docs/decorator">《阮一峰 ES6-Decorator》</a></li>
<li>  <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000">《廖雪峰 python-Decorator》</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之适配器模式</title>
    <url>/2019/01/17/she-ji-mo-shi-shou-ce/02.jie-gou-xing-mo-shi/06.gua-pei-qi-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是适配器模式？"><a href="#1-什么是适配器模式？" class="headerlink" title="1. 什么是适配器模式？"></a>1. 什么是适配器模式？</h2><blockquote>
<p>适配器模式为多个不兼容接口之间提供“转化器”。</p>
</blockquote>
<p>它的实现非常<strong>简单</strong>，检查接口的数据，<br>进行过滤、重组等操作，使另一接口可以使用数据即可。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>当数据不符合使用规则，就可以借助此种模式进行格式转化。</p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><p>假设编写了不同平台的音乐爬虫，破解音乐数据。而对外向用户暴露的数据应该是具有一致性。</p>
<p>下面，<code>adapter</code>函数的作用就是转化数据格式。</p>
<p>因为，网易、QQ、虾米等平台的音乐数据不同，需要处理成一致的数据返回给用户，方便用户调用。</p>
<h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> API = &#123;</span><br><span class="line">    qq: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        n: <span class="string">&#x27;菊花台&#x27;</span>,</span><br><span class="line">        a: <span class="string">&#x27;周杰伦&#x27;</span>,</span><br><span class="line">        f: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    netease: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        name: <span class="string">&#x27;菊花台&#x27;</span>,</span><br><span class="line">        author: <span class="string">&#x27;周杰伦&#x27;</span>,</span><br><span class="line">        f: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> adapter = <span class="function">(<span class="params">info = &#123;&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    name: info.name || info.n,</span><br><span class="line">    author: info.author || info.a,</span><br><span class="line">    free: !!info.f,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************测试函数***************/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adapter(API.qq()))</span><br><span class="line"><span class="built_in">console</span>.log(adapter(API.netease()))</span><br></pre></td></tr></table></figure>

<h3 id="3-2-python-实现"><a href="#3-2-python-实现" class="headerlink" title="3.2 python 实现"></a>3.2 python 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qq_music_info</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>: <span class="string">&quot;菊花台&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="string">&quot;周杰伦&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">netease_music_info</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;菊花台&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;author&#x27;</span>: <span class="string">&quot;周杰伦&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;f&#x27;</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapter</span>(<span class="params">info</span>):</span></span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    result[<span class="string">&#x27;name&#x27;</span>] = info[<span class="string">&quot;name&quot;</span>] <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> info <span class="keyword">else</span> info[<span class="string">&#x27;n&#x27;</span>]</span><br><span class="line">    result[<span class="string">&#x27;author&#x27;</span>] = info[<span class="string">&#x27;author&#x27;</span>] <span class="keyword">if</span> <span class="string">&#x27;author&#x27;</span> <span class="keyword">in</span> info <span class="keyword">else</span> info[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    result[<span class="string">&#x27;free&#x27;</span>] = <span class="keyword">not</span> <span class="keyword">not</span> info[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(adapter(qq_music_info()))</span><br><span class="line">    print(adapter(netease_music_info()))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之命令模式</title>
    <url>/2018/11/25/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/01.ming-ling-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“命令模式”？"><a href="#1-什么是“命令模式”？" class="headerlink" title="1. 什么是“命令模式”？"></a>1. 什么是“命令模式”？</h2><blockquote>
<p>命令模式是一种数据驱动的设计模式，它属于行为型模式。</p>
</blockquote>
<ol>
<li>请求以命令的形式包裹在对象中，并传给调用对象。</li>
<li>调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象。</li>
<li>该对象执行命令。</li>
</ol>
<p>在这三步骤中，分别有 3 个不同的主体：<strong>发送者、传递者和执行者</strong>。在实现过程中，需要特别关注。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>有时候需要向某些对象发送请求，但是又不知道请求的接受者是谁，更不知道被请求的操作是什么。此时，<strong>命令模式就是以一种松耦合的方式来设计程序</strong>。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><p>命令对象将动作的接收者设置在属性中，并且对外暴露了<code>execute</code>接口（按照习惯约定）。</p>
<p>在其他类设置命令并且执行命令的时候，只需要按照约定调用<code>Command</code>对象的<code>execute()</code>即可。到底是谁接受命令，并且怎么执行命令，都交给<code>Command</code>对象来处理！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__author__ = <span class="string">&#x27;godbmw.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受到命令，执行具体操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;按钮按下，执行操作&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, receiver</span>):</span></span><br><span class="line">    self.receiver = receiver</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.receiver.action()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体业务类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.command = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 设置命令对戏那个</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_command</span>(<span class="params">self, command</span>):</span></span><br><span class="line">    self.command = command</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 按下按钮，交给命令对象调用相关函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">down</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.command:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    self.command.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">  receiver = Receiver()</span><br><span class="line"></span><br><span class="line">  command = Command(receiver)</span><br><span class="line"></span><br><span class="line">  button = Button()</span><br><span class="line">  button.set_command(command)</span><br><span class="line">  button.down()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ES6-实现"><a href="#3-2-ES6-实现" class="headerlink" title="3.2 ES6 实现"></a>3.2 ES6 实现</h3><p><code>setCommand</code>方法为按钮指定了命令对象，命令对象为调用者（按钮）找到了接收者（<code>MenuBar</code>），并且执行了相关操作。<strong>而按钮本身并不需要关心接收者和接受操作</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受到命令，执行相关操作</span></span><br><span class="line"><span class="keyword">const</span> MenuBar = &#123;</span><br><span class="line">    <span class="function"><span class="title">refresh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;刷新菜单页面&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令对象，execute方法就是执行相关命令</span></span><br><span class="line"><span class="keyword">const</span> RefreshMenuBarCommand = <span class="function">(<span class="params">receiver</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            receiver.refresh()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为按钮对象指定对应的 对象</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function">(<span class="params">button, command</span>) =&gt;</span> &#123;</span><br><span class="line">    button.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        command.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar)</span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">setCommand(button, refreshMenuBarCommand)</span><br></pre></td></tr></table></figure>

<p>下面是同级目录的 html 代码，在谷歌浏览器中打开创建的<code>index.html</code>，并且打开控制台，即可看到效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>命令模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  《JavaScript 设计模式和开发实践》</li>
<li>  <a href="https://www.yiibai.com/python_design_patterns/python_design_patterns_command.html">如何实现命令模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之模板模式</title>
    <url>/2019/01/31/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/03.mo-ban-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是模板模式？"><a href="#1-什么是模板模式？" class="headerlink" title="1. 什么是模板模式？"></a>1. 什么是模板模式？</h2><blockquote>
<p>模板模式是抽象父类定义了子类需要重写的相关方法。<br>而这些方法，仍然是通过<strong>父类方法调用</strong>的。</p>
</blockquote>
<p>根据描述，“模板”的思想体现在：父类定义的接口方法。</p>
<p>除此之外，子类方法的调用，也是被父类控制的。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>一些系统的架构或者算法骨架，由“BOSS”编写抽象方法，具体的实现，交给“小弟们”实现。</p>
<p>而绝对是不是用“小弟们”的方法，还是看“BOSS”的心情。</p>
<p><strong>不是很恰当的比喻哈~</strong></p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p><code>Animal</code>是抽象类，<code>Dog</code>和<code>Cat</code>分别具体实现了<code>eat()</code>和<code>sleep()</code>方法。</p>
<p><code>Dog</code>或<code>Cat</code>实例可以通过<code>live()</code>方法调用<code>eat()</code>和<code>sleep()</code>。</p>
<p><strong>注意</strong>：<code>Cat</code>和<code>Dog</code>实例会被<strong>自动添加</strong><code>live()</code>方法。不暴露<code>live()</code>是为了防止<code>live()</code>被子类重写，保证父类的<strong>控制权</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// this 指向实例</span></span><br><span class="line">        <span class="built_in">this</span>.live = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.eat()</span><br><span class="line">            <span class="built_in">this</span>.sleep()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;模板类方法必须被重写&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;模板类方法必须被重写&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;狗吃粮&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;狗睡觉&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;猫吃粮&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;猫睡觉&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********* 以下为测试代码 ********/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时, Animal中的this指向dog</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.live()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时, Animal中的this指向cat</span></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line">cat.live()</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://www.cnblogs.com/TomXu/archive/2012/04/13/2436371.html">ES5 实现</a>：ES5 的实现更方便些</li>
<li>  <a href="http://www.alloyteam.com/2012/10/commonly-javascript-design-patterns-template-method-pattern/">《JavaScript 设计模式 10》模板方法模式</a></li>
<li>  《JavaScript 设计模式》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之备忘录模式</title>
    <url>/2019/01/26/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/02.bei-wang-lu-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是备忘录模式"><a href="#1-什么是备忘录模式" class="headerlink" title="1. 什么是备忘录模式"></a>1. 什么是备忘录模式</h2><blockquote>
<p>它属于行为模式，保存某个状态，并且在<strong>需要</strong>的时候直接获取，而不是<strong>重复计算</strong>。</p>
</blockquote>
<p><strong>注意</strong>：备忘录模式实现，不能破坏原始封装。<br>也就是说，能拿到内部状态，将其保存在外部。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>最典型的例子是“斐波那契数列”递归实现。<br>不借助备忘录模式，数据一大，就容易爆栈；借助备忘录，算法的时间复杂度可以降低到$ O(N) $</p>
<p>除此之外，数据的缓存等也是常见应用场景。</p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p>首先模拟了一下简单的拉取分页数据。<br>如果当前数据没有被缓存，那么就模拟异步请求，并将结果放入缓存中；<br>如果已经缓存过，那么立即取出即可，无需多次请求。</p>
<p><strong>main.js</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录 / 缓存</span></span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">page</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果页面数据已经被缓存, 直接取出</span></span><br><span class="line">            <span class="keyword">if</span> (page <span class="keyword">in</span> cache) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(cache[page])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则, 异步请求页面数据</span></span><br><span class="line">            <span class="comment">// 此处, 仅仅是模拟异步请求</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                cache[page] = <span class="string">`内容是<span class="subst">$&#123;page&#125;</span>`</span></span><br><span class="line">                resolve(cache[page])</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是测试代码</span></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),</span><br><span class="line">        now</span><br><span class="line">    <span class="comment">// 第一次: 没有缓存</span></span><br><span class="line">    <span class="keyword">await</span> fetchData(<span class="number">1</span>)</span><br><span class="line">    now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`没有缓存, 耗时<span class="subst">$&#123;now - start&#125;</span>ms`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次: 有缓存 / 备忘录有记录</span></span><br><span class="line">    start = now</span><br><span class="line">    <span class="keyword">await</span> fetchData(<span class="number">1</span>)</span><br><span class="line">    now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`有缓存, 耗时<span class="subst">$&#123;now - start&#125;</span>ms`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>最近在项目中还遇到一个场景，在<code>React</code>中加载微信登陆二维码。<br>这需要编写一个插入<code>script</code>标签的函数。</p>
<p>要考虑的情况是：</p>
<ol>
<li>同一个<code>script</code>标签不能被多次加载</li>
<li>对于加载错误，要正确处理</li>
<li>对于几乎同时触发加载函数的情况, 应该考虑锁住</li>
</ol>
<p>基于此，<strong>main2.js</strong>文件编码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录模式: 防止重复加载</span></span><br><span class="line"><span class="keyword">const</span> loadScript = <span class="function">(<span class="params">src</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> exists = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (exists) <span class="keyword">return</span> resolve()</span><br><span class="line">            <span class="comment">// 防止没有触发下方的onload时候, 又调用此函数重复加载</span></span><br><span class="line">            exists = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 开始加载</span></span><br><span class="line">            <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">            script.src = src</span><br><span class="line">            script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line">            script.onerror = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 加载失败: 允许外部再次加载</span></span><br><span class="line">                script.remove()</span><br><span class="line">                exists = <span class="literal">false</span></span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Load Error&#x27;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            script.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 加载成功: exists一直为true, 不会多次加载</span></span><br><span class="line">                resolve()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************** 测试代码 **************/</span></span><br><span class="line"><span class="comment">// 专门用于加载微信SDK的代码</span></span><br><span class="line"><span class="keyword">const</span> wxLoader = loadScript(<span class="string">&#x27;https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.jser&#x27;</span>)</span><br><span class="line"><span class="comment">// html中只有1个微信脚本</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    wxLoader()</span><br><span class="line">        .then()</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(error.message))</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>在<code>index2.html</code>中引入上述代码，即可查看效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-python3-实现"><a href="#3-2-python3-实现" class="headerlink" title="3.2 python3 实现"></a>3.2 python3 实现</h3><p>这里实现一下借助“备忘录模式”优化过的、递归写法的“斐波那契数列”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">  <span class="comment"># 结果缓存</span></span><br><span class="line">  mem = &#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_fibonacci</span>(<span class="params">_n</span>):</span></span><br><span class="line">    <span class="comment"># 是否缓存</span></span><br><span class="line">    <span class="keyword">if</span> _n <span class="keyword">in</span> mem:</span><br><span class="line">      <span class="keyword">return</span> mem[_n]</span><br><span class="line">    mem[_n] = _fibonacci(_n - <span class="number">1</span>) + _fibonacci(_n - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mem[_n]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _fibonacci(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  print(fibonacci(<span class="number">999</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之状态模式</title>
    <url>/2019/01/16/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/04.zhuang-tai-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“状态模式”？"><a href="#1-什么是“状态模式”？" class="headerlink" title="1. 什么是“状态模式”？"></a>1. 什么是“状态模式”？</h2><blockquote>
<p>状态模式：对象行为是<strong>基于状态</strong>来改变的。</p>
</blockquote>
<p>内部的状态转化，导致了行为表现形式不同。<br>所以，用户在外面看起来，<strong>好像</strong>是修改了行为。</p>
<h2 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h2><p><strong>优点</strong></p>
<p>封装了转化规则，对于大量<strong>分支语句</strong>，可以考虑使用状态类进一步封装。<br>每个状态都是确定的，所以对象行为是可控的。</p>
<p><strong>缺点</strong></p>
<p>状态模式的<strong>关键</strong>是将事物的状态都封装成单独的类，这个类的各种方法就是“此种状态对应的表现行为”。<br>因此，状态类会增加<strong>程序开销</strong>。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p>在 JavaScript 中，可以直接用 JSON 对象来代替状态类。</p>
<p>下面代码展示的就是 FSM（有限状态机）里面有 3 种状态：<code>download</code>、<code>pause</code>、<code>deleted</code>。<br>控制状态转化的代码也在其中。</p>
<p><code>DownLoad</code>类就是，常说的<code>Context</code>对象，它的行为会随着状态的改变而改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FSM = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currenState = <span class="string">&#x27;download&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        download: &#123;</span><br><span class="line">            click: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;暂停下载&#x27;</span>)</span><br><span class="line">                currenState = <span class="string">&#x27;pause&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            del: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;先暂停, 再删除&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        pause: &#123;</span><br><span class="line">            click: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;继续下载&#x27;</span>)</span><br><span class="line">                currenState = <span class="string">&#x27;download&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            del: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;删除任务&#x27;</span>)</span><br><span class="line">                currenState = <span class="string">&#x27;deleted&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        deleted: &#123;</span><br><span class="line">            click: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;任务已删除, 请重新开始&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            del: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;任务已删除&#x27;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        getState: <span class="function">() =&gt;</span> currenState,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Download</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">fsm</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fsm = fsm</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; fsm &#125; = <span class="built_in">this</span></span><br><span class="line">        fsm[fsm.getState()].click()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hanldeDel</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; fsm &#125; = <span class="built_in">this</span></span><br><span class="line">        fsm[fsm.getState()].del()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始下载</span></span><br><span class="line"><span class="keyword">let</span> download = <span class="keyword">new</span> Download(FSM)</span><br><span class="line"></span><br><span class="line">download.handleClick() <span class="comment">// 暂停下载</span></span><br><span class="line">download.handleClick() <span class="comment">// 继续下载</span></span><br><span class="line">download.hanldeDel() <span class="comment">// 下载中，无法执行删除操作</span></span><br><span class="line">download.handleClick() <span class="comment">// 暂停下载</span></span><br><span class="line">download.hanldeDel() <span class="comment">// 删除任务</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Python3-实现"><a href="#3-2-Python3-实现" class="headerlink" title="3.2 Python3 实现"></a>3.2 Python3 实现</h3><p>python 的代码采用的是“面向对象”的编程，没有过度使用函数式的闭包写法（python 写起来也不难）。</p>
<p>因此，负责状态转化的类，专门拿出来单独封装。<br>其他 3 个状态类的状态，均由这个状态类来管理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负责状态转化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateTransform</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__state = <span class="string">&#x27;download&#x27;</span></span><br><span class="line">    self.__states = [<span class="string">&#x27;download&#x27;</span>, <span class="string">&#x27;pause&#x27;</span>, <span class="string">&#x27;deleted&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, to_state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> to_state) <span class="keyword">or</span> (to_state <span class="keyword">not</span> <span class="keyword">in</span> self.__states) :</span><br><span class="line">      <span class="keyword">raise</span> Exception(<span class="string">&#x27;state is unvalid&#x27;</span>)</span><br><span class="line">    self.__state = to_state</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_state</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__state</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是三个状态类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadState</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, transfomer</span>):</span></span><br><span class="line">    self.__state = <span class="string">&#x27;download&#x27;</span></span><br><span class="line">    self.__transfomer = transfomer</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;暂停下载&#x27;</span>)</span><br><span class="line">    self.__transfomer.change(<span class="string">&#x27;pause&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;先暂停, 再删除&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseState</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, transfomer</span>):</span></span><br><span class="line">    self.__state = <span class="string">&#x27;pause&#x27;</span></span><br><span class="line">    self.__transfomer = transfomer</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;继续下载&#x27;</span>)</span><br><span class="line">    self.__transfomer.change(<span class="string">&#x27;download&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;删除任务&#x27;</span>)</span><br><span class="line">    self.__transfomer.change(<span class="string">&#x27;deleted&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeletedState</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, transfomer</span>):</span></span><br><span class="line">    self.__state = <span class="string">&#x27;deleted&#x27;</span></span><br><span class="line">    self.__transfomer = transfomer</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">click</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;任务已删除, 请重新开始&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;任务已删除&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 业务代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Download</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.state_transformer = StateTransform()</span><br><span class="line">    self.state_map = &#123;</span><br><span class="line">      <span class="string">&#x27;download&#x27;</span>: DownloadState(self.state_transformer),</span><br><span class="line">      <span class="string">&#x27;pause&#x27;</span>: PauseState(self.state_transformer),</span><br><span class="line">      <span class="string">&#x27;deleted&#x27;</span>: DeletedState(self.state_transformer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_click</span>(<span class="params">self</span>):</span></span><br><span class="line">    state = self.state_transformer.get_state()</span><br><span class="line">    self.state_map[state].click()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handle_del</span>(<span class="params">self</span>):</span></span><br><span class="line">    state = self.state_transformer.get_state()</span><br><span class="line">    self.state_map[state].delete()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  download = Download()</span><br><span class="line">  download.handle_click(); <span class="comment"># 暂停下载</span></span><br><span class="line">  download.handle_click(); <span class="comment"># 继续下载</span></span><br><span class="line">  download.handle_del(); <span class="comment"># 下载中，无法执行删除操作</span></span><br><span class="line">  download.handle_click(); <span class="comment"># 暂停下载</span></span><br><span class="line">  download.handle_del(); <span class="comment"># 删除任务</span></span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://www.cnblogs.com/geek6/p/3951677.html">23 种设计模式全解析</a></li>
<li>  <a href="http://www.runoob.com/design-pattern/state-pattern.html">菜鸟教程状态模式</a></li>
<li>  《JavaScript 设计模式与开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之策略模式</title>
    <url>/2018/10/25/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/05.ce-lue-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是策略模式？"><a href="#1-什么是策略模式？" class="headerlink" title="1. 什么是策略模式？"></a>1. 什么是策略模式？</h2><blockquote>
<p>策略模式定义：就是能够把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。</p>
</blockquote>
<p><strong>策略模式实现的核心就是：将算法的使用和算法的实现分离。</strong>算法的实现交给策略类。算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。</p>
<h2 id="2-策略模式优缺点"><a href="#2-策略模式优缺点" class="headerlink" title="2. 策略模式优缺点"></a>2. 策略模式优缺点</h2><p>在使用策略模式的时候，需要了解所有的“策略”（strategy）之间的异同点，才能选择合适的“策略”进行调用。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stragegy</span>():</span></span><br><span class="line">  <span class="comment"># 子类必须实现 interface 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interface</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 策略A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StragegyA</span>():</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interface</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;This is stragegy A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 策略B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StragegyB</span>():</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interface</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;This is stragegy B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境类：根据用户传来的不同的策略进行实例化，并调用相关算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>():</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, stragegy</span>):</span></span><br><span class="line">    self.__stragegy = stragegy()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 更新策略</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_stragegy</span>(<span class="params">self, stragegy</span>):</span></span><br><span class="line">    self.__stragegy = stragegy()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 调用算法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">interface</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.__stragegy.interface()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  <span class="comment"># 使用策略A的算法</span></span><br><span class="line">  cxt = Context( StragegyA )</span><br><span class="line">  cxt.interface()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用策略B的算法</span></span><br><span class="line">  cxt.update_stragegy( StragegyB )</span><br><span class="line">  cxt.interface()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-javascript-实现"><a href="#3-2-javascript-实现" class="headerlink" title="3.2 javascript 实现"></a>3.2 javascript 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略类</span></span><br><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">    <span class="function"><span class="title">A</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;This is stragegy A&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">B</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;This is stragegy B&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[name]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用策略A</span></span><br><span class="line">context(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用策略B</span></span><br><span class="line">context(<span class="string">&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://zhuanlan.zhihu.com/p/30576518">策略模式-Python 四种实现方式</a></li>
<li>  《JavaScript 设计模式和开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之解释器模式</title>
    <url>/2019/01/25/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/06.jie-shi-qi-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“解释器模式？"><a href="#1-什么是“解释器模式？" class="headerlink" title="1. 什么是“解释器模式？"></a>1. 什么是“解释器模式？</h2><blockquote>
<p>解释器模式: 提供了评估语言的<strong>语法</strong>或<strong>表达式</strong>的方式。</p>
</blockquote>
<p>这是基本<strong>不怎么使用</strong>的一种设计模式。<br>确实想不到什么场景一定要用此种设计模式。</p>
<p>实现这种模式的<strong>核心</strong>是：</p>
<ol>
<li>抽象表达式：主要有一个<code>interpret()</code>操作</li>
</ol>
<ul>
<li>  终结符表达式：<code>R = R1 + R2</code>中，<code>R1</code> <code>R2</code>就是终结符</li>
<li>  非终结符表达式：<code>R = R1 - R2</code>中，<code>-</code>就是终结符</li>
</ul>
<ol start="2">
<li>环境(Context): <strong>存放</strong>文法中各个<strong>终结符</strong>所对应的具体值。比如前面<code>R1</code>和<code>R2</code>的值。</li>
</ol>
<h2 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h2><p><strong>优点</strong>显而易见，每个<strong>文法规则</strong>可以表述为一个类或者方法。<br>这些文法互相不干扰，符合“开闭原则”。</p>
<p>由于每条文法都需要构建一个类或者方法，文法数量上去后，<strong>很难维护</strong>。<br>并且，语句的执行<strong>效率低</strong>（一直在不停地互相调用）。</p>
<h2 id="3-多语言实现"><a href="#3-多语言实现" class="headerlink" title="3. 多语言实现"></a>3. 多语言实现</h2><h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><p>为了方便说明，下面省略了“抽象表达式”的实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._list = [] <span class="comment">// 存放 终结符表达式</span></span><br><span class="line">        <span class="built_in">this</span>._sum = <span class="number">0</span> <span class="comment">// 存放 非终结符表达式(运算结果)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">sum</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">sum</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._sum = newValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">expression</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._list.push(expression)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">list</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> [...this._list]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">interpret</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;TypeError&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        context.sum = ++context.sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinusExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">interpret</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Context)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;TypeError&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        context.sum = --context.sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以下是测试代码 **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> Context()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次添加: 加法 | 加法 | 减法 表达式</span></span><br><span class="line">context.add(<span class="keyword">new</span> PlusExpression())</span><br><span class="line">context.add(<span class="keyword">new</span> PlusExpression())</span><br><span class="line">context.add(<span class="keyword">new</span> MinusExpression())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次执行: 加法 | 加法 | 减法 表达式</span></span><br><span class="line">context.list.forEach(<span class="function">(<span class="params">expression</span>) =&gt;</span> expression.interpret(context))</span><br><span class="line"><span class="built_in">console</span>.log(context.sum)</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="http://www.runoob.com/design-pattern/interpreter-pattern.html">菜鸟教程–解释器模式</a></li>
<li>  <a href="https://blog.csdn.net/yanbober/article/details/45537601">@工匠若水</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之订阅-发布模式</title>
    <url>/2018/11/18/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/07.ding-yue-fa-bu-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“订阅-发布模式”？"><a href="#1-什么是“订阅-发布模式”？" class="headerlink" title="1. 什么是“订阅-发布模式”？"></a>1. 什么是“订阅-发布模式”？</h2><blockquote>
<p>订阅-发布模式定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都可以得到通知。</p>
</blockquote>
<p>了解过事件机制或者函数式编程的朋友，应该会体会到“订阅-发布模式”所带来的“<strong>时间解耦</strong>”和“<strong>空间解耦</strong>”的优点。借助函数式编程中闭包和回调的概念，可以很优雅地实现这种设计模式。</p>
<h2 id="2-“订阅-发布模式”-vs-观察者模式"><a href="#2-“订阅-发布模式”-vs-观察者模式" class="headerlink" title="2. “订阅-发布模式” vs 观察者模式"></a>2. “订阅-发布模式” vs 观察者模式</h2><p>订阅-发布模式和观察者模式概念相似，但在订阅-发布模式中，订阅者和发布者之间多了一层中间件：一个被抽象出来的信息调度中心。</p>
<p>但其实没有必要太深究 2 者区别，因为《Head First 设计模式》这本经典书都写了：<strong>发布+订阅=观察者模式</strong>。<strong>其核心思想是状态改变和发布通知。</strong>在此基础上，根据语言特性，进行实现即可。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><p>python 中我们定义一个事件类<code>Event</code>, 并且为它提供 事件监听函数、（事件完成后）触发函数，以及事件移除函数。任何类都可以通过继承这个通用事件类，来实现“订阅-发布”功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.client_list = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">listen</span>(<span class="params">self, key, fn</span>):</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.client_list:</span><br><span class="line">      self.client_list[key] = []</span><br><span class="line">    self.client_list[key].append(fn)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">trigger</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">    fns = self.client_list[args[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    length = <span class="built_in">len</span>(fns)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fns <span class="keyword">or</span> length == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> fns:</span><br><span class="line">      fn(*args[<span class="number">1</span>:], **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, key, fn</span>):</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.client_list <span class="keyword">or</span> <span class="keyword">not</span> fn:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    fns = self.client_list[key]</span><br><span class="line">    length = <span class="built_in">len</span>(fns)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _fn <span class="keyword">in</span> fns:</span><br><span class="line">      <span class="keyword">if</span> _fn == fn:</span><br><span class="line">        fns.remove(_fn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助继承为对象安装 发布-订阅 功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOffice</span>(<span class="params">Event</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据自己需求定义一个函数：供事件处理完后调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_event</span>(<span class="params">event_name</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_handle_event</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Price is&quot;</span>, *args, <span class="string">&quot;at&quot;</span>, event_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _handle_event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  <span class="comment"># 创建2个回调函数</span></span><br><span class="line">  fn1 = handle_event(<span class="string">&quot;event01&quot;</span>)</span><br><span class="line">  fn2 = handle_event(<span class="string">&quot;event02&quot;</span>)</span><br><span class="line"></span><br><span class="line">  sales_office = SalesOffice()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 订阅event01 和 event02 这2个事件，并且绑定相关的 完成后的函数</span></span><br><span class="line">  sales_office.listen(<span class="string">&quot;event01&quot;</span>, fn1)</span><br><span class="line">  sales_office.listen(<span class="string">&quot;event02&quot;</span>, fn2)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 当两个事件完成时候，触发前几行绑定的相关函数</span></span><br><span class="line">  sales_office.trigger(<span class="string">&quot;event01&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">  sales_office.trigger(<span class="string">&quot;event02&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">  sales_office.remove(<span class="string">&quot;event01&quot;</span>, fn1)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 打印：False</span></span><br><span class="line">  print(sales_office.trigger(<span class="string">&quot;event01&quot;</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ES6-实现"><a href="#3-2-ES6-实现" class="headerlink" title="3.2 ES6 实现"></a>3.2 ES6 实现</h3><p>JS 中一般用事件模型来代替传统的发布-订阅模式。任何一个对象的原型链被指向<code>Event</code>的时候，这个对象便可以绑定自定义事件和对应的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Event = &#123;</span><br><span class="line">    clientList: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定事件监听</span></span><br><span class="line">    <span class="function"><span class="title">listen</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.clientList[key]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.clientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.clientList[key].push(fn)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发对应事件</span></span><br><span class="line">    <span class="function"><span class="title">trigger</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">Array</span>.prototype.shift.apply(<span class="built_in">arguments</span>),</span><br><span class="line">            fns = <span class="built_in">this</span>.clientList[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fns || fns.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> fns) &#123;</span><br><span class="line">            fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除相关事件</span></span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="built_in">this</span>.clientList[key]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前没有绑定事件</span></span><br><span class="line">        <span class="comment">// 或者没有指明要移除的事件</span></span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!fns || !fn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历移除置指定事件函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">let</span> _fn = fns[l]</span><br><span class="line">            <span class="keyword">if</span> (_fn === fn) &#123;</span><br><span class="line">                fns.splice(l, <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为对象动态安装 发布-订阅 功能</span></span><br><span class="line"><span class="keyword">const</span> installEvent = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> Event) &#123;</span><br><span class="line">        obj[key] = Event[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> salesOffices = &#123;&#125;</span><br><span class="line">installEvent(salesOffices)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定自定义事件和回调函数</span></span><br><span class="line"></span><br><span class="line">salesOffices.listen(</span><br><span class="line">    <span class="string">&#x27;event01&#x27;</span>,</span><br><span class="line">    (fn1 = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Price is&#x27;</span>, price, <span class="string">&#x27;at event01&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">salesOffices.listen(</span><br><span class="line">    <span class="string">&#x27;event02&#x27;</span>,</span><br><span class="line">    (fn2 = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Price is&#x27;</span>, price, <span class="string">&#x27;at event02&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;event01&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">salesOffices.trigger(<span class="string">&#x27;event02&#x27;</span>, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">salesOffices.remove(<span class="string">&#x27;event01&#x27;</span>, fn1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: false</span></span><br><span class="line"><span class="comment">// 说明删除成功</span></span><br><span class="line"><span class="built_in">console</span>.log(salesOffices.trigger(<span class="string">&#x27;event01&#x27;</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">维基百科·订阅-发布模式</a></li>
<li>  <a href="https://www.zhihu.com/question/23486749">观察者模式和订阅-发布模式的不同</a></li>
<li>  《JavaScript 设计模式和开发实践》</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之责任链模式</title>
    <url>/2019/01/07/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/08.ze-ren-lian-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是“责任链模式”？"><a href="#1-什么是“责任链模式”？" class="headerlink" title="1. 什么是“责任链模式”？"></a>1. 什么是“责任链模式”？</h2><blockquote>
<p>责任链模式：多个对象均有机会处理请求，从而<strong>解除</strong>发送者和接受者之间的耦合关系。这些对象连接成为<strong>链式结构</strong>，每个节点转发请求，直到有对象处理请求为止。</p>
</blockquote>
<p>其核心就是：<strong>请求者不必知道是谁哪个节点对象处理的请求</strong>。如果当前不符合终止条件，那么把请求转发给下一个节点处理。</p>
<p>而当需求具有“传递”的性质时（代码中其中一种体现就是：多个<code>if、else if、else if、else</code>嵌套），就可以考虑将每个分支拆分成一个节点对象，拼接成为责任链。</p>
<h2 id="2-优点与代价"><a href="#2-优点与代价" class="headerlink" title="2. 优点与代价"></a>2. 优点与代价</h2><ul>
<li>优点<ul>
<li>  可以根据需求变动，任意向责任链中添加 / 删除节点对象</li>
<li>  没有固定的“开始节点”，可以从任意节点开始</li>
</ul>
</li>
<li>  代价：<strong>责任链最大的代价就是每个节点带来的多余消耗</strong>。当责任链过长，很多节点只有传递的作用，而不是真正地处理逻辑。</li>
</ul>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><p>为了方便演示，模拟常见的“日志打印”场景。模拟了 3 种级别的日志输出：</p>
<ul>
<li>  <code>LogHandler</code>: 普通日志</li>
<li>  <code>WarnHandler</code>：警告日志</li>
<li>  <code>ErrorHandler</code>：错误日志</li>
</ul>
<p>首先我们会构造“责任链”：<code>LogHandler</code> -&gt; <code>WarnHandler</code> -&gt; <code>ErrorHandler</code>。<code>LogHandler</code>作为链的开始节点。</p>
<p>如果是普通日志，那么就由 <code>LogHandler</code> 处理，停止传播；如果是 Warn 级别的日志，那么 <code>LogHandler</code> 就会自动向下传递，<code>WarnHandler</code> 接收到并且处理，停止传播；Error 级别日志同理。</p>
<h3 id="3-1-ES6-实现"><a href="#3-1-ES6-实现" class="headerlink" title="3.1 ES6 实现"></a>3.1 ES6 实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">setNext</span>(<span class="params">handler</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = handler</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...props)</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;log&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params">level, msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level === <span class="built_in">this</span>.name) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`LOG: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.next &amp;&amp; <span class="built_in">this</span>.next.handle(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...props)</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;warn&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params">level, msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level === <span class="built_in">this</span>.name) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`WARN: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.next &amp;&amp; <span class="built_in">this</span>.next.handle(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">...props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(...props)</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params">level, msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (level === <span class="built_in">this</span>.name) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`ERROR: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.next &amp;&amp; <span class="built_in">this</span>.next.handle(...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************以下是测试代码******************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logHandler = <span class="keyword">new</span> LogHandler()</span><br><span class="line"><span class="keyword">let</span> warnHandler = <span class="keyword">new</span> WarnHandler()</span><br><span class="line"><span class="keyword">let</span> errorHandler = <span class="keyword">new</span> ErrorHandler()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置下一个处理的节点</span></span><br><span class="line">logHandler.setNext(warnHandler)</span><br><span class="line">warnHandler.setNext(errorHandler)</span><br><span class="line"></span><br><span class="line">logHandler.handle(<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;Some error occur&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Python3-实现"><a href="#3-2-Python3-实现" class="headerlink" title="3.2 Python3 实现"></a>3.2 Python3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_next</span>(<span class="params">self, handler</span>):</span></span><br><span class="line">        self.<span class="built_in">next</span> = handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.__name = <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self, level, msg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == self.__name:</span><br><span class="line">            print(<span class="string">&#x27;LOG: &#x27;</span>, msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            self.<span class="built_in">next</span>.handle(level, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WarnHandler</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.__name = <span class="string">&quot;warn&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self, level, msg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == self.__name:</span><br><span class="line">            print(<span class="string">&#x27;WARN: &#x27;</span>, msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            self.<span class="built_in">next</span>.handle(level, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorHandler</span>(<span class="params">Handler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.__name = <span class="string">&quot;error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self, level, msg</span>):</span></span><br><span class="line">        <span class="keyword">if</span> level == self.__name:</span><br><span class="line">            print(<span class="string">&#x27;ERROR: &#x27;</span>, msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            self.<span class="built_in">next</span>.handle(level, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是测试代码</span></span><br><span class="line">log_handler = LogHandler()</span><br><span class="line">warn_handler = WarnHandler()</span><br><span class="line">error_handler = ErrorHandler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置下一个处理的节点</span></span><br><span class="line">log_handler.set_next(warn_handler)</span><br><span class="line">warn_handler.set_next(error_handler)</span><br><span class="line"></span><br><span class="line">log_handler.handle(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Some error occur&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul>
<li>  《JavaScript 设计模式和开发实践》</li>
<li>  <a href="https://www.cnblogs.com/editor/p/5679552.html">javascript 之 责任链模式</a></li>
<li>  <a href="https://www.yiibai.com/python_design_patterns/python_design_patterns_chain_of_responsibility.html">职责链模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式手册之迭代器模式</title>
    <url>/2018/11/06/she-ji-mo-shi-shou-ce/03.xing-wei-xing-mo-shi/09.die-dai-qi-mo-shi/</url>
    <content><![CDATA[<h2 id="1-什么是迭代器模式？"><a href="#1-什么是迭代器模式？" class="headerlink" title="1. 什么是迭代器模式？"></a>1. 什么是迭代器模式？</h2><blockquote>
<p>迭代器模式是指提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现。</p>
</blockquote>
<h2 id="2-内部迭代器和外部迭代器"><a href="#2-内部迭代器和外部迭代器" class="headerlink" title="2. 内部迭代器和外部迭代器"></a>2. 内部迭代器和外部迭代器</h2><p>内部迭代器：封装的方法完全接手迭代过程，外部只需要一次调用。</p>
<p>外部迭代器：用户必须显式地请求迭代下一元素。熟悉 C++的朋友，可以类比 C++内置对象的迭代器的 <code>end()</code>、<code>next()</code>等方法。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-python3-实现"><a href="#3-1-python3-实现" class="headerlink" title="3.1 python3 实现"></a>3.1 python3 实现</h3><p>python3 的迭代器可以用作<code>for()</code>循环和<code>next()</code>方法的对象。同时，在实现迭代器的时候，可以在借助生成器<code>yield</code>。python 会生成传给<code>yeild</code>的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_iter</span>():</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">0</span>, <span class="string">&quot;first&quot;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>, <span class="string">&quot;second&quot;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>, <span class="string">&quot;third&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  <span class="comment"># 方法1: Iterator可以用for循环</span></span><br><span class="line">  <span class="keyword">for</span> (index, item) <span class="keyword">in</span> my_iter():</span><br><span class="line">    print(<span class="string">&quot;At&quot;</span>, index , <span class="string">&quot;is&quot;</span>, item)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 方法2: Iterator可以用next()来计算</span></span><br><span class="line">  <span class="comment"># 需要借助 StopIteration 来终止循环</span></span><br><span class="line">  _iter = <span class="built_in">iter</span>(my_iter())</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      index,item = <span class="built_in">next</span>(_iter)</span><br><span class="line">      print(<span class="string">&quot;At&quot;</span>, index , <span class="string">&quot;is&quot;</span>, item)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">      <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-ES6-实现"><a href="#3-2-ES6-实现" class="headerlink" title="3.2 ES6 实现"></a>3.2 ES6 实现</h3><p>这里实现的是一个外部迭代器。需要实现边界判断函数、元素获取函数和更新索引函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Iterator = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> next = <span class="function">() =&gt;</span> (current += <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> end = <span class="function">() =&gt;</span> current &gt;= obj.length</span><br><span class="line">    <span class="keyword">let</span> get = <span class="function">() =&gt;</span> obj[current]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next,</span><br><span class="line">        end,</span><br><span class="line">        get,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIter = Iterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">while</span> (!myIter.end()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myIter.get())</span><br><span class="line">    myIter.next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><p>  <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000">python 迭代器</a></p>
</li>
<li><p>  《JavaScript 设计模式和开发实践》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入koa源码：核心库原理</title>
    <url>/2019/06/21/hou-duan-kai-fa/nodejs/01.koa/01.koa-yuan-ma-he-xin-ku-yuan-li/</url>
    <content><![CDATA[<blockquote>
<p>最近读了 koa2 的源码，理清楚了架构设计与用到的第三方库。本系列将分为 3 篇，分别介绍 koa 的架构设计和 3 个核心库，最终会手动实现一个简易的 koa。<strong>这是系列第 2 篇，关于 3 个核心库的原理</strong>。</p>
</blockquote>
<h2 id="is-generator-function：判断-generator"><a href="#is-generator-function：判断-generator" class="headerlink" title="is-generator-function：判断 generator"></a>is-generator-function：判断 generator</h2><p>koa2 种推荐使用 async 函数，koa1 推荐的是 generator。koa2 为了兼容，在调用<code>use</code>添加中间件的时候，会判断是否是 generator。如果是，则用<code>covert</code>库转化为 async 函数。</p>
<p>判断是不是 generator 的逻辑写在了 <a href="https://github.com/ljharb/is-generator-function">is-generator-function</a> 库中，逻辑非常简单，通过判断<code>Object.prototype.toString.call</code> 的返回结果即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(say) <span class="comment">// 输出: [object GeneratorFunction]</span></span><br></pre></td></tr></table></figure>

<h2 id="delegates：属性代理"><a href="#delegates：属性代理" class="headerlink" title="delegates：属性代理"></a>delegates：属性代理</h2><p><a href="https://github.com/tj/node-delegates">delegates</a>和 koa 一样，这个库都是出自大佬 TJ 之手。它的作用就是属性代理。这个代理库常用的方法有<code>getter</code>，<code>setter</code>，<code>method</code> 和 <code>access</code>。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>假设准备了一个对象<code>target</code>，为了方便访问其上<code>request</code>属性的内容，对<code>request</code>进行代理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> delegates = <span class="built_in">require</span>(<span class="string">&#x27;delegates&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    request: &#123;</span><br><span class="line">        name: <span class="string">&#x27;xintan&#x27;</span>,</span><br><span class="line">        say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delegates(target, <span class="string">&#x27;request&#x27;</span>).getter(<span class="string">&#x27;name&#x27;</span>).setter(<span class="string">&#x27;name&#x27;</span>).method(<span class="string">&#x27;say&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>代理后，访问<code>request</code>将会更加方便：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// xintan</span></span><br><span class="line">target.name = <span class="string">&#x27;xintan!!!&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// xintan!!!</span></span><br><span class="line">target.say() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于 <code>setter</code> 和 <code>getter</code>方法，是通过调用对象上的 <code>__defineSetter__</code> 和 <code>__defineGetter__</code> 来实现的。下面是单独拿出来的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>proto 被代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>property 被代理对象上的被代理属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDelegates</span>(<span class="params">proto, property, name</span>) </span>&#123;</span><br><span class="line">    proto.__defineGetter__(name, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proto[property][name]</span><br><span class="line">    &#125;)</span><br><span class="line">    proto.__defineSetter__(name, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (proto[property][name] = val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myDelegates(target, <span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// xintan</span></span><br><span class="line">target.name = <span class="string">&#x27;xintan!!!&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// xintan!!!</span></span><br></pre></td></tr></table></figure>

<p>刚开始我的想法是更简单一些，就是直接让 <code>proto[name] = proto[property][name]</code>。但这样做有个缺点无法弥补，就是之后如果<code>proto[property][name]</code>改变，<code>proto[name]</code>获取不了最新的值。</p>
<p>对于<code>method</code>方法，实现上是在对象上创建了新属性，属性值是一个函数。这个函数调用的就是代理目标的函数。下面是单独拿出来的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>proto 被代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>property 被代理对象上的被代理属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>method 函数名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDelegates</span>(<span class="params">proto, property, method</span>) </span>&#123;</span><br><span class="line">    proto[method] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proto[property][method].apply(proto[property], <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myDelegates(target, <span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">target.say() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>因为是“代理”，所以这里不能修改上下文环境。<code>proto[property][method]</code>的上下文环境是 <code>proto[property]</code> ，需要<code>apply</code>重新指定。</p>
<p>koa 中也有对属性的<code>access</code>方法代理，这个方法就是<code>getter</code>和<code>setter</code>写在一起的语法糖。</p>
<h2 id="koa-compose：洋葱模型"><a href="#koa-compose：洋葱模型" class="headerlink" title="koa-compose：洋葱模型"></a>koa-compose：洋葱模型</h2><h3 id="模拟洋葱模型"><a href="#模拟洋葱模型" class="headerlink" title="模拟洋葱模型"></a>模拟洋葱模型</h3><p><strong>koa 最让人惊艳的就是大名鼎鼎的“洋葱模型”</strong>。以至于之前我在开发 koa 中间件的时候，一直有种 magic 的方法。经常疑惑，这里<code>await next()</code>，执行完之后的中间件又会重新回来继续执行未执行的逻辑。</p>
<p>这一段逻辑封装在了核心库<a href="https://github.com/koajs/compose">koa-compose</a> 里面。源码也很简单，算上各种注释只有不到 50 行。为了方便说明和理解，我把其中一些意外情况检查的代码去掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)))</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>middleware 里面保存的就是开发者自定义的中间件处理逻辑。为了方便说明，我准备了 2 个中间件函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = [</span><br><span class="line">    <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在，模拟在 koa 中对 compose 函数的调用，我们希望程序的输出是：<code>a b c</code>（正如使用 koa 那样）。运行以下代码即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fns = compose(middleware)</span><br><span class="line">fns()</span><br></pre></td></tr></table></figure>

<p>ok，目前已经模拟出来了一个不考虑异常情况的洋葱模型了。</p>
<h3 id="为什么会这样？"><a href="#为什么会这样？" class="headerlink" title="为什么会这样？"></a>为什么会这样？</h3><p>为什么会有洋葱穿透的的效果呢？回到上述的<code>compose</code>函数，闭包写法返回了一个新的函数，其实就是返回内部定义的<code>dispatch</code>函数。其中，参数的含义分别是：</p>
<ul>
<li>  i: 当前执行到的中间件在所有中间件中的下标</li>
<li>  context: 上下文环境。所以我们在每个中间件中都可以访问到当前请求的信息。</li>
</ul>
<p>在上面的测试用例中，<code>fns()</code> 其实就是 <code>dispatch(0)</code>。在<code>dispatch</code>函数中，通过参数 i 拿到了当前要运行的中间件<code>fn</code>。</p>
<p>然后，将当前请求的上下文环境(context)和 dispatch 处理的下一个中间件(next)，都传递给当前中间件。对应的代码段是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>那么，在中间件中执行 <code>await next()</code>，其实就是执行：<code>await dispatch.bind(null, i + 1)</code>。因此看起来，当前中间件会停止自己的逻辑，先处理下一个中间件的逻辑。</p>
<p>因为每个<code>dispatch</code>，都返回新的 Promsise。所以<code>async</code>会等到 Promise 状态改变后再回来继续执行自己的逻辑。</p>
<h3 id="async-await-改写"><a href="#async-await-改写" class="headerlink" title="async/await 改写"></a>async/await 改写</h3><p>最后，在不考虑 koa 的上下文环境的情况下，用 async/await 的提炼出了 compose 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> fn(dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是它的使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = [</span><br><span class="line">    <span class="keyword">async</span> (next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> (next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">compose(middleware) <span class="comment">// 输出a b c</span></span><br></pre></td></tr></table></figure>

<p>希望最后这段代码能帮助理解！</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>深入koa源码：架构设计</title>
    <url>/2019/06/18/hou-duan-kai-fa/nodejs/01.koa/02.koa-yuan-ma-jia-gou-she-ji/</url>
    <content><![CDATA[<blockquote>
<p>最近读了 koa 的源码，理清楚了架构设计与用到的第三方库。本系列将分为 3 篇，分别介绍 koa 的架构设计和 3 个核心库，最终会手动实现一个简易的 koa。</p>
</blockquote>
<p>koa 的实现都在仓库的<code>lib</code>目录下，如下图所示，只有 4 个文件：</p>
<p><img src="https://static.godbmw.com/img/2019-06-18-deep-in-koa/1.png"></p>
<p>对于这四个文件，根据用途和封装逻辑，可以分为 3 类：req 和 res，上下文以及 application。</p>
<h2 id="req-和-res"><a href="#req-和-res" class="headerlink" title="req 和 res"></a>req 和 res</h2><p>对应的文件是：<code>request.js</code> 和 <code>response.js</code>。分别代表着客户端请求信息和服务端返回信息。</p>
<p>这两个文件在实现逻辑上完全一致。对外暴露都是一个对象，对象上的属性都使用了<code>getter</code>或<code>setter</code>来实现读写控制。</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>对应的文件是：<code>context.js</code>。存了运行环境的上下文信息，例如<code>cookies</code>。</p>
<p>除此之外，因为<code>request</code>和<code>response</code>都属于上下文信息，所以通过<code>delegate.js</code>库来实现了对<code>request.js</code>和<code>response.js</code>上所有属性的代理。例如以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Response delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">delegate(proto, <span class="string">&#x27;response&#x27;</span>).method(<span class="string">&#x27;attachment&#x27;</span>).method(<span class="string">&#x27;redirect&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">&#x27;request&#x27;</span>).method(<span class="string">&#x27;acceptsLanguages&#x27;</span>).method(<span class="string">&#x27;acceptsEncodings&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用代理的另外一个好处就是：更方便的访问 req 和 res 上的属性。比如在开发 koa 应用的时候，可以通过<code>ctx.headers</code>来读取客户端请求的头部信息，不需要写成<code>ctx.res.headers</code>了（这样写没错）。</p>
<p><strong>注意</strong>：req 和 res 并不是在<code>context.js</code>中被绑定到上下文的，而是在<code>application</code>被绑定到上下文变量<code>ctx</code>中的。原因是因为每个请求的 req/res 都不是相同的。</p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>对应的文件是: <code>application.js</code>。这个文件的逻辑是最重要的，它的作用主要是：</p>
<ul>
<li>  给用户暴露服务启动接口</li>
<li>  针对每个请求，生成新的上下文</li>
<li>  处理中间件，将其串联</li>
</ul>
<h3 id="对外暴露接口"><a href="#对外暴露接口" class="headerlink" title="对外暴露接口"></a>对外暴露接口</h3><p>使用 koa 时候，我们常通过<code>listen</code>或者<code>callback</code>来启动服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.listen(<span class="number">3000</span>) <span class="comment">// listen启动</span></span><br><span class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>) <span class="comment">// callback启动</span></span><br></pre></td></tr></table></figure>

<p>这两种启动方法是完全等价的。因为<code>listen</code>方法内部，就调用了<code>callback</code>，并且将它传给<code>http.createServer</code>。接着看一下<code>callback</code>这个方法主要做了什么：</p>
<ol>
<li>调用<code>koa-compose</code>将中间件串联起来（下文再讲）。</li>
<li>生成传给<code>http.createServer()</code>的函数，并且返回。</li>
</ol>
<ul>
<li>  <code>http.createServer</code>传给函数参数的请求信息和返回信息，都被这个函数拿到了。并且传给<code>createContext</code>方法，生成本次请求的上下文。</li>
<li>  将生成的上下文传给第 1 步生成的中间件调用链，<strong>这就是为什么我们在中间件处理逻辑的时候能够访问<code>ctx</code></strong></li>
</ul>
<h3 id="生成新的上下文"><a href="#生成新的上下文" class="headerlink" title="生成新的上下文"></a>生成新的上下文</h3><p>这里上下文的方法对应的是<code>createContext</code>方法。这里我觉得更像语法糖，是为了让 koa 使用者使用更方便。比如以下这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.request 是 request.js 暴露出来的对象，将其引用保存在context.request中</span></span><br><span class="line"><span class="comment">// 用户可以直接通过 ctx.属性名 来访问对应属性</span></span><br><span class="line"><span class="keyword">const</span> request = (context.request = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.request))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个req是本次请求信息，是由 http.createServer 传递给回调函数的</span></span><br><span class="line">context.req = request.req = response.req = req</span><br></pre></td></tr></table></figure>

<p>读到这里，虽然可以解释 <code>context.headers</code> 是 <code>context.request.headers</code> 的语法糖这类问题。但是感觉怪怪的。就以这个例子，context.headers 访问的是 context.request 上的 headers，而不是本次请求信息上的<code>headers</code>。本次请求信息挂在了<code>context.req</code>上。</p>
<p>让我们再回到<code>reqeust.js</code>的源码，看到了<code>headers</code>的 getter 实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">headers</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.req.headers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>context.request.headers</code> 就是 <code>context.request.req.headers</code>。而前面提及的<code>createContext</code>方法中的逻辑，<code>context.reqest</code>上的<code>req</code>属性就是由<code>http</code>模块函数传来的真实请求信息。 <strong>感谢 <a href="https://github.com/theniceangel">@theniceangel</a> 的评论指正</strong>。</p>
<p>可以看到，koa 为了让开发者使用方便，在上下文上做了很多工作。</p>
<h3 id="中间件机制"><a href="#中间件机制" class="headerlink" title="中间件机制"></a>中间件机制</h3><p>中间件的设计是 koa 最重要的部分，实现上用到了<code>koa-compose</code>库来串联中间件，形成“洋葱模型”。关于这个库，放在第二篇关于 koa 核心库的介绍中说明。</p>
<p>application 中处理中间件的函数是<code>use</code>和<code>handleRequest</code>：</p>
<ul>
<li>  <code>use</code>函数：传入<code>async/await</code>函数，并将其放入 application 实例上的<code>middleware</code>数组中。如果传入是 generator，会调用<code>koa-conver</code>库将其转化为<code>async/await</code>函数。</li>
<li>  <code>handleRequest(ctx, fnMiddleware)</code>函数：传入的<code>fnMiddleware</code>是已经串联好的中间件，函数所做的工作就是再其后再添加一个返回给客户端的函数和错误处理函数。返回给客户端的函数其实就是<code>respond</code>函数，里面通过调用<code>res.end()</code>来向客户端返回信息，整个流程就走完了。</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>深入koa源码：手动实现玩具版koa</title>
    <url>/2019/06/21/hou-duan-kai-fa/nodejs/01.koa/03.koa-yuan-ma-shou-dong-shi-xian/</url>
    <content><![CDATA[<blockquote>
<p>最近读了 koa2 的源码，理清楚了架构设计与用到的第三方库。本系列将分为 3 篇，分别介绍 koa 的架构设计和 3 个核心库，最终会手动实现一个简易的 koa。<strong>这是系列第 3 篇，模拟实现玩具版 koa</strong>。</p>
</blockquote>
<p>源码和测试代码放在了：<a href="https://github.com/root-lucas/Blog-demos/tree/master/nodeJS/simple-koa">simple-koa</a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>设计思想和第三方库原理都在前 2 篇详细说明了。这篇主要目的是做一个验证检验，在语法使用 ES6/7 的语法。</p>
<p>在开始前，安装一下需要用到的库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save koa-compose koa-convert is-generator-function</span><br><span class="line">npm install --save events</span><br></pre></td></tr></table></figure>

<h2 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h2><p>为了说明效果，先按照正常使用 koa 的逻辑编写了测试文件。当启动它的时候，它的预期行为是：</p>
<ul>
<li>  监听 3000 端口</li>
<li>  加载中间件</li>
<li>  浏览器访问<code>localhost:3000</code>，屏幕打印<code>hello</code></li>
<li>  服务器的控制台依次输出：1inner =&gt; 2innter =&gt; 2outer =&gt; 1outer</li>
</ul>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;./lib/application&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1 inner&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1 outer&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    ctx.res.body = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2 inner&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2 outer&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.use(middleware1)</span><br><span class="line">server.use(middleware2)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="玩具-koa"><a href="#玩具-koa" class="headerlink" title="玩具 koa"></a>玩具 koa</h2><p>只准备了一个文件，跑通上面的逻辑即可。文件是 <code>lib/application.js</code> 。</p>
<p>文件代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Emitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">&#x27;koa-compose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.middleware = []</span><br><span class="line">        <span class="built_in">this</span>.context = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.request = &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.response = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback())</span><br><span class="line">        <span class="keyword">return</span> server.listen(...args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">use</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.middleware.push(fn)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">callback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware)</span><br><span class="line">        <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = ctx.res</span><br><span class="line">        <span class="comment">// res.statusCode = 404</span></span><br><span class="line">        <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            res.end(res.body)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(<span class="built_in">this</span>.onerror)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">createContext</span>(<span class="params">req, res</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.context)</span><br><span class="line">        context.request = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.request)</span><br><span class="line">        context.response = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.response)</span><br><span class="line">        context.req = req</span><br><span class="line">        context.res = res</span><br><span class="line"></span><br><span class="line">        context.app = <span class="built_in">this</span></span><br><span class="line">        context.state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">onerror</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`error occurs: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面开始解析<code>lib/application.js</code>文件代码</p>
</blockquote>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首先对外暴露的就是一个继承 Emitter 的 Application 类。整体框架如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Emitter = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">&#x27;koa-compose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.middleware = [] <span class="comment">// 中间件</span></span><br><span class="line">        <span class="built_in">this</span>.context = &#123;&#125; <span class="comment">// 上下文</span></span><br><span class="line">        <span class="built_in">this</span>.request = &#123;&#125; <span class="comment">// 请求信息</span></span><br><span class="line">        <span class="built_in">this</span>.response = &#123;&#125; <span class="comment">// 返回信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">use</span>(<span class="params">fn</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">callback</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">createContext</span>(<span class="params">req, res</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">onerror</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`error occurs: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承 Emitter 事件类，是为了方便监听和处理报错。</p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>将外面传入的中间件保存起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">use (fn) &#123;</span><br><span class="line">  <span class="built_in">this</span>.middleware.push(fn)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>主要用于创建上下文。外面可以通过访问 ctx 上的 req/res 拿到请求或者返回信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createContext (req, res) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.context)</span><br><span class="line">  context.request = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.request)</span><br><span class="line">  context.response = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.response)</span><br><span class="line">  context.req = req</span><br><span class="line">  context.res = res</span><br><span class="line"></span><br><span class="line">  context.app = <span class="built_in">this</span></span><br><span class="line">  context.state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listen-和-callback"><a href="#listen-和-callback" class="headerlink" title="listen 和 callback"></a>listen 和 callback</h3><p>监听端口，启动服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">listen (...args) &#123;</span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="built_in">this</span>.callback())</span><br><span class="line">  <span class="keyword">return</span> server.listen(...args)</span><br><span class="line">&#125;,</span><br><span class="line">callback () &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="built_in">this</span>.middleware)</span><br><span class="line">  <span class="built_in">this</span>.on(<span class="string">&#x27;error&#x27;</span>, <span class="built_in">this</span>.onerror)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.handleRequest(ctx, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="handleRequest"><a href="#handleRequest" class="headerlink" title="handleRequest"></a>handleRequest</h3><p>在 <code>callback</code> 方法中真是返回的内容，它的作用就是：处理请求，并且返回给客户端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res</span><br><span class="line">  <span class="comment">// res.statusCode = 404</span></span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.end(res.body)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx)</span><br><span class="line">    .then(handleResponse)</span><br><span class="line">    .catch(<span class="built_in">this</span>.onerror)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p>启动 index.js 后，在浏览器访问本地 3000 端口：</p>
<p>回到控制台，查看中间件的输出顺序是否正确：</p>
<p><img src="https://s2.ax1x.com/2019/12/23/l9ljyR.png"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转 Nodejs 命令行</title>
    <url>/2019/05/07/hou-duan-kai-fa/nodejs/02.ming-ling-xing/01.wan-zhuan-nodejs-ming-ling-xing/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做 cli 工具的时候，非常需要命令行相关的第三方库。一个比较稳健成熟的命令行应该考虑以下 4 种需求：</p>
<ol>
<li>读取传入的各种参数，例如： –help, -v=123</li>
<li>逻辑处理和友好的 UI 交互，例如：提供列表选择</li>
<li>细致控制字体颜色和背景颜色</li>
<li>状态显示，例如：等待过程前面是转圈圈，完成过程前面自动换成对号</li>
</ol>
<p>在开始前，安装一下需要用到的库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save inquirer</span><br><span class="line">npm install --save commander</span><br><span class="line">npm install --save inquirer</span><br><span class="line">npm install --save ora</span><br></pre></td></tr></table></figure>

<p>下面的四个文件例子只需复制粘贴到文件通过 node.js 即可运行</p>
<h2 id="读取参数-commander"><a href="#读取参数-commander" class="headerlink" title="读取参数: commander"></a>读取参数: commander</h2><p>这里用到的是 commander 这个库。它的文档地址是：<a href="https://www.npmjs.com/package/commander">https://www.npmjs.com/package/commander</a></p>
<p>请先看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分为2种操作, 2种操作互相冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Options 操作</span></span><br><span class="line">program</span><br><span class="line">    .version(<span class="string">&#x27;0.0.1&#x27;</span>)</span><br><span class="line">    .option(<span class="string">&#x27;-t, --types [type]&#x27;</span>, <span class="string">&#x27;test options&#x27;</span>)</span><br><span class="line">    <span class="comment">// option这句话必须加</span></span><br><span class="line">    .parse(process.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commands 操作</span></span><br><span class="line">program</span><br><span class="line">    <span class="comment">// 命令与参数: &lt;&gt; 必填; [] 选填</span></span><br><span class="line">    .command(<span class="string">&#x27;exec &lt;cmd&gt; [env]&#x27;</span>)</span><br><span class="line">    <span class="comment">// 别名</span></span><br><span class="line">    .alias(<span class="string">&#x27;ex&#x27;</span>)</span><br><span class="line">    <span class="comment">// 帮助信息</span></span><br><span class="line">    .description(<span class="string">&#x27;execute the given remote cmd&#x27;</span>)</span><br><span class="line">    <span class="comment">// 没用，option和command是冲突的</span></span><br><span class="line">    .option(<span class="string">&#x27;-e, --exec_mode &lt;mode&gt;&#x27;</span>, <span class="string">&#x27;Which exec mode to use&#x27;</span>)</span><br><span class="line">    <span class="comment">// 执行的操作</span></span><br><span class="line">    .action(<span class="function">(<span class="params">cmd, env, options</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 参数可以拿到</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`env is <span class="subst">$&#123;env&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;exec &quot;%s&quot; using %s mode&#x27;</span>, cmd, options.exec_mode)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 自定义help信息</span></span><br><span class="line">    .on(<span class="string">&#x27;--help&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;自定义help信息&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数长度不够, 打印帮助信息</span></span><br><span class="line"><span class="keyword">if</span> (!process.argv.slice(<span class="number">2</span>).length) &#123;</span><br><span class="line">    program.outputHelp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (program.types) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(program.types)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析命令行参数</span></span><br><span class="line">program.parse(process.argv)</span><br></pre></td></tr></table></figure>

<p>文档上基本都写明白了，但是有几个需要注意的点：</p>
<ol>
<li>它主要提供 options 和 commands 两种操作，option 就是形如“-t，–types”这样的传参，commands 就是形如“exec”这样的传参。 <strong>不要混用两者</strong> 。</li>
<li>读取 commands 中传入的参数，写在 <code>.action</code>  中；读取 options 传入的参数，是通过访问 <code>program</code>  上的变量。除此之外，<strong>options 操作需要执行  .parse(process.argv) 解析命令行参数</strong></li>
<li><code>-V</code>  和 <code>-h</code>  默认也是提供的，但是也可以通过自定义覆盖</li>
<li>一般都把 options 写在前面， <strong>顺便标识版本号</strong> ；把 commands 写在后面；最后会判断一下参数长度，不够会自动输出打印信息</li>
</ol>
<h2 id="交互验证：inquirer"><a href="#交互验证：inquirer" class="headerlink" title="交互验证：inquirer"></a>交互验证：inquirer</h2><p>深入交互并且提供基于命令行的选择列表、弹框等 UI 视图，我们借助：inquirer 库。它的文档地址是：<a href="https://www.npmjs.com/package/inquirer">https://www.npmjs.com/package/inquirer</a></p>
<p>请看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"></span><br><span class="line">program.version(<span class="string">&#x27;1.0.0&#x27;</span>).option(<span class="string">&#x27;--sass [sass]&#x27;</span>, <span class="string">&#x27;启用sass&#x27;</span>).option(<span class="string">&#x27;--less&#x27;</span>, <span class="string">&#x27;启用less&#x27;</span>).parse(process.argv)</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">&#x27;module [moduleName]&#x27;</span>)</span><br><span class="line">    .alias(<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    .description(<span class="string">&#x27;创建新模块&#x27;</span>)</span><br><span class="line">    .action(<span class="function">(<span class="params">option</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`option is <span class="subst">$&#123;option&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`program.sass is <span class="subst">$&#123;program.sass&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">const</span> config = &#123;</span><br><span class="line">            moduleName: <span class="literal">null</span>,</span><br><span class="line">            des: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            sass: <span class="literal">false</span>,</span><br><span class="line">            less: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> promps = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// type: input</span></span><br><span class="line">        <span class="comment">// 问答框类型</span></span><br><span class="line">        <span class="keyword">if</span> (config.moduleName !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">            promps.push(&#123;</span><br><span class="line">                type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;moduleName&#x27;</span>,</span><br><span class="line">                message: <span class="string">&#x27;请输入模块名称&#x27;</span>,</span><br><span class="line">                validate: <span class="function"><span class="keyword">function</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;输入不能为空&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// type: list</span></span><br><span class="line">        <span class="comment">// 列表选择器类型</span></span><br><span class="line">        <span class="keyword">if</span> (!program.sass &amp;&amp; !program.less) &#123;</span><br><span class="line">            promps.push(&#123;</span><br><span class="line">                type: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;cssPretreatment&#x27;</span>,</span><br><span class="line">                message: <span class="string">&#x27;想用什么css预处理器呢&#x27;</span>,</span><br><span class="line">                choices: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: <span class="string">&#x27;Sass&#x27;</span>,</span><br><span class="line">                        value: <span class="string">&#x27;sass&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: <span class="string">&#x27;Less&#x27;</span>,</span><br><span class="line">                        value: <span class="string">&#x27;less&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inquirer.prompt(promps).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(answers)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">program.parse(process.argv)</span><br></pre></td></tr></table></figure>

<p>除去 commader 库的应用，inquirer 库的应用在 15~64 行。它首先会验证是否传入 module 参数，如果没有，那么以问答的形式引导用户输入；紧接着检查是否指定了 scss / less，如果没有指定，弹出列表选择器供用户选择。</p>
<p>整个过程中的交互体验还是非常好的，尤其是针对多个选项的时候的列表选择器，一目了然。</p>
<h2 id="颜色控制：chalk"><a href="#颜色控制：chalk" class="headerlink" title="颜色控制：chalk"></a>颜色控制：chalk</h2><p>这个比较简单，写过 c 的同学应该知道控制命令行颜色，只需要 颜色宏定义 + 字体内容 拼接即可。所以这个库也是，提供更语义化的 api 将文本处理成拼接后的结果，然后交给控制台输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> print = <span class="built_in">console</span>.log</span><br><span class="line">print(chalk.blue(<span class="string">&#x27;Hello&#x27;</span>) + <span class="string">&#x27; World&#x27;</span> + chalk.red(<span class="string">&#x27;!&#x27;</span>))</span><br><span class="line">print(chalk.blue.bgRed.bold(<span class="string">&#x27;Hello World!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="过程控制：ora"><a href="#过程控制：ora" class="headerlink" title="过程控制：ora"></a>过程控制：ora</h2><p>它实现的核心功能是控制台刷新，我可以用它来做“下载进度条”（一直更新 text 属性即可）。当然，项目中用它来做状态提示，它会在语句前面给个转圈圈的 icon，还会有对号、错误等终止状态 icon。</p>
<p>看下面这段代码，假想现在是在下载<strong>*。</strong>可以跑一下下面代码，mac 下比 windows 下好太多**。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">&#x27;ora&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = ora(&#123;</span><br><span class="line">    text: <span class="string">&#x27;链接网络中&#x27;</span>,</span><br><span class="line">&#125;).start() <span class="comment">// 开始状态 =&gt; 加载状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    spinner.color = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">    spinner.text = <span class="string">&#x27;网速有点慢&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>) <span class="comment">// 还是 加载状态, 更新文案和颜色</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    spinner.succeed(<span class="string">&#x27;下载成功&#x27;</span>) <span class="comment">// 加载状态 =&gt; 成功状态</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<p>主要使用了 <code>commander.js</code> &amp;&amp; <code>inquirer.js</code> &amp;&amp; <code>chalk.js</code> 这三个库。</p>
<h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html">阿里开发团队一篇靠谱的文档</a>: 非常推荐</p>
<h3 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h3><p><a href="https://www.npmjs.com/package/commander">commander.js 文档</a>：看了后很多疑惑。。。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest实战：单元测试与服务测试</title>
    <url>/2019/05/04/hou-duan-kai-fa/nodejs/03.ce-shi/01.jest-shi-zhan-dan-yuan-ce-shi-yu-fu-wu-ce-shi/</url>
    <content><![CDATA[<h2 id="需求与思路"><a href="#需求与思路" class="headerlink" title="需求与思路"></a>需求与思路</h2><p>一名好的大前端开发人员，一定是一名好的“配置工程师”（滑稽脸）。被安排给 <a href="https://github.com/vemoteam/vemo">vemoJS</a>  和 cloudbase-cli 写测试用例，并且要保证覆盖率！</p>
<p>这里主要以 vemojs 下的测试用例为主来讲解 Jest 要注意的地方。测试代码在：<a href="https://github.com/vemoteam/vemo/tree/master/test">https://github.com/vemoteam/vemo/tree/master/test</a></p>
<p>观察 vemojs 这个项目，如果想进行全面测试，需要解决以下问题：</p>
<ol>
<li>以 utils.js errror.js 等文件，对应的是单元功能测试</li>
<li>以 cloudbase.js 文件为代表的，需要请求远程 API，模拟不同的情况</li>
<li>以 index.js 中的 http 和静态服务器为代表的，测试服务是否正常启动</li>
<li>以 index.js 中的 websocket 服务为代表的，模拟用户使用环境，测试 ws 是否正常</li>
<li>提供测试覆盖率</li>
</ol>
<p>针对以上问题，解决思路总结如下：</p>
<ol>
<li>函数功能测试：断言匹配功能</li>
<li>请求 API：mock 模块和函数，例如测试用例中的 <code>axios</code>  就是被 mock 的</li>
<li>http 和静态服务：测试代码中启动服务后，利用 <code>axios</code>  等第三方请求库请求服务</li>
<li>websock 服务：借助 puppeteer（内置无头浏览器）来模拟用户使用，监听数据变动</li>
<li>jest 自带覆盖率统计工具</li>
</ol>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><p>针对上面的步骤以及核心的 jest 配置，分别做讲解。</p>
<h3 id="1-配置文件和命令行"><a href="#1-配置文件和命令行" class="headerlink" title="1. 配置文件和命令行"></a>1. 配置文件和命令行</h3><p>jest 提供两种方式来让用户自定义配置，一个是根目录的 <code>jest.config.js</code> ，另一个是启动 jest 的时候给参数。我是采用两者混搭的方法。</p>
<p><code>jest.config.js</code> ：在统计覆盖率的时候，忽略 <code>test</code>  和 <code>node_modules</code>  文件夹下。有时候为了方便，会把测试常用的函数、配置放在 test 目录下，如果不忽略，会被统计进去，但它不属于源码部分。除此之外，别忘了 node_modules，否则由于文件太多，根本启动不起来，而且结果也不对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    coveragePathIgnorePatterns: [<span class="string">&#x27;&lt;rootDir&gt;/test/&#x27;</span>, <span class="string">&#x27;&lt;rootDir&gt;/node_modules/&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行参数写在 <code>package.json</code>  文件的 <code>scripts</code>  属性中。 需要注意的地方有 2 个， <code>--detectOpenHandles</code>  参数是为了当句柄未正常关闭，显式报错给用户； <code>--env=node</code>  指明测试环境是 nodejs，默认是浏览器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;jest --passWithNoTests --coverage --env=node --detectOpenHandles&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-断言与函数功能"><a href="#2-断言与函数功能" class="headerlink" title="2. 断言与函数功能"></a>2. 断言与函数功能</h3><p>这个很简单，但是可以配合 <code>describe</code>  关键字，层级区分测试逻辑。还可以配合 beforeAll 等生命周期钩子函数，提高测试效率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; VemoError &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./../src/error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;error.js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    test(<span class="string">&#x27;Throw VemoError&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">throwVemoError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> VemoError()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expect(throwVemoError).toThrow(<span class="built_in">Error</span>)</span><br><span class="line">        expect(throwVemoError).toThrow(VemoError)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">&#x27;VemoError should have code and message&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> properties = [<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">        <span class="keyword">const</span> vemoError = <span class="keyword">new</span> VemoError()</span><br><span class="line">        expect(properties.every(<span class="function">(<span class="params">prop</span>) =&gt;</span> vemoError.hasOwnProperty(prop))).toBe(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-远程-API-测试"><a href="#3-远程-API-测试" class="headerlink" title="3. 远程 API 测试"></a>3. 远程 API 测试</h3><p>有一些函数需要连接云的 API 进行认证，由于安全策略，不在云厂商的服务器上无法请求。这时候，就需要 mock 对应的请求库，返回我们构造好的数据，以让函数逻辑走下去，提高测试覆盖率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jest.mock(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line">test(<span class="string">&#x27;getTempSecret should get tencent cloud temporary secret&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 下面就是mock的数据</span></span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            TmpSecretId: <span class="string">&#x27;testTmpSecretId&#x27;</span>,</span><br><span class="line">            TmpSecretKey: <span class="string">&#x27;testTmpSecretKey&#x27;</span>,</span><br><span class="line">            Token: <span class="string">&#x27;testToken&#x27;</span>,</span><br><span class="line">            ExpiredTime: <span class="built_in">Date</span>.now(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> cloudBaseMiddleware(&#123;&#125;, <span class="keyword">async</span> () =&gt; &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-http-与-static-服务测试"><a href="#4-http-与-static-服务测试" class="headerlink" title="4. http 与 static 服务测试"></a>4. http 与 static 服务测试</h3><p>这方面很多人可能会用 supertest 这个库来测试。在做调研的时候发现，jest 的下载量和更新记录远远高于 supertest，而且更纯粹。为什么这么说呢？它提供一种测试的组织形式，其它可以借助第三方库和工具实现。</p>
<p>而服务测试的思路就是：在 test 目录下启动简单的 http 服务器和静态服务器，然后利用 <code>axios</code>  访问启动的服务器，拿到返回结果，再利用断言的写法，检查即可。</p>
<p>请看下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./../../src/&#x27;</span>) <span class="comment">// 启动服务器</span></span><br><span class="line"><span class="comment">// 加载配置文件和axios库</span></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./vemofile&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">`http://<span class="subst">$&#123;config.host&#125;</span>:<span class="subst">$&#123;config.port&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 下面分别请求：/home#GET 和 /api#POST 接口，并且检查返回结果</span></span><br><span class="line">describe(<span class="string">&#x27;index.js api server&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    test(<span class="string">&#x27;template response should be HTML&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        expect.assertions(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; data, status &#125; = <span class="keyword">await</span> instance.get(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        expect(status).toEqual(<span class="number">200</span>)</span><br><span class="line">        expect(data).toMatch(<span class="regexp">/&lt;html&gt;.*&lt;\/html&gt;/i</span>s)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    test(<span class="string">&#x27;post and validate check&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        expect.assertions(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> params = &#123;</span><br><span class="line">            param1: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">            param2: <span class="number">123</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; data, status &#125; = <span class="keyword">await</span> instance.post(<span class="string">&#x27;/api&#x27;</span>, params)</span><br><span class="line"></span><br><span class="line">        expect(status).toEqual(<span class="number">200</span>)</span><br><span class="line">        expect(<span class="built_in">JSON</span>.stringify(data)).toEqual(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-puppeteer-与无头浏览器"><a href="#5-puppeteer-与无头浏览器" class="headerlink" title="5. puppeteer 与无头浏览器"></a>5. puppeteer 与无头浏览器</h3><p>针对 ws 协议，测试它的思路有点像 SSR：</p>
<ol>
<li>启动测试后台，并且在 <code>/ws</code>  路由上启动 ws 协议，在 2s 后，会向链接的客户端主动发送消息</li>
<li>puppeteer 打开新的页面，访问对应的页面，拿到页面的内容，并且记录</li>
<li>新的页面在等待 2s 后，接受到 <code>/ws</code>  主动传来的数据，然后更新页面内容</li>
<li>再利用 puppeteer 读取页面内容，并且记录</li>
<li>比较 2 次记录的内容是否有更新，如果有，那么验证通过</li>
</ol>
<p>具体请看：<a href="https://github.com/vemoteam/vemo/blob/master/test/server/index.test.js">https://github.com/vemoteam/vemo/blob/master/test/server/index.test.js</a>  的 61 ~ 91 行</p>
<h2 id="体验与改进"><a href="#体验与改进" class="headerlink" title="体验与改进"></a>体验与改进</h2><h3 id="1-windows-下的-puppeteer"><a href="#1-windows-下的-puppeteer" class="headerlink" title="1. windows 下的 puppeteer"></a>1. windows 下的 puppeteer</h3><p>由于 windows 下 puppeteer 无法通过 npm 下载安装（就是很麻烦），所以把 puppeteer 的加载代码进一步处理，同时在失败的时候给出友好的提示，引导使用者切换测试平台：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... other codes</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">launchBrowser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch()</span><br><span class="line">        <span class="keyword">return</span> browser</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// if load fail, show information and return immediately</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">&quot;Don&#x27;t run test in Windows. \n&quot;</span> +</span><br><span class="line">                <span class="string">&#x27;If you fail to launch on UNIX, please install dependencies. \n&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;More info: https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md. \n&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> launchBrowser()</span><br><span class="line"><span class="comment">// ... other codes</span></span><br></pre></td></tr></table></figure>

<h3 id="2-最小影响原则"><a href="#2-最小影响原则" class="headerlink" title="2. 最小影响原则"></a>2. 最小影响原则</h3><p>http 服务器、静态服务器和 ws 服务器对应的启动文件 <code>/src/index.js</code>  没有对外暴露接口，没法显示传入要求的配置文件: <code>vemofile.js</code> ，它只能自动读取。</p>
<p>而在运行测试的时候，它会在根目录下读取  <code>vemofile.js</code> ，而我们的配置写在 <code>/test/serve</code>  下，所以要手动切换一下运行目录： <code>process.chdir(__dirname)</code> 。这样就保证了针对测试服务器的配置不会污染代码库。</p>
<h3 id="3-下载体验"><a href="#3-下载体验" class="headerlink" title="3. 下载体验"></a>3. 下载体验</h3><p>用户在安装库的时候，显然不需要跑测试，所以需要让 npm 忽略 test 目录下的文件（其实对于一些 ts 的项目，src 下的源码也是忽略的）。给 <code>.npmignore</code>  添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="string">test</span></span><br></pre></td></tr></table></figure>

<h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>最后放一下覆盖率统计效果吧（Ubuntu 16.04）：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1556957797294-9856555c-26e1-4fde-ba80-21ea40e96020.png#align=left&display=inline&height=106&name=image.png&originHeight=132&originWidth=558&size=13052&status=done&width=446.4" alt="image.png"></p>
<p>没覆盖的地方，全部是出现异常地方。一般来说超过 80%的覆盖率即可，其他的可以慢慢补上。这种自己手动跑的方式太 low 了，之后还会有一篇讲解 CI 等第三方工具的文章，“懒就是生产力”。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>Jest进阶：接入ts、集成测试与覆盖率统计</title>
    <url>/2019/05/04/hou-duan-kai-fa/nodejs/03.ce-shi/02.jest-jin-jie-jie-ru-ts-ji-cheng-ce-shi-yu-fu-gai-lu-tong-ji/</url>
    <content><![CDATA[<h2 id="接入-TypeScript"><a href="#接入-TypeScript" class="headerlink" title="接入 TypeScript"></a>接入 TypeScript</h2><p>在给 vemojs 做完各种测试之后，很快又有了新的要求，给 <a href="https://github.com/TencentCloudBase/cloud-base-cli">clousebase-cli</a>  编写测试用例。有个问题摆在眼前：它是用 typescript 编写，所以需要配置相关环境。</p>
<p>好吧，不说废话了，直接上干货。</p>
<p><code>jest.config.js</code>  配置内容如下，解释在注释里面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    roots: [</span><br><span class="line">        <span class="string">&#x27;&lt;rootDir&gt;/test&#x27;</span>, <span class="comment">// 测试目录</span></span><br><span class="line">    ],</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">&#x27;^.+\\.tsx?$&#x27;</span>: <span class="string">&#x27;ts-jest&#x27;</span>, <span class="comment">// 匹配 .ts 或者 .tsx 结尾的文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    collectCoverage: <span class="literal">true</span>, <span class="comment">// 统计覆盖率</span></span><br><span class="line">    testEnvironment: <span class="string">&#x27;node&#x27;</span>, <span class="comment">// 测试环境</span></span><br><span class="line">    setupFilesAfterEnv: [</span><br><span class="line">        <span class="string">&#x27;&lt;rootDir&gt;/jest.setup.js&#x27;</span>, <span class="comment">// 之后再说</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 不算入覆盖率的文件夹</span></span><br><span class="line">    coveragePathIgnorePatterns: [<span class="string">&#x27;&lt;rootDir&gt;/node_modules/&#x27;</span>, <span class="string">&#x27;&lt;rootDir&gt;/test/&#x27;</span>, <span class="string">&#x27;&lt;rootDir&gt;/deps/&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有个 <code>jest.setup.js</code> ，它的内容是： <code>jest.setTimeout(60000)</code> 。因为有时候网速很慢，api 请求延时会很高，所以这个就是设置请求超时时间为 1 分钟。</p>
<p>最坑的一点是，除了 <code>jest</code>  的配置文件，还要修改 typescript 对应的文件， <code>tsconfig.json</code>  内容如下。types 中必须添加 <code>jest</code> ，否则找不到 <code>expect</code> 、 <code>describe</code>  等变量的定义。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;types&quot;</span>: [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;jest&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总之，cloudbase-cli 的测试用例写的比 vemo 好，哈哈</strong></p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>持续继承测试我们借助  <a href="https://travis-ci.org/">https://travis-ci.org/</a>  这个平台，它的工作流程非常简单：</p>
<ol>
<li>在它平台上授权 github 仓库的权限，github 仓库下配置  .travis.yml 文件</li>
<li>每次 commit 推上新代码的时候，travis-ci 平台都会接收到通知</li>
<li>读取 .travis.yml 文件，<strong>然后创建一个虚拟环境</strong>，来跑配置好的脚本（比如启动测试脚本）</li>
</ol>
<p>它的优点在于，测试代码推上去后，直接在账号下的控制台就能看到测试结果，非常方便；而且可以在配置文件中，指明多个测试环境，比如 node 有 6、8、10，让测试更具有信服力。</p>
<p>我把样例代码放在了 <a href="https://github.com/dongyuanxin/try-travis-ci">try-travis-ci</a>  仓库下，可以跑一下看看。下面是 .travis.yml 文件内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">&#x27;node_js&#x27;</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;8&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>看见了吗，就是下面贼酷炫的界面，登陆用户就能看到了：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1556960049220-d204d334-21fb-4963-9095-e37d1600ac4b.png#align=left&display=inline&height=784&name=image.png&originHeight=980&originWidth=1908&size=147774&status=done&width=1526.4" alt="image.png"></p>
<h2 id="覆盖率统计"><a href="#覆盖率统计" class="headerlink" title="覆盖率统计"></a>覆盖率统计</h2><p>覆盖率统计也很简单（本来以为会很难），但是要安装 <code>coveralls</code>  这个库。除此之外，还要修改一下 package.json 中的 scripts 的指令。通过管道，将结果交给 coveralls。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest --passWithNoTests --coverage --env=node --detectOpenHandles --coverageReporters=text-lcov | coveralls&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来发现，在统计覆盖率的时候，会把覆盖的信息放在根目录下的 <code>coverage</code>  文件夹下，这些信息都是多个平台约定好的数据格式。所以各个工具间可以共同使用。</p>
<p>剩下要做的就是，登陆 coveralls.io 平台，授权 github 仓库权限。当你在 travis 平台运行上述 scripts 脚本时候，它就自动把结果扔到了 coveralls.io 平台。登陆账号，就能看到覆盖率了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>  《持续集成服务 Travis CI 教程》：<a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html?20190430165111">http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html?20190430165111</a></li>
<li>  Travis CI Document：<a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/#stq=&stp=0">https://docs.travis-ci.com/user/languages/javascript-with-nodejs/#stq=&amp;stp=0</a></li>
<li>  Coveralls IO JavaScript Document：<a href="https://docs.coveralls.io/javascript">https://docs.coveralls.io/javascript</a></li>
<li>  第三方库 node-coveralls：<a href="https://github.com/nickmerwin/node-coveralls">https://github.com/nickmerwin/node-coveralls</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试</title>
    <url>/2019/04/22/hou-duan-kai-fa/nodejs/03.ce-shi/03.dan-yuan-ce-shi/</url>
    <content><![CDATA[<p>一般而言我们若不借助工具开发者工具做测试的话,会采用以下几种测试方法<br>为了方便我们新建一个文件夹用来存放此次测试的文件：<code>mkdir API-testing</code>。</p>
<h3 id="1-常规测试"><a href="#1-常规测试" class="headerlink" title="1.常规测试"></a>1.常规测试</h3><p><code>cd API-testing</code>后新建一个文件。<br><code>math.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev + curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mul:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev * curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面编写完我们需求测试的函数功能后紧接着我们根据需求来新建另一个文件来进行常规测试,改功能模块是否符合达到自己需求的标准。<br><code>simple.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*常规测试用法*/</span></span><br><span class="line"><span class="keyword">const</span> &#123;add, mul&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">add(<span class="number">2</span>,<span class="number">3</span>) === <span class="number">5</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;add(2,3) === 5&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;add(2,3) !== 5, error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    add(2,3) === 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样测试不仅效率低、成本高、而且耗费时间长。</p>
</blockquote>
<h3 id="2-内置模块assert"><a href="#2-内置模块assert" class="headerlink" title="2.内置模块assert"></a>2.内置模块assert</h3><p>由于此次测试依旧使用上面<code>math.js</code>文件这里就不过多复写了。<br><a href="http://nodejs.cn/api/assert.html">官网内置API</a>     </p>
<p><code>simple.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;add, mul&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(assert.equal(add(<span class="number">2</span>,<span class="number">3</span>), <span class="number">5</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    undefined   #代表不报错是正确的,若是将5改为6则会error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不显式的显示正确还是错误,这样不利于维护</p>
</blockquote>
<h3 id="3-chai模块"><a href="#3-chai模块" class="headerlink" title="3.chai模块"></a>3.chai模块</h3><p>由于属于第三方模块所以我们需要先安装一下：<code>npm install chai --save</code>。<br>具体模块详细使用<a href="https://www.chaijs.com/">参考官网</a></p>
<p>由于此次测试依旧使用上面<code>math.js</code>文件这里就不过多复写了。<br><code>simple.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;should, expect, assert&#125; = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;add, mul&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">should();</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">3</span>).should.equal(<span class="number">5</span>)); <span class="comment">//返回一个对象</span></span><br><span class="line">expect(add(<span class="number">2</span>, <span class="number">3</span>)).to.be.equal(<span class="number">5</span>);</span><br><span class="line">assert.equal(add(<span class="number">2</span>, <span class="number">4</span>), <span class="number">5</span>);     <span class="comment">//AssertionError</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>chai模块是不错的选择,但是这样手动写是非常凌乱的,所以需要借助<code>mocha</code>来管理。</p>
</blockquote>
<h3 id="4-mocha"><a href="#4-mocha" class="headerlink" title="4.mocha"></a>4.mocha</h3><p>诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。</p>
<p>所谓”测试框架”，就是运行测试的工具。通过它，可以为JavaScript应用添加测试，从而保证代码的质量。</p>
<p>mocha旨在帮你跑各种各样的断言库,mocha本身是不包含断言库的。<br>在使用之前我们先安装一下:<code>npm install mocha --save</code>。</p>
<p><a href="https://github.com/mochajs/mocha">项目地址</a><br><a href="https://mochajs.org/">官网详细使用</a><br><code>math.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev + curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mul:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev * curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mocha.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;should, expect, assert&#125; = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;add, mul, cover&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;#math&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    describe(<span class="string">&#x27;add&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;should return 5 then 2 + 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            expect(add(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>);      </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it.skip(<span class="string">&#x27;should return -1 then 2 - 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;   <span class="comment">//only(仅测试这条),skip(跳过)</span></span><br><span class="line">            expect(add(<span class="number">2</span>, -<span class="number">3</span>), -<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(<span class="string">&#x27;mul&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;should return 6 then 2 * 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// expect(mul(2, 3), 5); 		//测试时这样写也不报错????</span></span><br><span class="line">            expect(mul(<span class="number">2</span>, <span class="number">3</span>)).to.be.equal(<span class="number">6</span>);   	<span class="comment">//最正确写法测试</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>cmd下使用<code>mocha mocha.js</code>即可测试结果。<br>或者自行在<code>package.json</code>中<code>scripts:&quot;test&quot;: &quot;mocha mocha.js&quot;</code>,后使用<code>npm test</code>即可测试。</p>
<h3 id="5-测试覆盖率"><a href="#5-测试覆盖率" class="headerlink" title="5.测试覆盖率"></a>5.测试覆盖率</h3><p>本次使用测试工具为<code>istanbul</code>旨在测试代码使用覆盖率。它使我们能够更轻松地测试跨耦合模块的API更改。这是一个用JS编写的JS代码覆盖率工具。</p>
<p><a href="https://github.com/gotwarlost/istanbul">项目地址</a><br><a href="https://istanbul.js.org/">官网地址</a>    </p>
<p>使用<code>npm install -g istanbul</code>安装好测试工具。<br>在<code>package.json</code>中<code>scripts</code>插入下面语句后<code>npm run cover</code>即可测试</p>
<ul>
<li>Linux中使用插入<code>&quot;cover&quot;: &quot;istanbul cover _mocha mocha.js&quot;</code></li>
<li>Window中使用插入<code>&quot;cover&quot;: &quot;node_modules/mocha/bin/_mocha test/mocha.js&quot;</code><br><code>math.js</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> (b - a) * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev + curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mul:<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">prev, curr</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev * curr;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    cover:<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">a == b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> min(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//不调用</span></span><br></pre></td></tr></table></figure>
<code>mocha.js</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;should, expect, assert&#125; = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;add, mul, cover&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../math.js&#x27;</span>);  <span class="comment">//#注1</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;#math&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    describe(<span class="string">&#x27;add&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;should return 5 then 2 + 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            expect(add(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>);      </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it.skip(<span class="string">&#x27;should return -1 then 2 - 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;   <span class="comment">//only(仅测试这条),skip(跳过)</span></span><br><span class="line">            expect(add(<span class="number">2</span>, -<span class="number">3</span>), -<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(<span class="string">&#x27;mul&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;should return 6 then 2 * 3&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// expect(mul(2, 3), 5); //测试时这样写也能通过????,不是等于6吗</span></span><br><span class="line">            expect(mul(<span class="number">2</span>, <span class="number">3</span>)).to.be.equal(<span class="number">6</span>);   <span class="comment">//一定要这样测试</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    describe(<span class="string">&#x27;cover&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        it(<span class="string">&#x27;should return 1 then cover(2, 1)&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            expect(cover(<span class="number">2</span>, <span class="number">1</span>)).to.be.equal(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&#x27;should return 3 then cover(1, 2)&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            expect(cover(<span class="number">1</span>, <span class="number">2</span>)).to.be.equal(<span class="number">3</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        it(<span class="string">&#x27;should return 4 then cover(2, 2)&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            expect(cover(<span class="number">2</span>, <span class="number">2</span>)).to.be.equal(<span class="number">4</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注1：测试过程中<code>./math.js</code>将相同代码放在与<code>mocha.js</code>同一文件夹并不会显示测试覆盖率,只有将<code>math.js</code>文件放在上级目录后<code>../math.js</code>调用才能显示代码覆盖率…懵。</p>
</blockquote>
</li>
</ul>
<p>npm run cover输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Statements   : <span class="number">100</span>% ( <span class="number">14</span>/<span class="number">14</span> )</span><br><span class="line">Branches     : <span class="number">100</span>% ( <span class="number">4</span>/<span class="number">4</span> )</span><br><span class="line">Functions    : <span class="number">50</span>% ( <span class="number">1</span>/<span class="number">2</span> )  <span class="comment">//因为有个函数a尚未被没被调用</span></span><br><span class="line">Lines        : <span class="number">100</span>% ( <span class="number">14</span>/<span class="number">14</span> )</span><br></pre></td></tr></table></figure>
<p>其在当前目录下也会生成一个<code>coverage</code>目录</p>
<h3 id="6-持续集成"><a href="#6-持续集成" class="headerlink" title="6.持续集成"></a>6.持续集成</h3><p>持续集成是一种软件开发流程,他有俩个特性：</p>
<ul>
<li>频繁地将代码集成到主干</li>
<li>每次集成都通过自动化的构建来验证</li>
</ul>
<p>持续继承的优点：</p>
<ul>
<li>及时反馈结果，尽早发现问题</li>
<li>防止分支大幅偏离主干</li>
<li>自动化代替上面的手工，工程师将更多的时间精力放在设计、需求分析、风险预防等方面；</li>
</ul>
<h4 id="获得版本测试图标"><a href="#获得版本测试图标" class="headerlink" title="获得版本测试图标"></a>获得版本测试图标</h4><p>首先必须先使用下面账户同步项目。选择打开需求的项目<br><a href="https://travis-ci.org/">必须git账户同步</a><br><a href="https://github.com/dwyl/repo-badges">图标获得</a>     </p>
<p>接着在项目本地新建本件<code>.travis.yml</code>内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - <span class="string">&quot;6&quot;</span></span><br><span class="line">  - <span class="string">&quot;7&quot;</span></span><br><span class="line">  - <span class="string">&quot;10&quot;</span></span><br><span class="line">brancher:</span><br><span class="line">  only:</span><br><span class="line">    - <span class="string">&quot;dev&quot;</span></span><br><span class="line">    - <span class="string">&quot;master&quot;</span></span><br><span class="line">script:</span><br><span class="line">  - <span class="string">&quot;npm run cover&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后将1-4步骤的项目git上github。即可通过<a href="https://travis-ci.org/">查看</a>在网上的自我<code>build</code>测试信息。(必须先在<a href="https://travis-ci.org/">查看</a>上启动项目名才行)<br>等待时间测试的6、7、10版本没有通过点击<code>build jobs</code>查看具体错误信息。</p>
<p>测试通过后选取通过图标的编码,这里选择markdown格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**图注1: **</span><br><span class="line"></span><br><span class="line">[![Build Status](https:&#x2F;&#x2F;travis-ci.org&#x2F;root-lucas&#x2F;testing3.svg?branch&#x3D;master)](https:&#x2F;&#x2F;travis-ci.org&#x2F;root-lucas&#x2F;testing3)</span><br></pre></td></tr></table></figure>

<h4 id="获得测试覆盖率图标"><a href="#获得测试覆盖率图标" class="headerlink" title="获得测试覆盖率图标"></a>获得测试覆盖率图标</h4><p>测试通过后使用git账户登录<a href="https://codecov.io/">代码覆盖率图片链接</a>选择相应项目后修改<code>.travis.yml</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - <span class="string">&quot;8&quot;</span></span><br><span class="line">  - <span class="string">&quot;10&quot;</span></span><br><span class="line">brancher:</span><br><span class="line">  only:</span><br><span class="line">    - <span class="string">&quot;dev&quot;</span></span><br><span class="line">    - <span class="string">&quot;master&quot;</span></span><br><span class="line">install:</span><br><span class="line">  - <span class="string">&quot;npm install&quot;</span></span><br><span class="line">  - <span class="string">&quot;npm install -g codecov&quot;</span></span><br><span class="line">script:</span><br><span class="line">  - <span class="string">&quot;npm run cover&quot;</span></span><br><span class="line">  - <span class="string">&quot;codecov&quot;</span></span><br></pre></td></tr></table></figure>
<p>将<a href="https://codecov.io/">代码覆盖率图片链接</a>的Settings——Badge同样复制markdown格式图片。</p>
<p>接着将上面图注1:以及以上获得的图片粘贴至本地项目的<code>README.md</code>文件去。</p>
<p>最后重新git push提交即可看到自己项目中新增的俩个图片</p>
<blockquote>
<p>若是图片显示未知,可以将<a href="https://codecov.io/">链接</a>的Settings——General——Default Branch——更新图片状态即可在github项目中查看图标了。</p>
</blockquote>
<blockquote>
<p>图标1是编译测试通过了node 8以及10版本可以使用; 图标2则是显示代码覆盖率</p>
</blockquote>
<p>做完上面这些主要是你下次git push项目后,其版本测试以及代码覆盖率的图标会自动生成相应比率图。</p>
<h3 id="7-基准"><a href="#7-基准" class="headerlink" title="7.基准"></a>7.基准</h3><p>基准用于测试频繁使用的API接口的速度,从而选择更优秀的接口。</p>
<p><a href="https://benchmarkjs.com/">官网使用教程</a></p>
<p><code>fn.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    num1: <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">parseInt</span>(n),</span><br><span class="line">    num2: <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Number</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>benchmark.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;num1, num2&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./fn.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Benchmark = <span class="built_in">require</span>(<span class="string">&#x27;benchmark&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> suite = <span class="keyword">new</span> Benchmark.Suite;</span><br><span class="line"></span><br><span class="line">suite.add(<span class="string">&#x27;parseInt&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    num1(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">&#125;).add(<span class="string">&#x27;Number&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    num2(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">&#125;).on(<span class="string">&#x27;cycle&#x27;</span>,<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;).on(<span class="string">&#x27;complete&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Fastestss is &#x27;</span> + <span class="built_in">this</span>.filter(<span class="string">&#x27;fastest&#x27;</span>).map(<span class="string">&#x27;name&#x27;</span>));</span><br><span class="line">&#125;).run(&#123;<span class="string">&#x27;async&#x27;</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.Benchmark语法*/</span></span><br><span class="line"><span class="comment">// add tests</span></span><br><span class="line"><span class="comment">// suite.add(&#x27;RegExp#test&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//   /o/.test(&#x27;Hello World!&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// .add(&#x27;String#indexOf&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//   &#x27;Hello World!&#x27;.indexOf(&#x27;o&#x27;) &gt; -1;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// .add(&#x27;String#match&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//   !!&#x27;Hello World!&#x27;.match(/o/);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// // add listeners</span></span><br><span class="line"><span class="comment">// .on(&#x27;cycle&#x27;, function(event) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(String(event.target));</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// .on(&#x27;complete&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;Fastest is &#x27; + this.filter(&#x27;fastest&#x27;).map(&#x27;name&#x27;));</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// // run async</span></span><br><span class="line"><span class="comment">// .run(&#123; &#x27;async&#x27;: true &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.常规测试：受环境影响不同多次测试结果也不同,且难测*/</span></span><br><span class="line"><span class="comment">// const s1 = Date.now();</span></span><br><span class="line"><span class="comment">// for(let i=0;i&lt;10000;i++)&#123;</span></span><br><span class="line"><span class="comment">//     num1(&#x27;123456&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// const e1 = Date.now();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(e1 - s1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const s2 = Date.now();</span></span><br><span class="line"><span class="comment">// for(let i=0;i&lt;10000;i++)&#123;</span></span><br><span class="line"><span class="comment">//     num2(&#x27;1234567&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// const e2 = Date.now();</span></span><br><span class="line"><span class="comment">// console.log(e2 - s2);</span></span><br></pre></td></tr></table></figure>
<p>$node benchmark.js //测试结果Fastests is parseInt,表示parseInt比Number速度更快</p>
<p><a href="https://jsperf.com/">在线测试基准</a></p>
<blockquote>
<p>本章测试属于API测试范畴</p>
</blockquote>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Jest</tag>
      </tags>
  </entry>
  <entry>
    <title>基于实时数据库：在线对战五子棋小游戏</title>
    <url>/2019/08/14/hou-duan-kai-fa/nodejs/04.serverless/01.ji-yu-shi-shi-shu-ju-ku-zai-xian-dui-zhan-wu-zi-qi-xiao-you-xi/</url>
    <content><![CDATA[<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1 项目概述"></a>1 项目概述</h2><p>游戏开发，尤其是微信小游戏开发，是最近几年比较热门的话题。</p>
<p>本次「云开发」公开课，将通过实战「在线对战五子棋」，一步步带领大家，在不借助后端的情况下，利用「小程序 ✖ 云开发」，独立完成一款微信小游戏的开发与上线。</p>
<h2 id="2-任务目标"><a href="#2-任务目标" class="headerlink" title="2 任务目标"></a>2 任务目标</h2><p>根据项目初始框架，阅读教程的同时，逐步完成棋盘绘制、音乐播放、玩家对战、输赢判定等功能，最终实现一个可以快乐玩耍的在线对战五子棋。</p>
<p>在这个过程中，会了解到 Serverless 的一些概念，并且实际应用它们，比如：<strong>云数据库</strong>、<strong>云存储</strong>、<strong>云函数</strong>、<strong>增值能力</strong>。除了这些基本功能，还准备了更多的硬核概念与落地实践，比如：<strong>实时数据库</strong>、<strong>聚合搜索</strong>、<strong>权限控制</strong>。</p>
<p>完成开发后，上传并且设置为体验版，欢迎邀请更多人来体验。</p>
<h2 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3 准备工作"></a>3 准备工作</h2><p>从 <a href="https://github.com/TencentCloudBase/tcb-game-gomoku">TencentCloudBase/tcb-game-gomoku</a> 中下载代码到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/TencentCloudBase/tcb-game-gomoku.git</span><br><span class="line"><span class="built_in">cd</span> tcb-game-gomoku/</span><br></pre></td></tr></table></figure>

<p>切换课程专用的 <code>minigame-study</code> 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout minigame-study</span><br></pre></td></tr></table></figure>

<p>⚠️<code>minigame</code>分支保存着「小游戏版」的完整代码，<code>miniprogram</code>分支保存着「小程序版」的完整代码。</p>
<h2 id="4-游戏流程图"><a href="#4-游戏流程图" class="headerlink" title="4 游戏流程图"></a>4 游戏流程图</h2><p>小游戏版本的核心放在了实时对战上，中间穿插应用了云开发的各个方面。如果想体验完整的流程与交互，请前往<a href="https://github.com/TencentCloudBase/tcb-game-gomoku/tree/miniprogram"><code>miniprogram</code>分支</a>。</p>
<p><img src="https://github.com/TencentCloudBase/tcb-game-gomoku/raw/minigame/static/%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p>
<h2 id="5-实战任务"><a href="#5-实战任务" class="headerlink" title="5 实战任务"></a>5 实战任务</h2><h3 id="5-1-创建云开发与小游戏环境"><a href="#5-1-创建云开发与小游戏环境" class="headerlink" title="5.1 创建云开发与小游戏环境"></a>5.1 创建云开发与小游戏环境</h3><p>1、打开微信 IDE，点击左侧的小游戏，选择右侧的导入项目，导入之前下载的「在线对战五子棋」的目录，AppID 修改为你已经注册好的小游戏 AppID。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686430445_67dhgo46ds9.png/0"></p>
<p>2、进入后，点击上方的云开发按钮。如果之前没有开通过云开发，需要开通云开发，新开通的话需要等待 10 ～ 20 分钟。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686451687_pdl8t1onir.png/0"></p>
<p>3、进入「云开发/数据库」，创建新的集合，新集合的名称是<code>rooms</code>。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686465563_rx5zo815jmj.png/0"></p>
<p>4、进入「云开发/存储」，点击“上传文件”。上传的内容是<code>/static/</code>下的<code>bgm.mp3</code> 和 <code>fall.mp3</code>。之后的代码中会通过云存储的接口，请求文件的临时 url，这样做的目的是<strong>减少用户首次进入游戏加载的静态资源</strong>。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686476650_7pts6bn8fr.png/0"></p>
<h3 id="5-2-准备配置文件"><a href="#5-2-准备配置文件" class="headerlink" title="5.2 准备配置文件"></a>5.2 准备配置文件</h3><p>创建配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp miniprogram/shared/config.example.js miniprogram/shared/config.js</span><br></pre></td></tr></table></figure>

<p>将关键字段的信息，换成自己账号的信息即可：</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686524751_pxxe5yawz6m.png/0"></p>
<h3 id="5-3-创建云开发接口"><a href="#5-3-创建云开发接口" class="headerlink" title="5.3 创建云开发接口"></a>5.3 创建云开发接口</h3><p>打开 <code>miniprogram/shared/cloud.js</code>，在里面初始化云开发能力，并且对外暴露云数据库以及聚合搜索的 API。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686536274_yusm5uxcxab.png/0"></p>
<h3 id="5-4-获取云存储资源的链接"><a href="#5-4-获取云存储资源的链接" class="headerlink" title="5.4 获取云存储资源的链接"></a>5.4 获取云存储资源的链接</h3><p>为了减少用户首屏加载的静态资源，音乐资源并没有放在<code>miniprogram</code>目录下，而是放在了云存储中，通过调用云存储的 api 接口，来返回静态资源的临时链接。</p>
<p>在 <code>miniprogram/modules/music.js</code>中，会调用资源接口，获取资源链接：</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686547006_efn2rd6bu4f.png/0"></p>
<p><code>getTempFileURL</code>函数属于云开发相关，因此放在了 <code>miniprogram/shared/cloud.js</code>中。这里只需要临时链接<code>tempFileURL</code>属性，其它返回值直接过滤调即可。</p>
<p>为了方便外面调用，promise 内部不再用 reject 抛错。对于错误异常，返回空字符串。这样，加载失败的资源不会影响正常资源的加载和 Promise.all 中逻辑进行。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686556058_24v2t5tkr4c.png/0"></p>
<h3 id="5-5-游戏进入与身份判断"><a href="#5-5-游戏进入与身份判断" class="headerlink" title="5.5 游戏进入与身份判断"></a>5.5 游戏进入与身份判断</h3><p>根据前面的流程图我们可以看到，游戏玩家的身份是分为 owner 与 player。它们的含义如下：</p>
<ul>
<li>  owner：玩家进入游戏后，查找是否有空闲房间，如果不存在空闲房间，那么就会主动创建新的空闲房间。那么对于新创建的房间，玩家就是 owner。</li>
<li>  player：玩家进入游戏后，查找是否有空闲房间，如果存在空闲房间，那么就加入空闲房间。那么对于空闲房间，玩家就是 player。</li>
</ul>
<p>判断的依据就是 <code>judgeIdentity</code> 方法中，读取云数据库集合中的 rooms 的记录。如果存在多个空闲房间，需要选取创建时间最近的一个房间。因此，这里需要用到「聚合搜索」的逻辑。</p>
<p>聚合搜索的条件，在这里有 3 个：</p>
<ol>
<li>标记人数的字段，是否为 1</li>
<li>创建时间倒叙排序</li>
<li>只选择 1 个</li>
</ol>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686565847_3yze316092d.png/0"></p>
<h3 id="5-6-创建新房间"><a href="#5-6-创建新房间" class="headerlink" title="5.6 创建新房间"></a>5.6 创建新房间</h3><p>在上述的身份判断函数逻辑中，如果聚合搜索查询的结果为空，说明没有空闲房间，玩家需要作为 owner 来创建新的房间，等待其它玩家加入。</p>
<p>创建房间的逻辑就是将约定好的字段，放进云数据库的记录中。这些字段有：</p>
<ul>
<li>  roomid&lt;<code>String</code>&gt;: 6 位房间号，<strong>唯一</strong></li>
<li>  nextcolor&lt;<code>&quot;white&quot; | &quot;black&quot;</code>&gt;: 下一步是白棋/黑棋走</li>
<li>  chessmen&lt;<code>String</code>&gt;: 编码后的棋盘数据</li>
<li>  createTimestamp&lt;<code>String</code>&gt;: 记录创建时间戳，精确到 ms</li>
<li>  people&lt;<code>Number</code>&gt;: 房间人数</li>
</ul>
<p>是的，你可能注意到了，这里需要保证 roomid 是不重复的。因此本地生成的随机 roomid，需要先调用云数据库的查询接口，检测是否存在。如果存在，那么递归调用，重新生成随机字符串。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686576953_tjr37rmv9ae.png/0"></p>
<h3 id="5-7-监听玩家进入"><a href="#5-7-监听玩家进入" class="headerlink" title="5.7 监听玩家进入"></a>5.7 监听玩家进入</h3><p>对于 owner 身份来说，除了要创建新房间，还需要在创建后监听 player 身份的玩家进入游戏。</p>
<p>对于 player 身份的玩家进入游戏后，会更新记录中的 people 字段（1 =&gt; 2）。这时候就需要利用「实时数据库」的功能，监听远程记录的 people 字段变化。</p>
<p>代码实现上，调用<code>watch</code>方法，并且传递<code>onChange</code>函数参数。一旦有任何风吹草动，都可以在<code>onChange</code>回调函数中获得。对于传递给回调函数的参数，有两个比较重要：</p>
<ul>
<li>  docChanges&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的变化类型，变化类型有 init、update、delete 等。</li>
<li>  docs&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的当前数据。</li>
</ul>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686591306_os588ni3m8.png/0"></p>
<h3 id="5-8-越权更新字段"><a href="#5-8-越权更新字段" class="headerlink" title="5.8 越权更新字段"></a>5.8 越权更新字段</h3><p>对于 player 身份来说，进入房间后，既不需要「创建新房间」，也不需要「监听玩家进入」。但需要更新记录的 people 字段。由于记录是由 owner 身份的玩家创建的，而云数据库只有以下 4 种权限：</p>
<ul>
<li>  所有用户可读，仅创建者可读写</li>
<li>  仅创建者可读写</li>
<li>  所有用户可读</li>
<li>  所有用户不可读写</li>
</ul>
<p>以上 4 种权限，并没有「所有用户可读写」。因此，对于越权读写的情况，需要通过调用云函数来以“管理员”的权限实现。在 <code>cloudfunction</code> 中创建 <code>updateDoc</code> 云函数，接收前端传来的 collection、docid、data 字段。对于 data 字段来说，就是数据记录的最新更新数据。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686600499_7jw2an2f8er.png/0"></p>
<p>在小游戏中，通过<code>wx.cloud.callFunction</code>来调用云函数。传入的 data 字段指明被调用的云函数，传入的 data 字段可以在云函数的回调函数的 event 参数中访问到（如上图所示）。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686609491_51yce50b2tf.png/0"></p>
<h3 id="5-9-落子更新逻辑"><a href="#5-9-落子更新逻辑" class="headerlink" title="5.9 落子更新逻辑"></a>5.9 落子更新逻辑</h3><p>不论对于 player 还是 owner 身份，都需要处理落子的逻辑。落子逻辑中，下面的两种情况是属于无效落子：</p>
<ol>
<li>点击位置已经有棋子</li>
<li>对方还未落子，目前依然处于等待情况</li>
</ol>
<p>对于以上两种情况，处理的逻辑分别是：</p>
<ol>
<li>棋盘状态保存在内部类中，调用落子的函数，会返回是否成功的字段标识</li>
<li>只有监听到远程棋盘更新后，才会打开本地的锁，允许落子；落子后，会重新上锁</li>
</ol>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686620401_gfziqov00gm.png/0"></p>
<p>落子成功后，要在本地判断是否胜利。如果胜利，需要调用退出的逻辑。但无论是否胜利，都要将本地的最新状态更新到云端。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686628911_zv5160zwrhb.png/0"></p>
<h3 id="5-10-监听远程棋盘更新"><a href="#5-10-监听远程棋盘更新" class="headerlink" title="5.10 监听远程棋盘更新"></a>5.10 监听远程棋盘更新</h3><p>不论对于 player 还是 owner 身份的玩家，都需要监听远程棋盘的更新逻辑。当远程棋盘字段更新时，本地根据最新的棋盘状态，重绘整个棋盘。并且进行输赢判定，如果可以判定输赢，则退出游戏；否则，打开本地的锁，玩家可以落子。</p>
<p><strong>因为不同身份均需要监听，因此这一块的监听逻辑可以复用</strong>。<strong>不同的是，两种身份的监听启动时间不一样</strong>。owner 身份需要等待 player 身份玩家进入游戏后才开启棋盘监听；player 身份是更新了 people 字段后，开启棋盘监听。</p>
<p>在监听逻辑中，需要判断远程更新的字段是否是 chessmen，这是通过前面提及的 dataType 来实现的。还徐哟啊判断记录中的 nextcolor 字段是否和本地的 color 一样，来决定是否打开本地的锁。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686878918_0fvrbmcw7xw.png/0"></p>
<p>如果上述的两个条件均满足，则执行更新本地棋盘、判定输赢、打开本地锁的逻辑。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686968256_u9wfsb9tcjj.png/0"></p>
<h3 id="5-11-游戏结束与退出"><a href="#5-11-游戏结束与退出" class="headerlink" title="5.11 游戏结束与退出"></a>5.11 游戏结束与退出</h3><p>每次需要判定输赢的地方，如果可以判定输赢，那么都会走到游戏退出逻辑。退出的逻辑分为 2 个部分，第 1 个是给用户提示，第 2 个是调用云函数清空记录。</p>
<p>第 1 个逻辑中用户提示，需要判定用户胜负状态：</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686982496_8w7g8tn7owp.png/0"></p>
<p>第 2 个逻辑中清除记录的原因是为了方便调试，对于真正的业务场景，一般不会删除历史数据，方便问题定位。同时，这也是一个越权操作，需要调用云函数来实现。</p>
<p><img src="https://puui.qpic.cn/vupload/0/20190813_1565686993095_7g1lsvvydsn.png/0"></p>
<h2 id="6-课程完整源码"><a href="#6-课程完整源码" class="headerlink" title="6. 课程完整源码"></a>6. 课程完整源码</h2><p><a href="https://github.com/TencentCloudBase/tcb-game-gomoku">https://github.com/TencentCloudBase/tcb-game-gomoku</a></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS实现简易区块链</title>
    <url>/2019/05/02/hou-duan-kai-fa/nodejs/05.geng-duo/01.nodejs-shi-xian-jian-yi-qu-kuai-lian/</url>
    <content><![CDATA[<p>之前由于课程要求，基于 Nodejs 做了一个实现简易区块链。要求非常简单，结构体记录区块结构，顺便能向链中插入新的区块即可。</p>
<p>但是如果要支持多用户使用，就需要考虑“可信度”的问题。那么按照区块链要求，链上的数据不能被篡改，除非算力超过除了攻击者本身之外其余所以机器的算力。</p>
<p>想了想，就动手做试试咯。</p>
<h2 id="技术调研-🔍"><a href="#技术调研-🔍" class="headerlink" title="技术调研 🔍"></a>技术调研 🔍</h2><p>在 google 上搜了搜，发现有个项目不错： <a href="https://github.com/lhartikk/naivechain">https://github.com/lhartikk/naivechain</a> 。大概只有 200 行，但是其中几十行都是关于搭建 ws 和 http 服务器，美中不足的是没有实现批量插入区块链和计算可信度。</p>
<p>结合这个项目，基本上可以确定每个区块会封装成一个 class（结构化表示），区块链也封装成一个 class，再对外暴露接口。</p>
<h2 id="区块定义"><a href="#区块定义" class="headerlink" title="区块定义"></a>区块定义</h2><p>为了方便表示区块，将其封装为一个 class，它没有任何方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 区块信息的结构化定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">index</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">previousHash</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">timestamp</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">hash</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">index, previousHash, timestamp, data, hash</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index <span class="comment">// 区块的位置</span></span><br><span class="line">        <span class="built_in">this</span>.previousHash = previousHash + <span class="string">&#x27;&#x27;</span> <span class="comment">// 前一个区块的hash</span></span><br><span class="line">        <span class="built_in">this</span>.timestamp = timestamp <span class="comment">// 生成区块时候的时间戳</span></span><br><span class="line">        <span class="built_in">this</span>.data = data <span class="comment">// 区块本身携带的数据</span></span><br><span class="line">        <span class="built_in">this</span>.hash = hash + <span class="string">&#x27;&#x27;</span> <span class="comment">// 区块根据自身信息和规则生成的hash</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于怎么生成 hash，这里采用的规则比较简单：</p>
<ol>
<li>拼接 index、previouHash、timestamp 和 data，将其字符串化</li>
<li>利用 sha256 算法，计算出的记过就是 hash</li>
</ol>
<p>为了方便，会引入一个加密库：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CryptoJS = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="链结构定义"><a href="#链结构定义" class="headerlink" title="链结构定义"></a>链结构定义</h2><p>很多区块链接在一起，就组成了一条链。这条链，也用 class 来表示。并且其中实现了很多方法：</p>
<ol>
<li>按照加密规则生成 hash</li>
<li>插入新块和检查操作</li>
<li>批量插入块和检查操作以及可信度计算</li>
</ol>
<h3 id="1-起源块"><a href="#1-起源块" class="headerlink" title="1. 起源块"></a>1. 起源块</h3><p>起源块是“硬编码”，因为它前面没数据呀。并且规定它不能被篡改，即不能强制覆盖。我们在构造函数中，直接将生成的起源块放入链中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockChain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blocks = [<span class="built_in">this</span>.getGenesisBlock()]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建区块链起源块, 此块是硬编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">getGenesisBlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Block(<span class="number">0</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">1552801194452</span>, <span class="string">&#x27;genesis block&#x27;</span>, <span class="string">&#x27;810f9e854ade9bb8730d776ea02622b65c02b82ffa163ecfe4cb151a14412ed4&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-计算下一个区块"><a href="#2-计算下一个区块" class="headerlink" title="2. 计算下一个区块"></a>2. 计算下一个区块</h3><p>BlockChain 对象可以根据当前链，自动计算下一个区块。并且与用户传来的区块信息比较，如果一样，说明合法，可以插入；否则，用户的区块就是非法的，不允许插入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法都是BlockChain对象方法</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据信息计算hash值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">calcuteHash</span>(<span class="params">index, previousHash, timestamp, data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CryptoJS.SHA256(index + previousHash + timestamp + data) + <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 得到区块链中最后一个块节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">getLatestBlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.blocks[<span class="built_in">this</span>.blocks.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算当前链表的下一个区块</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">blockData</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">generateNextBlock</span>(<span class="params">blockData</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> previousBlock = <span class="built_in">this</span>.getLatestBlock()</span><br><span class="line">    <span class="keyword">const</span> nextIndex = previousBlock.index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> nextTimeStamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="keyword">const</span> nextHash = <span class="built_in">this</span>.calcuteHash(nextIndex, previousBlock.hash, nextTimeStamp, blockData)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Block(nextIndex, previousBlock.hash, nextTimeStamp, blockData, nextHash)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入区块"><a href="#3-插入区块" class="headerlink" title="3. 插入区块"></a>3. 插入区块</h3><p>插入区块的时候，需要检查当前块是否合法，如果合法，那么插入并且返回 true；否则返回 false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向区块链添加新节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Block&#125;</span> <span class="variable">newBlock</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">addBlock</span>(<span class="params">newBlock</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 合法区块</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.isValidNewBlock(newBlock, <span class="built_in">this</span>.getLatestBlock())</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.blocks.push(newBlock)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查的逻辑就就放在了 <code>isValidNewBlock</code>  方法中, 它主要完成 3 件事情：</p>
<ol>
<li>判断新区块的 index 是否是递增的</li>
<li>判断 previousHash 是否和前一个区块的 hash 相等</li>
<li>判断新区块的 hash 是否按约束好的规则生成</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断新加入的块是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Block&#125;</span> <span class="variable">newBlock</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Block&#125;</span> <span class="variable">previousBlock</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">isValidNewBlock</span>(<span class="params">newBlock, previousBlock</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(</span><br><span class="line">    !(newBlock <span class="keyword">instanceof</span> Block) ||</span><br><span class="line">    !(previousBlock <span class="keyword">instanceof</span> Block)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断index</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">newBlock.index !== previousBlock.index + <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断hash值</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">newBlock.previousHash !== previousBlock.hash</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算新块的hash值是否符合规则</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.calcuteHash(newBlock.index, newBlock.previousHash, newBlock.timestamp, newBlock.data) !== newBlock.hash</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-批量插入"><a href="#4-批量插入" class="headerlink" title="4. 批量插入"></a>4. 批量插入</h3><p>批量插入的逻辑比较复杂，比如当前链上有 4 个区块的下标是：0-&gt;1-&gt;2-&gt;3。除了起源块 0 不能被覆盖，当插入一条新的下标为“1-&gt;2-&gt;3-&gt;4”的链时候，就可以替换原来的区块。最终结果是：0-&gt;1-&gt;2-&gt;3-&gt;4。</p>
<p>在下标 index 的处理上，假设还是上面的情况，如果传入的链的下标是从大于 4 的整数开始，显然无法拼接原来的区块链的下标，直接扔掉。</p>
<p>但是如何保证可信度呢？就是当新链（B 链）替换原来的链（A 链）后，生成新的链（C 链）。如果 length(C) &gt; length(A)，那么即可覆盖要替换的部分。 <strong>这就保证了，只有在算力超过所有算力 50%的时候，才能篡改这条链</strong> 。</p>
<p>插入新链的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入新链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">newChain</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">addChain</span>(<span class="params">newChain</span>)</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.isValidNewChain(newChain)</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = newChain[<span class="number">0</span>].index</span><br><span class="line">    <span class="built_in">this</span>.blocks.splice(index)</span><br><span class="line">    <span class="built_in">this</span>.blocks = <span class="built_in">this</span>.blocks.concat(newChain)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现上面所述逻辑的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断新插入的区块链是否合法而且可以覆盖原来的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">newChain</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">isValidNewChain</span>(<span class="params">newChain</span>)</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">Array</span>.isArray(newChain) === <span class="literal">false</span> || newChain.length === <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newChainLength = newChain.length,</span><br><span class="line">    firstBlock = newChain[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 硬编码的起源块不能改变</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">firstBlock.index === <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移植新的链的长度 &lt;= 现有链的长度</span></span><br><span class="line">  <span class="comment">// 新的链不可信</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">newChainLength + firstBlock.index &lt;= <span class="built_in">this</span>.blocks.length</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面检查新的链能否移植</span></span><br><span class="line">  <span class="comment">// 以及新的链的每个节点是否符合规则</span></span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">!<span class="built_in">this</span>.isValidNewBlock(firstBlock, <span class="built_in">this</span>.blocks[firstBlock.index - <span class="number">1</span>])</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i = <span class="number">1</span>; i &lt; newChainLength; ++i</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!<span class="built_in">this</span>.isValidNewBlock(newChain[i], newChain[i - <span class="number">1</span>])</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-为什么需要批量插入？"><a href="#5-为什么需要批量插入？" class="headerlink" title="5. 为什么需要批量插入？"></a>5. 为什么需要批量插入？</h3><p>我当时很奇怪，为什么需要“批量插入”这个方法。后来想明白了（希望没想错）。假设服务器 S，以及两个用户 A 与 B。</p>
<p>A 与 B 同时拉取到已知链的数据，然后各自生成。A 网速较快，但是算力低，就生成了 1 个区块，放入了 S 上。注意：此时 S 上的区块已经更新。</p>
<p>而 B 比较惨了，它在本地生成了 2 个区块，但是受限于网速，只能等网速恢复了传入区块。这时候，按照规则，它是可以覆盖的（算力高嘛）。所以这种情况下，服务器 S 接受到 B 的 2 个区块，更新后的链长度是 3（算上起源块），并且 A 的那个区块已经被覆盖了。</p>
<h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>虽然没有写服务器，但是还是模拟了上面讲述的第 5 种情况。代码在 <code>test.js</code>  文件中，直接 run 即可。看下效果截图吧：</p>
<p><img src="https://s2.ax1x.com/2019/12/23/lpUVHA.jpg" alt="image.png"></p>
<p>红线上面就是先算出来的，红线下面就是被算力更高的客户端篡改后的区块链。具体模拟过程可以看代码，这里不再冗赘了。</p>
<p>全部代码在都放在： <a href="https://github.com/root-lucas/Blog-demos/tree/master/nodeJS/node-blockchain">https://github.com/root-lucas/Blog-demos/tree/master/nodeJS/node-blockchain</a></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡：轮询调度算法实现</title>
    <url>/2019/05/04/hou-duan-kai-fa/nodejs/05.geng-duo/02.fu-zai-jun-heng-lun-xun-diao-du-suan-fa-shi-xian/</url>
    <content><![CDATA[<p>最近在学习 cluster 的时候，了解到它的负载均衡以及 NGINX 的负载均衡都是基于“轮询调度”算法来实现的。它由 Round Robin 提出，所以又称为“rr 算法”。除此之外，负载均衡使用的是基于权重的“wrr 算法”。为了深入理解，我这里都做了实现。</p>
<h2 id="RR-算法"><a href="#RR-算法" class="headerlink" title="RR 算法"></a>RR 算法</h2><p>它的实现思路是：每一次把来自用户的请求轮流分配给内部中的服务器，从 1 开始，直到 N(内部服务器个数)，然后再从头开始分配。一直重复以上过程。</p>
<p>毫无疑问，它的优点是实现简单，而且不需要统计服务器状态以及连接状态，是无状态调度，所以消耗极低。在配置基本一致的集群上，使用这种算法即可。</p>
<p>在实现过程中，利用了 es6 提供的生成器，方便调用。请看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">rr</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i++ % num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NUM = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> reqTimes = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> cluster = rr(NUM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reqTimes; ++i) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cluster.next().value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WRR-算法"><a href="#WRR-算法" class="headerlink" title="WRR 算法"></a>WRR 算法</h2><p>在实际环境中，很少有集群上单机算力完全一样的情况。假设每个单机都有一个权重数据，代表它们目前的能力。那么 WRR 算法就可以根据这组数据，来将不同的请求导给不同的单机，以保证流量比等于权重比。</p>
<p>而对于 WRR 算法如何根据权重分配流量，以及为什么在代码中计算所有数据的最大公约数，就需要理解它的原理，你可以称之为“锚点移动”。请看下面的图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/233327/1556978305074-56f95a8b-5cd8-454d-bcb1-1a297162b8eb.png#align=left&display=inline&height=541&originHeight=541&originWidth=941&size=0&status=done&width=941"></p>
<p>如图所示，最大公约数就是能够切分每个权重的最小单位（都能切成整份，方便处理）。锚点 P<strong>从右向左移动</strong>，步长就是最大公约数。停下来之后，<strong>再从上到下扫描</strong>，扫描到的，就是可以分配的流量。然后再从右向左移动，重复上面步骤，直到锚点 P 到达最左侧。</p>
<p>这个过程中，对于单机来说，被选中的次数就是 Weight/div 。div 是一定的，所以选中次数和权重成正比。</p>
<p>代码首先实现求最大公约数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求x, y的最大公约数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">y</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// x: 462; y: 1071</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// y是被取余对象</span></span><br><span class="line">    <span class="comment">// x是组成部分</span></span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 之前的余数为0, 可以整除</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1071 = 2 * 462 + 147</span></span><br><span class="line">    <span class="comment">// x组成部分变成被取余对象</span></span><br><span class="line">    <span class="comment">// 余数变成组成部分</span></span><br><span class="line">    <span class="keyword">return</span> gcd(y % x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * n个数的最大公约数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">arr</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nGcd</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Param should be Array&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = arr[<span class="number">0</span>],</span><br><span class="line">        length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        result = gcd(result, arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrr 算法也是借助迭代器，当然，也可以一次性计算出所有的分配队列：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">wrr</span>(<span class="params">weights</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(weights)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Param should be Array&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hcf = nGcd(weights) <span class="comment">// highest common factor: 最大公约数</span></span><br><span class="line">    <span class="keyword">let</span> i = -<span class="number">1</span>,</span><br><span class="line">        cw = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % weights.length</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            cw = cw - hcf</span><br><span class="line">            <span class="keyword">if</span> (cw &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cw = <span class="built_in">Math</span>.max(...weights) <span class="comment">// Math.max(arg1, arg2, arg3, ...) // 注意参数的坑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (weights[i] &gt;= cw) &#123;</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下。用生成器实现的好处显示出来了，不需要一次性计算全部，用到的时候，调用 <code>next()</code>  会继续计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(gcd(<span class="number">1071</span>, <span class="number">462</span>))</span><br><span class="line"><span class="built_in">console</span>.log(nGcd([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">16</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weights = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> sumWeight = weights.reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> cluster = wrr(weights)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sumWeight; ++i) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cluster.next())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一台机子被分配了3n次，其他机子也是按照比例的</span></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>IPVS 和 Nginx 两种 WRR 负载均衡算法详解</p>
<ul>
<li>  Weighted Round-Robin Scheduling：<a href="http://kb.linuxvirtualserver.org/wiki/Weighted_Round-Robin_Scheduling">http://kb.linuxvirtualserver.org/wiki/Weighted_Round-Robin_Scheduling</a></li>
<li>  IPVS 和 Nginx 两种 WRR 负载均衡算法详解：<a href="https://blog.csdn.net/dog250/article/details/80115358">https://blog.csdn.net/dog250/article/details/80115358</a></li>
<li>  辗转相除法求最大公约数：<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95</a></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>VemoJS源码拆解</title>
    <url>/2019/04/23/hou-duan-kai-fa/nodejs/05.geng-duo/03.vemojs-yuan-ma-chai-jie/</url>
    <content><![CDATA[<p>主要分析下 src 文件夹下的代码。从简单到难吧：</p>
<h2 id="utils-js"><a href="#utils-js" class="headerlink" title="utils.js"></a>utils.js</h2><p>按照命名，肯定是封装一些常用的方法。这里只提供了一个 cpuNum 的 getter 接口。</p>
<p>这个是计算当前计算机的 cpu 核心数目，用于决定开启多大的集群进程。为了保证效率，最小的返回值是 4。</p>
<h2 id="error-js"><a href="#error-js" class="headerlink" title="error.js"></a>error.js</h2><p>主要从 <code>Error</code>  对象上继承并且创建了新对象： <code>VemoError</code> 。对象构造函数上， <strong>设计了一个有关此框架的错误状态码的信息</strong> 。</p>
<p>除了 <code>VemoError</code> ，还暴露了一些错误的代号定义。</p>
<h2 id="cluster-js"><a href="#cluster-js" class="headerlink" title="cluster.js"></a>cluster.js</h2><p>对外暴露了自定义的高并发集群代码，它引用了同级的 <code>./process.js</code>  封装的管理类，并且初始化了它。它的具体含义请见”process.js”中的讲解。</p>
<h2 id="cloudbase-js"><a href="#cloudbase-js" class="headerlink" title="cloudbase.js"></a>cloudbase.js</h2><p><code>getLocalSecret</code>  方法是读取本地用户的根目录中的 <code>.tcbrc.json</code>  配置文件，并且将 Id 和 Key 放入 <code>process.env</code>  变量中。</p>
<p><code>getTempSecret</code>  方法是获取云主机的临时密钥：</p>
<ol>
<li>正常情况下，访问远程地址，获取 id、key、token 和过期时间，并且放入 <code>process.env</code>  变量中。 <strong>有个不错的设计点：过期时间比远程动态减少 600s，主要是为了提前拉取</strong></li>
<li>异常情况下， <strong>如果没有到达最大失败次数，则在异常捕获中，调用自身，进行重试</strong> 。这里也是一个不错的设计点，包括参数的传递。（不需要用闭包）</li>
<li><strong>改进意见</strong> ：</li>
<li>考虑到网络情况造成的异常情况处理，其实可以使用定时器调用。</li>
<li>检测位置可以提到函数入口，考虑参数为 (0, -1) 的情况</li>
</ol>
<p><br>对外暴露：<br>async 函数，就是拿到有效的临时密钥，并且挂载上下文，继续执行后面的程序（next 参数）。</p>
<h2 id="process-js"><a href="#process-js" class="headerlink" title="process.js"></a>process.js</h2><p>整体的设计思路是：一个主进程，多个工作进程。为了保证工作进程有效，<strong>又采用了”心跳机制” + “生命周期” + “定时检测”3 种机制</strong>来保证有效以及意外情况下的重启机制。</p>
<p>除此之外，在内存不足的时候，会自动降级服务！</p>
<h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><p><code>timer</code>  函数，就是一个类似 setInterval 的函数。与 setInterval 不同的地方有 2 点：</p>
<ol>
<li>回调函数的参数：当前的时间戳</li>
<li>第一次是立即执行的</li>
</ol>
<p><code>restartWorker</code>  函数，专门用来重启工作进程的函数。<br>它首先会检测距离上次批量重启的时间是否太短，太短，则跳过。 <strong>根据全局环境设置，这里的每次自动重启检测的时间是 60s。</strong> <br>否则，循环遍历所有子进程， <strong>检查当前子进程的存活时间是否超过规定（60min）</strong> ，超过，就调用 killWorker 先新建再删除。<br>这个函数的精彩之处，在于时间上的处理。一言：每分钟自动检测进程更新，每个进程都会在 1 小时后被依次自动更新。</p>
<p><code>killWorker</code>  函数，先启动新进程占位，再删除原进程。</p>
<ol>
<li>对于新建的进程：监听 killSelf 新号，重建自己；监听 hearBeat 心跳信号。</li>
<li>对于被替换的老进程：先断开连接，再 2s 后 kill 掉。（ <em>problem：为什么先断链，再关闭呢</em> ？如果有大运算，调用 disconnect 会阻塞并不会关闭 IPC 管道。需要等待 2s 自定义缓冲时间， <strong>再强制 kill</strong> ，不再调用 disconnect，因为还会阻塞）。</li>
</ol>
<h3 id="对外暴露方法"><a href="#对外暴露方法" class="headerlink" title="对外暴露方法"></a>对外暴露方法</h3><p><code>init</code>  函数，初始化进程管理器：</p>
<ol>
<li>对于主进程</li>
<li>根据 cpu 核心创建工作进程</li>
<li>每个工作进程监听 3 种信号并且响应</li>
<li>开启 restartWorker，对于超过生命周期的进程，自动重启</li>
<li>再定义一个 timer，检测每个工作进程存活状态，以及心跳是否正常</li>
<li>对于工作进程</li>
<li>加载 index.js 中的端口逻辑，若有出错，则告知主进程，并且关闭主进程（ <em>problem：主进程会自动关闭其他工作进程吗？</em> cluster 已经帮忙做了，linux 下通过 ps -aux | grep “…” 可以查看）</li>
<li>定义一个 timer，向主进程发送心跳包</li>
<li>定义一个 timer，检测内存占用过高，主进程关闭工作进程（ <em>problem：process.memoryUsage()是全部的吗？是当前进程的信息</em> ）</li>
</ol>
<p><code>reload</code>  函数，重启全部进程：<br></p>
<p>这个设计的很巧妙，因为全部工作进程的创建时间都放在 <code>workerCreateTime</code>  对象中，主进程中又开启了自动重启子进程的 timer（在 120 行）。所以这里直接一个循环，将其所有属性置 0。<br></p>
<p><strong>当然，这并不是同时重启，每个子进程的重启有个间隔，这个间隔可以改进，因为这个间隔期间就是服务器响应能力比较弱的时候</strong></p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><p>在工作进程启动端口相关的服务，主要分为 3 个部分：普通 http 服务、websocket 服务以及静态服务器服务。</p>
<p>请分别调研使用它们的服务对应的库的用法。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML与CSS</title>
    <url>/2018/03/09/mian-shi-bao-dian/01.html-yu-css/</url>
    <content><![CDATA[<h2 id="HTML问题"><a href="#HTML问题" class="headerlink" title="HTML问题"></a>HTML问题</h2><h3 id="说下你对-WEB-标准以及-W3C-的理解与认识"><a href="#说下你对-WEB-标准以及-W3C-的理解与认识" class="headerlink" title="说下你对 WEB 标准以及 W3C 的理解与认识?"></a>说下你对 WEB 标准以及 W3C 的理解与认识?</h3><p><strong>web 标准：</strong> 简单来说可以分为结构、表现和行为。其中结构主要是有 HTML 标签组成。或许通俗点说，在页面 body 里面我们写入的标签都是为了页面的结构。表现即指 css 样式表，通过 css 可以是页面的结构标签更具美感。行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是有 js 组成。</p>
<p>web 标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p>
<p><strong>W3C</strong> 对 web 标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点</p>
<p>1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对 SEO 很有帮助）</p>
<p>1）。标签字母要小写</p>
<p>2）。标签要闭合</p>
<p>3）。标签不允许随意嵌套</p>
<p>2.对于 css 和 js 来说</p>
<p>1）。能提高搜索机器人的搜索几率,内容能被更广泛的用户所访问,尽量使用外链 css 样式表和 js 脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。</p>
<p>2）。样式尽量少用行间样式表，使结构与表现分离，标签的 id 和 class 等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版</p>
<p>3）。使用更少的代码和组件，使其容易维护改版方便，不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</p>
<h3 id="xhtml-和-html-的区别"><a href="#xhtml-和-html-的区别" class="headerlink" title="xhtml 和 html 的区别"></a>xhtml 和 html 的区别</h3><pre><code>必须被正确的嵌套
必须是小写
必须关闭标签
必须有根元素</code></pre>
<h3 id="前端页面有那三层构成，分别是什么？作用是什么"><a href="#前端页面有那三层构成，分别是什么？作用是什么" class="headerlink" title="前端页面有那三层构成，分别是什么？作用是什么"></a>前端页面有那三层构成，分别是什么？作用是什么</h3><pre><code>结构层   html  做页面显示结构的
表示层   css     做样式显示的
行为层   javascript  做事件触发显示的</code></pre>
<h3 id="隐藏元素的三个方法"><a href="#隐藏元素的三个方法" class="headerlink" title="隐藏元素的三个方法"></a>隐藏元素的三个方法</h3><pre><code>display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。    

visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。        

visibility: collapse;  当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 &quot;hidden&quot;。其表现却跟 display: none 一样，也即其占用的空间会释放。</code></pre>
<h3 id="Doctype-严格模式与混杂模式"><a href="#Doctype-严格模式与混杂模式" class="headerlink" title="Doctype? 严格模式与混杂模式"></a>Doctype? 严格模式与混杂模式</h3><p>doctype 的作用：<br>　　声明位于文档 的最前面，告知浏览器的解析器，用什么文档类型、规范来解析这个文档。</p>
<p><strong>可以分为两种:</strong></p>
<p>一种是 html4.01 中申明的严格模式：<code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD *XHTML 1.0* Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code>；DOCTYPE 不存在或形式不正确会导致 HTML 和 XHTML 文档以混杂模式呈现。没有文档声明的话大多数浏览器都将会转换到为怪异模式(quirk mode)，有些地方会称为混杂模式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个是正常模式就是(标准模式也成为严格模式) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个是怪异模式也称为混杂模式,怪异模式则是使用浏览器自己的方式来解析执行代码。--&gt;</span></span><br></pre></td></tr></table></figure>

<p>混杂模式：混杂模式的页面以宽松的向后兼容的方式显示；模拟老的浏览器的行为以防止站点无法工作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 到底都有哪些声明呢？哪种声明更好呢？我们建议你使用XHTML 1.0最严格模式，从一开始我们就应该严格的要求自己，具体声明如下： --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果你接手的是一个遗留网页，最初并没有DTD声明，并且使用了很多在XHTML中已经废除的标签，那么，我们建议你使用XHTML兼容模式，声明如下： --&gt;</span></span><br><span class="line">  <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">怪异模式中，IE6/7/8都不认识!important声明，这只是区别的一种，还有很多其它区别。所以，要想写出跨浏览器的CSS，你必须采用标准模式。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在ie6中，如果在doctype声明前加一个xml声明，采用quirks模式解析</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在标准模式和怪异模式下，盒子模型的差异：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标准模式下：  width = content</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">怪异模式下 ： width = border + padding  + content </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在标准情况下使用  box-sizing:border-box  才能和怪异模式下的盒子模型保持一致</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一种是 javascript 中申明的严格模式：在函数内部的最上方写上“use strict”,严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。</p>
<p>两者区别很多，包括 css（、html 不知道有没有）、javascript 都有区别，严格模式可以向后兼容，其实严格模式可以理解为是已经确定了不需要更改的内容</p>
<p>就目前来说 html5 的<code>&lt;!DOCTYPE html&gt;</code>没有 DTD 因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容.</p>
<h3 id="浏览器页面宽高度设置有哪些？"><a href="#浏览器页面宽高度设置有哪些？" class="headerlink" title="浏览器页面宽高度设置有哪些？"></a>浏览器页面宽高度设置有哪些？</h3><h4 id="与浏览器相关"><a href="#与浏览器相关" class="headerlink" title="与浏览器相关"></a>与浏览器相关</h4><p>window.innerWidth<br>window.outerWidth<br>window.screen.width<br>window.screen.availWidth<br>window.screenLeft (浏览器距离屏幕左侧的距离宽度)</p>
<p>含有 screen 关键字的与浏览器无关</p>
<h4 id="与浏览器元素有关"><a href="#与浏览器元素有关" class="headerlink" title="与浏览器元素有关"></a>与浏览器元素有关</h4><p>语法：document.documentElement.clientWidth.或者 doucment.body.clientWidth.</p>
<p>clientWidth（距离父级元素 clientLeft）</p>
<p>offsetWidth（距离父级元素 offsetLeft）</p>
<p>scrollWidth（距离滚动条顶部 scrollTop）</p>
<h4 id="兼容写法"><a href="#兼容写法" class="headerlink" title="兼容写法"></a>兼容写法</h4><p>由于 document.compatMode 在 IE 浏览器是”BackCompat”;而在 chrome 浏览器则是”CSS1Compat”。</p>
<p>兼容写法：页面不出现滚动条，那么 clientWidth 和 scrollWidth 应该相等。但不同浏览器有不同的处理，这两个值未必相等，所以取最大值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagearea</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">&quot;BackCompat&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollWidth, <span class="built_in">document</span>.body.clientWidth),</span><br><span class="line">      height: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight, <span class="built_in">document</span>.body.clientHeight)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      width: <span class="built_in">Math</span>.max(</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollWidth,</span><br><span class="line">        <span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line">      ),</span><br><span class="line">      height: <span class="built_in">Math</span>.max(</span><br><span class="line">        <span class="built_in">document</span>.documentElement.scrollHeight,</span><br><span class="line">        <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">      )</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般无滚动条情况下 offsetWidth=clientWidth=scrollWidth(有可能存在误差 1px)</p>
</blockquote>
<h3 id="标签语义化的好处"><a href="#标签语义化的好处" class="headerlink" title="标签语义化的好处"></a>标签语义化的好处</h3><p>更直观的认识标签，让页面的内容结构化，对搜索引擎抓取有好处，用正确的标签做正确的事，便于开发者更好的阅读理解，以及修改代码。<br>后期方便维护，更利于 seo</p>
<h3 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h3><pre><code>1.新的绘画  canvas  svg
2.新的媒体图像  video  audio
3.新的存储方式  localstorage   sessionstorage
4.新的标签  header nav  section article  aside footer
5.新的控件  email url search date time calendar
6.新的技术 websocket  webworker  geolocation
7.ie8,ie7,ie6支持通过createElement方法产生的标签可以利用这一特性让这些浏览器支持HTML5新标签</code></pre>
<h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>①伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</p>
<p>②与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。</p>
<p><strong>区别：</strong> 伪类是”:”,伪元素是”::”<br>伪类一般有:<code>:hover,:focus,:nth-child,:checked,:not</code>     </p>
<p>伪元素一般有<code> ::before,::first-letter,::first-line</code>,伪元素也可以将双冒号改为单冒号。</p>
<h3 id="DOM-节点操作-API"><a href="#DOM-节点操作-API" class="headerlink" title="DOM 节点操作 API"></a>DOM 节点操作 API</h3><pre><code>getElementById()    返回带有指定 ID 的元素。
getElementsByTagName()    返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。
getElementsByClassName()    返回包含带有指定类名的所有元素的节点列表。
appendChild()    把新的子节点添加到指定节点。
removeChild()    删除子节点。
replaceChild()    替换子节点。
insertBefore()    在指定的子节点前面插入新的子节点。
createAttribute()    创建属性节点。
createElement()    创建元素节点。
createTextNode()    创建文本节点。
getAttribute()    返回指定的属性值。getAttributeNode
setAttribute()    把指定属性设置或修改为指定的值。setAttributeNode</code></pre>
<p><strong>tip：</strong> 删除，替换与插入的第二参数都必须是节点写法：<code>abc.replaceChild(news,abc.childNodes[0])</code>,</p>
<p><strong>删除已有的 HTML 元素:</strong></p>
<pre><code>方法一必需引用父元素
var parent=document.getElementById(&quot;div1&quot;);     //如果p元素的父元素是Body就用ByTagName(&quot;body&quot;)[0]
var child=document.getElementById(&quot;p1&quot;);
parent.removeChild(child);

方法二无需引用父元素    //此方法缺点：只能清空元素内容，但元素依旧存在并占据原有空间
var a=document.getElementById(&quot;p1&quot;);
    a.removeChild(a.childNodes[0]);

方法三无缺点

child.parentNode.removeChild(child)
这是常用的解决方案：找到您希望删除的子元素，然后使用其 parentNode 属性来找到父元素</code></pre>
<p><code>cloneNode(true) //true</code>表示复制包括其子节点，false 只复制其标签元素(但不复制其 innerHTML 内容)</p>
<p><strong>非 node 与 node 的区别</strong><br>俩这都是删除指定的属性,前者不返回值,后者以 Attr Node 对象返回被删除的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.removeAttribute与removeAttributeNode的区别*/</span></span><br><span class="line"><span class="comment">//前者写法:没有返回值</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;H1&quot;</span>)[<span class="number">0</span>].removeAttribute(<span class="string">&quot;style&quot;</span>); <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后者写法:返回具有指定名称的属性</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;H1&quot;</span>)[<span class="number">0</span>].removeAttributeNode(); <span class="comment">//报错,不能一行完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;H1&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> a = n.getAttributeNode(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">n.removeAttributeNode(a); <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;INPUT&quot;</span>)[<span class="number">0</span>].attributes.removeNamedItem(<span class="string">&quot;type&quot;</span>);</span><br><span class="line"><span class="comment">/*2.setAttribute和setAttributeNode区别*/</span></span><br><span class="line"><span class="comment">//前者写法</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;H1&quot;</span>)[<span class="number">0</span>].setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;sett&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后者写法</span></span><br><span class="line"><span class="keyword">var</span> atr = <span class="built_in">document</span>.createAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">atr.nodeValue = <span class="string">&quot;sett&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> h = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;H1&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">h.setAttributeNode(atr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写document.getElementsByTagName(&quot;H1&quot;)[0].setAttributeNode(atr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.getAttribute和getAttributeNode区别*/</span></span><br><span class="line"><span class="comment">//前者写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].getAttribute(<span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后者写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].getAttributeNode(<span class="string">&quot;target&quot;</span>); <span class="comment">//返回的是[object Attr],Attr对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>].getAttributeNode(<span class="string">&quot;target&quot;</span>).value; <span class="comment">//正确,或者nodeValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*4.hasAttribute和hasAttributes区别*/</span></span><br><span class="line"><span class="comment">//俩这均返回布尔值</span></span><br><span class="line"><span class="comment">//前者写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;BUTTON&quot;</span>)[<span class="number">0</span>].hasAttribute(<span class="string">&quot;onclick&quot;</span>);</span><br><span class="line"><span class="comment">//后者写法</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;BUTTON&quot;</span>)[<span class="number">0</span>].hasAttributes(); <span class="comment">//无参数的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*5.children和childNodes*/</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;UL&quot;</span>)[<span class="number">0</span>].children[<span class="number">0</span>].tagName; <span class="comment">//等于</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;UL&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].tagName; <span class="comment">//其中tagName也可以写为nodeName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//childNodes返回类似数组形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*6.parentNode使用*/</span></span><br><span class="line">parentNode.nodeName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*7.previousSibling和previousElementSibling*/</span></span><br><span class="line">itm.previousSibling.id; <span class="comment">//等于</span></span><br><span class="line">itm.previousElementSibling.id; <span class="comment">//节点写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*8.nextSibling和nextElementSibling*/</span></span><br><span class="line">itm.nextSibling.id; <span class="comment">//等于</span></span><br><span class="line">itm.nextElementSibling.id; <span class="comment">//节点写法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回该元素的所有属性长度：x.innerHTML=btn.attributes.length</p>
</blockquote>
<blockquote>
<p>childNodes[0]等于 abc.firstChild</p>
</blockquote>
<h3 id="http-事务是怎样的一个过程？"><a href="#http-事务是怎样的一个过程？" class="headerlink" title="http 事务是怎样的一个过程？"></a>http 事务是怎样的一个过程？</h3><pre><code>1.域名解析
2.tcp三次握手
3.建立tcp连接，发起http请求
4.服务器响应，浏览器得到代码
5.浏览器解析代码，请求代码中的资源
6.得到资源，呈现给用户网页</code></pre>
<h3 id="AJAX-的优缺点？"><a href="#AJAX-的优缺点？" class="headerlink" title="AJAX 的优缺点？"></a>AJAX 的优缺点？</h3><pre><code>优点：相对于同步而言，不会产生卡死，无需刷新网页更新，
缺点：后退按钮无效，多个请求同时触发，由于回调时间不确定会造成混乱，不利于SEO,数据安全有隐患</code></pre>
<h3 id="AJAX-请求时-get-和-post-的区别"><a href="#AJAX-请求时-get-和-post-的区别" class="headerlink" title="AJAX 请求时 get 和 post 的区别"></a>AJAX 请求时 get 和 post 的区别</h3><pre><code>1.一个在url后面，一个在虚拟载体里
2.根据不同的浏览器区别有大小限制
3.安全问题，应用不同，一个是只需要请求明文可见的，一个类似于修改密码的</code></pre>
<h3 id="补充-get-和-post-请求在缓存方面的区别"><a href="#补充-get-和-post-请求在缓存方面的区别" class="headerlink" title="补充 get 和 post 请求在缓存方面的区别"></a>补充 get 和 post 请求在缓存方面的区别</h3><pre><code>1.get在查找的过程，用户获取数据(明文传输)，可以不用每次都与后台数据库连接，所以可以使用缓存。
2.post不同，post做的一般是修改和删除的工作，所以每次都需要与数据库进行交互，所以不能使用缓存</code></pre>
<h3 id="简单说下-xml，html-xhtml-以及-html5-区别"><a href="#简单说下-xml，html-xhtml-以及-html5-区别" class="headerlink" title="简单说下 xml，html,xhtml,以及 html5 区别"></a>简单说下 xml，html,xhtml,以及 html5 区别</h3><pre><code>1. XML 用来描述数据，而 HTML 则用来显示数据
2. xhtml是为了取代html的，但xhtml不是html的升级版，html5是html的升级版，html5不是xhtml的升级版。
3. 简单来说，XHTML 可以认为是 XML 版本的 HTML，为符合 XML 要求，XHTML 语法上要求更严谨些。XHTML相对于HTML更严谨，不过被html5规范淘汰了。</code></pre>
<p>由于 SGML 的复杂，因而难以普及。HTML 和 XML 同样衍生于 SGML，XML 可以被认为是 SGML 的一个子集，而 HTML 是 SGML 的一个应用。</p>
<p>从继承关系上讲，HTML 是一种基于标准通用标记语言(SGML)的应用，是一种非常灵活的置标语言，而 XHTML 则基于可扩展标记语言(XML)，XML 是 SGML 的一个子集。XHTML 1.0 在 2000 年 1 月 26 日成为 W3C 的推荐标准。</p>
<h3 id="图片的预加载和懒加载？"><a href="#图片的预加载和懒加载？" class="headerlink" title="图片的预加载和懒加载？"></a>图片的预加载和懒加载？</h3><p>预加载：提前加载图片，当用户需要查看图片的时候可直接从本地缓存中渲染，预加载会给服务器增加压力。<br>懒加载：不提前加载，甚至不加载，优化了服务器前端的优化，减少了请求数或延迟请求数</p>
<h3 id="浮动定位和绝对定位"><a href="#浮动定位和绝对定位" class="headerlink" title="浮动定位和绝对定位"></a>浮动定位和绝对定位</h3><p>一个元素若设置了 position:absolute | fixed; 则该元素就不能设置 float。这是一个常识性的知识点，因为这是两个不同的流，一个是浮动流，另一个是“定位流(这是自己起的名字，呵呵)”。</p>
<p>但是 relative 却可以。因为它原本所占的空间仍然占据文档流。<br>当元素设置 position:absolute、float:left、float:right 中任意一个时，都会让元素以<code>display:inline-block</code>的方式显示（特点是：可以设置长宽，默认宽度不占满父元素）。这时，即使故意设置 display:inline; display:block 都是无效的。<br>但是 float 在 IE6 下的双边距 bug 就是用 display:inline; 来解决的。</p>
<h3 id="HTML-5-应用程序缓存"><a href="#HTML-5-应用程序缓存" class="headerlink" title="HTML 5 应用程序缓存"></a>HTML 5 应用程序缓存</h3><pre><code>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。
应用程序缓存为应用带来三个优势：
1.离线浏览 - 用户可在应用离线时使用它们
2.速度 - 已缓存资源加载得更快
3.减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。

manifest 文件可分为三个部分：
CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</code></pre>
<h3 id="创建一个文本节点（Text）的过程"><a href="#创建一个文本节点（Text）的过程" class="headerlink" title="创建一个文本节点（Text）的过程"></a>创建一个文本节点（Text）的过程</h3><p>创建一个文本节点一共溯寻了 6 层原型链。</p>
<pre><code>使用document.createTextNode(&quot;xxx&quot;)创建文本节点，
其实document.createTextNode(&quot;xxx&quot;)是Text的一个实例，
而Text的父类是CharactorData，CharactorData的父类是Node，
Node的父类是EventTarget，
EventTarget的父类是Function，
Function的父类是Object。</code></pre>
<h3 id="HTML-的渲染引擎过程"><a href="#HTML-的渲染引擎过程" class="headerlink" title="HTML 的渲染引擎过程"></a>HTML 的渲染引擎过程</h3><pre><code>这四步仅仅是HTML的渲染引擎过程，
1.解析HTML，构建DOM树(将标签转化为节点) ——&gt;
2.解析样式信息，构建渲染树(外部css文件、style标签) ——&gt;
3.布局渲染树，即布局DOM节点(确定每个节点在屏幕上的确切坐标) ——&gt;
4.绘制渲染树，即绘制DOM节点(遍历渲染树，使用UI后端层绘制每个节点)</code></pre>
<h3 id="BOM-和-DOM-的关系"><a href="#BOM-和-DOM-的关系" class="headerlink" title="BOM 和 DOM 的关系"></a>BOM 和 DOM 的关系</h3><p>1.BOM（Browser Object Model）是指浏览器对象模型，它使 JavaScript 有能力与浏览器进行“对话”，主要处理浏览器窗口和框架。</p>
<p>2.DOM （Document Object Model）是指文档对象模型，通过它，可以访问 HTML 文档的所有元素。是 HTML 和 XML 的应用程序接口（API），遵循 W3C 的标准，所有浏览器公共遵守的标准。</p>
<p>可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。</p>
<h3 id="XML-操作-API"><a href="#XML-操作-API" class="headerlink" title="XML 操作 API"></a>XML 操作 API</h3><p>下面的 api 用于获取 book.xml 文档的使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">appendData()，deleteData()，insertData()，replaceData()，subStringData()</span><br><span class="line">以下5个方法都是编辑Text节点文本内容的方法。</span><br><span class="line">appendData()：在Text节点尾部追加字符串。</span><br><span class="line">deleteData()：删除Text节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</span><br><span class="line">insertData()：在Text节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</span><br><span class="line">replaceData()：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</span><br><span class="line">subStringData()：用于获取子字符串，第一个参数为子字符串在Text节点中的开始位置，第二个参数为子字符串长度。</span><br><span class="line">// HTML 代码为 //</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">var pElementText = document.querySelector(&#x27;p&#x27;).firstChild;</span><br><span class="line">pElementText.appendData(&#x27;!&#x27;); // 页面显示 Hello World!</span><br><span class="line">pElementText.deleteData(7, 5); // 页面显示 Hello W pElementText.insertData(7,</span><br><span class="line">&#x27;Hello &#x27;); // 页面显示 Hello WHello pElementText.replaceData(7, 5, &#x27;World&#x27;); //</span><br><span class="line">页面显示 Hello WWorld pElementText.substringData(7, 10); //</span><br><span class="line">页面显示不变，返回&quot;orld&quot;</span><br></pre></td></tr></table></figure>

<p><strong>tip：</strong> 貌似可以和 nodeValue 获取值,也就是说可以使用节点的 API。</p>
<h3 id="用到雪碧图的场景"><a href="#用到雪碧图的场景" class="headerlink" title="用到雪碧图的场景"></a>用到雪碧图的场景</h3><p>1.静态图片，不随用户信息的变化而变化</p>
<p>2.小图片，图片容量比较小</p>
<p>3.加载量比较大<br>一些大图不建议拼成雪碧图</p>
<p>为了减少 http 请求数量，加速网页内容显示，很多网站的导航栏图标、登录框图片等，使用的并不是<code>&lt;image&gt;</code>标签，而是 CSS Sprite 雪碧图</p>
<h3 id="div-css-较-table-有哪些优势"><a href="#div-css-较-table-有哪些优势" class="headerlink" title="div+css 较 table 有哪些优势"></a>div+css 较 table 有哪些优势</h3><pre><code>1.表现与结构相分离
2.扩展性更好，便于维护
3.页面加载速度更快，结构化清晰，页面显示简洁
4.对搜索引擎更友好，网站排名更靠前
统一的标准，降低开发难度，开发成本，SEO也会更好做</code></pre>
<h3 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h3><pre><code>200, OK，访问正常
301, Moved Permanently，永久移动
302, Moved temporarily，暂时移动
304, Not Modified，未修改
307, Temporary Redirect，暂时重定向
401, Unauthorized，未授权    //如豆瓣需要apiKey才能访问
403, Forbidden，禁止访问    //需要特指的服务器或者IP以及账号才能访问
404, Not Found，未发现指定网址
500, Internal Server Error，服务器发生错误</code></pre>
<h3 id="js-动画和-css3-动画的差异"><a href="#js-动画和-css3-动画的差异" class="headerlink" title="js 动画和 css3 动画的差异"></a>js 动画和 css3 动画的差异</h3><pre><code>1.js功能覆盖上，比css3好
2.重构/构建上css3比js简单，快速方便
3.css3对表现帧速不好的低版本浏览器，可以做到自动降级
4.css3有天然事件支持
5.css3有兼容性问题</code></pre>
<h3 id="Ajax-的工作原理"><a href="#Ajax-的工作原理" class="headerlink" title="Ajax 的工作原理"></a>Ajax 的工作原理</h3><p>AJAX 全称 Async Javascript and XML 翻译成中文：异步的 JavaScript 和 XML</p>
<p>Ajax 技术的核心是 XMLHttpRequest 对象（简称：XHR），可以在不刷新页面页面也能取得新的数据。</p>
<p>满足下面的条件就是 AJAX</p>
<p>使用 XMLHttpReques 发请求<br>服务器返回 XML 格式的字符串<br>JS 解析 XML，并更新局部页面</p>
<p>Ajax 的工作原理相当于在用户和服务器之间加了—个中间层(AJAX 引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。像—些数据验证和数据处理等都交给 Ajax 引擎自己来做,，只有确定需要从服务器读取新数据时再由 Ajax 引擎代为向服务器提交请求。</p>
<h3 id="前端优化性能有哪些？"><a href="#前端优化性能有哪些？" class="headerlink" title="前端优化性能有哪些？"></a>前端优化性能有哪些？</h3><pre><code>1.减少http请求数
2.减少html标签带来的带宽浪费
3.用innerHTML代替基本的DOM 操作
4.用className代替style
5.少用全局变量，减少IO操作
6.避免使用css表达式
7.图片预加载，样式放在顶部，脚本放在底部</code></pre>
<h3 id="前端开发人员具备哪些条件？"><a href="#前端开发人员具备哪些条件？" class="headerlink" title="前端开发人员具备哪些条件？"></a>前端开发人员具备哪些条件？</h3><pre><code>1.将产品从90分做到100分，甚至更好
2.快速的做出高效高质量的效果图，精确到1px
3.与团队成员，UI设计，产品经理沟通
4.做好页面结构/页面重构工作，给用户好体验
5.处理hack，兼容，优化代码格式
6.针对服务器优化</code></pre>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令分类合集</title>
    <url>/2018/12/09/linux/01.linux-shi-yong/01.linux-ming-ling-fen-lei-he-ji/</url>
    <content><![CDATA[<p>下面罗列出来的都是常用命令,若想查询更多 ➡️：<a href="https://man.linuxde.net/">https://man.linuxde.net/</a></p>
<h2 id="1-系统信息"><a href="#1-系统信息" class="headerlink" title="1.系统信息"></a>1.系统信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch                    <span class="comment">#显示机器的处理器架构(1)</span></span><br><span class="line">uname -m                <span class="comment">#显示机器的处理器架构(2)</span></span><br><span class="line">uname -r                <span class="comment">#显示正在使用的内核版本</span></span><br><span class="line">dmidecode -q            <span class="comment">#显示硬件系统部件 - (SMBIOS / DMI)</span></span><br><span class="line">hdparm -i /dev/hda      <span class="comment">#罗列一个磁盘的架构特性</span></span><br><span class="line">hdparm -tT /dev/sda     <span class="comment">#在磁盘上执行测试性读取操作</span></span><br><span class="line">cat /proc/cpuinfo       <span class="comment">#显示CPU info的信息</span></span><br><span class="line">cat /proc/interrupts    <span class="comment">#示中断</span></span><br><span class="line">cat /proc/meminfo       <span class="comment">#校验内存使用</span></span><br><span class="line">cat /proc/swaps         <span class="comment">#显示哪些swap被使用</span></span><br><span class="line">cat /proc/version       <span class="comment">#显示内核的版本</span></span><br><span class="line">cat /proc/net/dev       <span class="comment">#显示网络适配器及统计</span></span><br><span class="line">cat /proc/mounts        <span class="comment">#显示已加载的文件系统</span></span><br><span class="line">lspci -tv               <span class="comment">#罗列 PCI 设备</span></span><br><span class="line">lsusb -tv               <span class="comment">#显示 USB 设备</span></span><br><span class="line">date                    <span class="comment">#显示系统日期</span></span><br><span class="line">cal 2007                <span class="comment">#显示2007年的日历表</span></span><br><span class="line">date 041217002007.00    <span class="comment">#设置日期和时间 - 月日时分年.秒</span></span><br><span class="line">clock -w                <span class="comment">#将时间修改保存到 BIOS</span></span><br></pre></td></tr></table></figure>

<h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2.关机"></a>2.关机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(系统的关机、重启以及登出 )</span><br><span class="line">shutdown -h now             <span class="comment">#关闭系统(1)</span></span><br><span class="line">init 0                      <span class="comment">#关闭系统(2)</span></span><br><span class="line">telinit 0                   <span class="comment">#关闭系统(3)</span></span><br><span class="line">shutdown -h hours:minutes &amp; <span class="comment">#后台运行按预定时间关闭系统</span></span><br><span class="line">shutdown -c                 <span class="comment">#取消按预定时间关闭系统</span></span><br><span class="line">shutdown -r now             <span class="comment">#重启(1)</span></span><br><span class="line">reboot                      <span class="comment">#重启(2)</span></span><br><span class="line"><span class="built_in">logout</span>                      <span class="comment">#注销</span></span><br></pre></td></tr></table></figure>

<h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3.文件和目录"></a>3.文件和目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home                              <span class="comment">#进入 &#x27;/ home&#x27; 目录&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> ..                                 <span class="comment">#返回上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../..                              <span class="comment">#返回上两级目录</span></span><br><span class="line"><span class="built_in">cd</span>                                    <span class="comment">#进入某目录</span></span><br><span class="line"><span class="built_in">cd</span> ~user1                             <span class="comment">#进入个人的主目录</span></span><br><span class="line"><span class="built_in">cd</span> -                                  <span class="comment">#返回上次所在的目录</span></span><br><span class="line"><span class="built_in">pwd</span>                                   <span class="comment">#显示工作路径</span></span><br><span class="line">ls                                    <span class="comment">#查看目录中的文件</span></span><br><span class="line">ls -F                                 <span class="comment">#查看目录中的文件</span></span><br><span class="line">ls -l                                 <span class="comment">#显示文件和目录的详细资料</span></span><br><span class="line">ls -a                                 <span class="comment">#显示隐藏文件</span></span><br><span class="line">ls *[0-9]*                            <span class="comment">#显示包含数字的文件名和目录名</span></span><br><span class="line">tree                                  <span class="comment">#显示文件和目录由根目录开始的树形结构(1)</span></span><br><span class="line">lstree                                <span class="comment">#显示文件和目录由根目录开始的树形结构(2)</span></span><br><span class="line">mkdir dir1                            <span class="comment">#创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span></span><br><span class="line">mkdir dir1 dir2                       <span class="comment">#同时创建两个目录</span></span><br><span class="line">mkdir -p /tmp/dir1/dir2               <span class="comment">#创建一个目录树</span></span><br><span class="line">rm -f file1                           <span class="comment">#删除一个叫做 &#x27;file1&#x27; 的文件&#x27;</span></span><br><span class="line">rmdir dir1                            <span class="comment">#删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span></span><br><span class="line">rm -rf dir1                           <span class="comment">#删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容</span></span><br><span class="line">rm -rf dir1 dir2                      <span class="comment">#同时删除两个目录及它们的内容</span></span><br><span class="line">mv dir1 new_dir                       <span class="comment">#重命名/移动 一个目录</span></span><br><span class="line">cp file1 file2                        <span class="comment">#复制一个文件</span></span><br><span class="line">cp dir/* .                            <span class="comment">#复制一个目录下的所有文件到当前工作目录</span></span><br><span class="line">cp -a /tmp/dir1 .                     <span class="comment">#复制一个目录到当前工作目录</span></span><br><span class="line">cp -a dir1 dir2                       <span class="comment">#复制一个目录</span></span><br><span class="line">ln -s file1 lnk1                      <span class="comment">#创建一个指向文件或目录的软链接</span></span><br><span class="line">ln file1 lnk1                         <span class="comment">#创建一个指向文件或目录的物理链接</span></span><br><span class="line">touch -t 0712250000 file1             <span class="comment">#修改一个文件或目录的时间戳 - (YYMMDDhhmm)</span></span><br><span class="line">file filename                         <span class="comment">#输出文件的类型和编码格式</span></span><br><span class="line">iconv -l                              <span class="comment">#列出iconv支持的编码列表,该命令是用来转换文件的编码方式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span>                            <span class="comment">#查看当前操作系统的编码格式</span></span><br><span class="line">iconv -f UTF-8 -t GBK file1 -o file2  <span class="comment">#将UTF8编码file1的转换成GBK并输出为file2</span></span><br><span class="line">find . -maxdepth 1 -name *.jpg -<span class="built_in">print</span> -<span class="built_in">exec</span> convert <span class="string">&quot;&#123;&#125;&quot;</span> -resize 80x60 <span class="string">&quot;thumbs/&#123;&#125;&quot;</span> \; batch</span><br></pre></td></tr></table></figure>

<h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4.文件搜索"></a>4.文件搜索</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name file1                          <span class="comment">#从 &#x27;/&#x27; 开始进入根文件系统搜索文件和目录</span></span><br><span class="line">find / -user user1                          <span class="comment">#搜索属于用户 &#x27;user1&#x27; 的文件和目录</span></span><br><span class="line">find /home/user1 -name \*.bin               <span class="comment">#在目录 &#x27;/ home/user1&#x27; 中搜索带有&#x27;.bin&#x27; 结尾的文件</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -atime +100           <span class="comment">#搜索在过去100天内未被使用过的执行文件</span></span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -mtime -10            <span class="comment">#搜索在10天内被创建或者修改过的文件</span></span><br><span class="line">find / -name \*.rpm -<span class="built_in">exec</span> chmod 755 <span class="string">&#x27;&#123;&#125;&#x27;</span> \; <span class="comment">#搜索以 &#x27;.rpm&#x27; 结尾的文件并定义其权限</span></span><br><span class="line">find / -xdev -name \*.rpm                   <span class="comment">#搜索以 &#x27;.rpm&#x27; 结尾的文件，忽略光驱、捷盘等可移动设备</span></span><br><span class="line">locate \*.ps                                <span class="comment">#寻找以 &#x27;.ps&#x27; 结尾的文件 - 先运行 &#x27;updatedb&#x27; 命令</span></span><br><span class="line">whereis halt                                <span class="comment">#显示一个二进制文件、源码或man的位置</span></span><br><span class="line"><span class="built_in">which</span> halt                                  <span class="comment">#显示一个二进制文件或可执行文件的完整路径</span></span><br></pre></td></tr></table></figure>

<h2 id="5-挂载一个文件系统"><a href="#5-挂载一个文件系统" class="headerlink" title="5.挂载一个文件系统"></a>5.挂载一个文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/hda2 /mnt/hda2         <span class="comment">#挂载一个叫做hda2的盘 - 确定目录 &#x27;/ mnt/hda2&#x27; 已经存在</span></span><br><span class="line">umount /dev/hda2                  <span class="comment">#卸载一个叫做hda2的盘 - 先从挂载点 &#x27;/ mnt/hda2&#x27; 退出</span></span><br><span class="line">fuser -km /mnt/hda2               <span class="comment">#当设备繁忙时强制卸载</span></span><br><span class="line">umount -n /mnt/hda2               <span class="comment">#运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</span></span><br><span class="line">mount /dev/fd0 /mnt/floppy        <span class="comment">#挂载一个软盘</span></span><br><span class="line">mount /dev/cdrom /mnt/cdrom       <span class="comment">#挂载一个cdrom或dvdrom</span></span><br><span class="line">mount /dev/hdc /mnt/cdrecorder    <span class="comment">#挂载一个cdrw或dvdrom</span></span><br><span class="line">mount /dev/hdb /mnt/cdrecorder    <span class="comment">#挂载一个cdrw或dvdrom</span></span><br><span class="line">mount -o loop file.iso /mnt/cdrom <span class="comment">#挂载一个文件或ISO镜像文件</span></span><br><span class="line">mount -t vfat /dev/hda5 /mnt/hda5 <span class="comment">#挂载一个Windows FAT32文件系统</span></span><br><span class="line">mount /dev/sda1 /mnt/usbdisk      <span class="comment">#挂载一个usb 捷盘或闪存设备</span></span><br><span class="line">mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share</span><br><span class="line"><span class="comment">#挂载一个windows网络共享</span></span><br></pre></td></tr></table></figure>

<h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6.磁盘空间"></a>6.磁盘空间</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h               <span class="comment">#显示已经挂载的分区列表</span></span><br><span class="line">ls -lSr |more       <span class="comment">#以尺寸大小排列文件和目录</span></span><br><span class="line">du -sh dir1         <span class="comment">#估算目录 &#x27;dir1&#x27; 已经使用的磁盘空间&#x27;</span></span><br><span class="line">du -sk * | sort -rn <span class="comment">#以容量大小为依据依次显示文件和目录的大小</span></span><br><span class="line">rpm -q -a --qf <span class="string">&#x27;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#x27;</span> | sort -k1,1n <span class="comment">#以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</span></span><br><span class="line">dpkg-query -W -f=<span class="string">&#x27;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#x27;</span> | sort -k1,1n <span class="comment">#以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</span></span><br></pre></td></tr></table></figure>

<h2 id="7-用户和群组"><a href="#7-用户和群组" class="headerlink" title="7.用户和群组"></a>7.用户和群组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd group_name                       <span class="comment">#创建一个新用户组</span></span><br><span class="line">groupdel group_name                       <span class="comment">#删除一个用户组</span></span><br><span class="line">groupmod -n new_group_name old_group_name <span class="comment">#重命名一个用户组</span></span><br><span class="line">useradd -c <span class="string">&quot;Name Surname &quot;</span> -g admin -d /home/user1 -s /bin/bash user1 <span class="comment">#创建一个属于 &quot;admin&quot; 用户组的用户</span></span><br><span class="line">useradd user1                             <span class="comment">#创建一个新用户</span></span><br><span class="line">userdel -r user1                          <span class="comment">#删除一个用户 ( &#x27;-r&#x27; 排除主目录)</span></span><br><span class="line">usermod -c <span class="string">&quot;User FTP&quot;</span> -g system -d /ftp/user1 -s /bin/nologin user1 <span class="comment">#修改用户属性</span></span><br><span class="line">passwd                                  <span class="comment">#修改口令</span></span><br><span class="line">passwd user1                            <span class="comment">#修改一个用户的口令 (只允许root执行)</span></span><br><span class="line">chage -E 2005-12-31 user1               <span class="comment">#设置用户口令的失效期限</span></span><br><span class="line">pwck                                    <span class="comment">#验证系统认证文件/etc/passwd和/etc/shadow的内容和格式的完整性</span></span><br><span class="line">grpck                                   <span class="comment">#检查 &#x27;/etc/passwd&#x27; 的文件格式和语法修正以及存在的群组</span></span><br><span class="line">newgrp group_name                       <span class="comment">#登陆进一个新的群组以改变新创建文件的预设群组</span></span><br></pre></td></tr></table></figure>

<h2 id="8-文件的权限"><a href="#8-文件的权限" class="headerlink" title="8.文件的权限"></a>8.文件的权限</h2><ul>
<li>使用 “+” 设置权限，使用 “-“ 用于取消</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -lh                          <span class="comment">#显示权限</span></span><br><span class="line">ls /tmp | pr -T5 -W<span class="variable">$COLUMNS</span>     <span class="comment">#将终端划分成5栏显示</span></span><br><span class="line">chmod ugo+rwx directory1        <span class="comment">#设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</span></span><br><span class="line">chmod go-rwx directory1         <span class="comment">#删除群组(g)与其他人(o)对目录的读写执行权限</span></span><br><span class="line">chown user1 file1               <span class="comment">#改变一个文件的所有人属性</span></span><br><span class="line">chown -R user1 directory1       <span class="comment">#改变一个目录的所有人属性并同时改变改目录下所有文件的属性</span></span><br><span class="line">chgrp group1 file1              <span class="comment">#改变文件的群组</span></span><br><span class="line">chown user1:group1 file1        <span class="comment">#改变一个文件的所有人和群组属性</span></span><br><span class="line">find / -perm -u+s               <span class="comment">#罗列一个系统中所有使用了SUID控制的文件</span></span><br><span class="line">chmod u+s /bin/file1            <span class="comment">#设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</span></span><br><span class="line">chmod u-s /bin/file1            <span class="comment">#禁用一个二进制文件的 SUID位</span></span><br><span class="line">chmod g+s /home/public          <span class="comment">#设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</span></span><br><span class="line">chmod g-s /home/public          <span class="comment">#禁用一个目录的 SGID 位</span></span><br><span class="line">chmod o+t /home/public          <span class="comment">#设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</span></span><br><span class="line">chmod o-t /home/public          <span class="comment">#禁用一个目录的 STIKY 位</span></span><br></pre></td></tr></table></figure>

<h2 id="9-文件的特殊属性"><a href="#9-文件的特殊属性" class="headerlink" title="9.文件的特殊属性"></a>9.文件的特殊属性</h2><ul>
<li>使用 “+” 设置权限，使用 “-“ 用于取消</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +a file1         <span class="comment">#只允许以追加方式读写文件</span></span><br><span class="line">chattr +c file1         <span class="comment">#允许这个文件能被内核自动压缩/解压</span></span><br><span class="line">chattr +d file1         <span class="comment">#在进行文件系统备份时，dump程序将忽略这个文件</span></span><br><span class="line">chattr +i file1         <span class="comment">#设置成不可变的文件，不能被删除、修改、重命名或者链接</span></span><br><span class="line">chattr +s file1         <span class="comment">#允许一个文件被安全地删除</span></span><br><span class="line">chattr +S file1         <span class="comment">#一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</span></span><br><span class="line">chattr +u file1         <span class="comment">#若文件被删除，系统会允许你在以后恢复这个被删除的文件</span></span><br><span class="line">lsattr                  <span class="comment">#显示特殊的属性</span></span><br></pre></td></tr></table></figure>

<h2 id="10-打包和压缩文件"><a href="#10-打包和压缩文件" class="headerlink" title="10.打包和压缩文件"></a>10.打包和压缩文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bunzip2 file1.bz2                       <span class="comment">#解压一个叫做 &#x27;file1.bz2&#x27;的文件</span></span><br><span class="line">bzip2 file1                             <span class="comment">#压缩一个叫做 &#x27;file1&#x27; 的文件</span></span><br><span class="line">gunzip file1.gz                         <span class="comment">#解压一个叫做 &#x27;file1.gz&#x27;的文件</span></span><br><span class="line">gzip file1                              <span class="comment">#压缩一个叫做 &#x27;file1&#x27;的文件</span></span><br><span class="line">gzip -9 file1                           <span class="comment">#最大程度压缩</span></span><br><span class="line">rar a file1.rar test_file               <span class="comment">#创建一个叫做 &#x27;file1.rar&#x27; 的包</span></span><br><span class="line">rar a file1.rar file1 file2 dir1        <span class="comment">#同时压缩 &#x27;file1&#x27;, &#x27;file2&#x27; 以及目录 &#x27;dir1&#x27;</span></span><br><span class="line">rar x file1.rar                         <span class="comment">#解压rar包</span></span><br><span class="line">unrar x file1.rar                       <span class="comment">#解压rar包</span></span><br><span class="line">tar -cvf archive.tar file1              <span class="comment">#创建一个非压缩的 tarball</span></span><br><span class="line">tar -cvf archive.tar file1 file2 dir1   <span class="comment">#创建一个包含了 &#x27;file1&#x27;, &#x27;file2&#x27; 以及 &#x27;dir1&#x27;的档案文件</span></span><br><span class="line">tar -tf archive.tar                     <span class="comment">#显示一个包中的内容</span></span><br><span class="line">tar -xvf archive.tar                    <span class="comment">#释放一个包</span></span><br><span class="line">tar -xvf archive.tar -C /tmp            <span class="comment">#将压缩包释放到 /tmp目录下</span></span><br><span class="line">tar -cvfj archive.tar.bz2 dir1          <span class="comment">#创建一个bzip2格式的压缩包</span></span><br><span class="line">tar -xvfj archive.tar.bz2               <span class="comment">#解压一个bzip2格式的压缩包</span></span><br><span class="line">tar -cvfz archive.tar.gz dir1           <span class="comment">#创建一个gzip格式的压缩包</span></span><br><span class="line">tar -xvfz archive.tar.gz                <span class="comment">#解压一个gzip格式的压缩包</span></span><br><span class="line">zip file1.zip file1                     <span class="comment">#创建一个zip格式的压缩包</span></span><br><span class="line">zip -r file1.zip file1 file2 dir1       <span class="comment">#将几个文件和目录同时压缩成一个zip格式的压缩包</span></span><br><span class="line">unzip file1.zip                         <span class="comment">#解压一个zip格式压缩包</span></span><br></pre></td></tr></table></figure>

<h2 id="11-RPM-包"><a href="#11-RPM-包" class="headerlink" title="11.RPM 包"></a>11.RPM 包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- （Fedora, Redhat及类似系统）</span><br><span class="line">rpm -ivh package.rpm                    <span class="comment">#安装一个rpm包</span></span><br><span class="line">rpm -ivh --nodeeps package.rpm          <span class="comment">#安装一个rpm包而忽略依赖关系警告</span></span><br><span class="line">rpm -U package.rpm                      <span class="comment">#更新一个rpm包但不改变其配置文件</span></span><br><span class="line">rpm -F package.rpm                      <span class="comment">#更新一个确定已经安装的rpm包</span></span><br><span class="line">rpm -e package_name.rpm                 <span class="comment">#删除一个rpm包</span></span><br><span class="line">rpm -qa                                 <span class="comment">#显示系统中所有已经安装的rpm包</span></span><br><span class="line">rpm -qa | grep httpd                    <span class="comment">#显示所有名称中包含 &quot;httpd&quot; 字样的rpm包</span></span><br><span class="line">rpm -qi package_name                    <span class="comment">#获取一个已安装包的特殊信息</span></span><br><span class="line">rpm -qg <span class="string">&quot;System Environment/Daemons&quot;</span>    <span class="comment">#显示一个组件的rpm包</span></span><br><span class="line">rpm -ql package_name                    <span class="comment">#显示一个已经安装的rpm包提供的文件列表</span></span><br><span class="line">rpm -qc package_name                    <span class="comment">#显示一个已经安装的rpm包提供的配置文件列表</span></span><br><span class="line">rpm -q package_name --whatrequires      <span class="comment">#显示与一个rpm包存在依赖关系的列表</span></span><br><span class="line">rpm -q package_name --whatprovides      <span class="comment">#显示一个rpm包所占的体积</span></span><br><span class="line">rpm -q package_name --scripts           <span class="comment">#显示在安装/删除期间所执行的脚本l</span></span><br><span class="line">rpm -q package_name --changelog         <span class="comment">#显示一个rpm包的修改历史</span></span><br><span class="line">rpm -qf /etc/httpd/conf/httpd.conf      <span class="comment">#确认所给的文件由哪个rpm包所提供</span></span><br><span class="line">rpm -qp package.rpm -l                  <span class="comment">#显示由一个尚未安装的rpm包提供的文件列表</span></span><br><span class="line">rpm --import /media/cdrom/RPM-GPG-KEY   <span class="comment">#导入公钥数字证书</span></span><br><span class="line">rpm --checksig package.rpm              <span class="comment">#确认一个rpm包的完整性</span></span><br><span class="line">rpm -qa gpg-pubkey                      <span class="comment">#确认已安装的所有rpm包的完整性</span></span><br><span class="line">rpm -V package_name                     <span class="comment">#检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</span></span><br><span class="line">rpm -Va                                 <span class="comment">#检查系统中所有已安装的rpm包- 小心使用</span></span><br><span class="line">rpm -Vp package.rpm                     <span class="comment">#确认一个rpm包还未安装</span></span><br><span class="line">rpm2cpio package.rpm | cpio --extract --make-directories *bin* <span class="comment">#从一个rpm包运行可执行文件</span></span><br><span class="line">rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm               <span class="comment">#从一个rpm源码安装一个构建好的包</span></span><br><span class="line">rpmbuild --rebuild package_name.src.rpm                        <span class="comment">#从一个rpm源码构建一个 rpm 包</span></span><br></pre></td></tr></table></figure>

<h2 id="12-YUM-软件包升级器"><a href="#12-YUM-软件包升级器" class="headerlink" title="12.YUM 软件包升级器"></a>12.YUM 软件包升级器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- （Fedora, RedHat及类似系统）</span><br><span class="line">yum install package_name          <span class="comment">#下载并安装一个rpm包</span></span><br><span class="line">yum localinstall package_name.rpm <span class="comment">#将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</span></span><br><span class="line">yum update package_name.rpm       <span class="comment">#更新当前系统中所有安装的rpm包</span></span><br><span class="line">yum update package_name           <span class="comment">#更新一个rpm包</span></span><br><span class="line">yum remove package_name           <span class="comment">#删除一个rpm包</span></span><br><span class="line">yum list                          <span class="comment">#列出当前系统中安装的所有包</span></span><br><span class="line">yum search package_name           <span class="comment">#在rpm仓库中搜寻软件包</span></span><br><span class="line">yum clean packages                <span class="comment">#清理rpm缓存删除下载的包</span></span><br><span class="line">yum clean headers                 <span class="comment">#删除所有头文件</span></span><br><span class="line">yum clean all                     <span class="comment">#删除所有缓存的包和头文件</span></span><br></pre></td></tr></table></figure>

<h2 id="13-DEB-包"><a href="#13-DEB-包" class="headerlink" title="13.DEB 包"></a>13.DEB 包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Debian, Ubuntu 以及类似系统)</span><br><span class="line">dpkg -i package.deb             <span class="comment">#安装/更新一个 deb 包</span></span><br><span class="line">dpkg -r package_name            <span class="comment">#从系统删除一个 deb 包</span></span><br><span class="line">dpkg -l                         <span class="comment">#显示系统中所有已经安装的 deb 包</span></span><br><span class="line">dpkg -l | grep httpd            <span class="comment">#显示所有名称中包含 &quot;httpd&quot; 字样的deb包</span></span><br><span class="line">dpkg -s package_name            <span class="comment">#获得已经安装在系统中一个特殊包的信息</span></span><br><span class="line">dpkg -L package_name            <span class="comment">#显示系统中已经安装的一个deb包所提供的文件列表</span></span><br><span class="line">dpkg --contents package.deb     <span class="comment">#显示尚未安装的一个包所提供的文件列表</span></span><br><span class="line">dpkg -S /bin/ping               <span class="comment">#确认所给的文件由哪个deb包提供</span></span><br></pre></td></tr></table></figure>

<h2 id="14-APT-软件工具"><a href="#14-APT-软件工具" class="headerlink" title="14.APT 软件工具"></a>14.APT 软件工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Debian, Ubuntu 以及类似系统)</span><br><span class="line">apt-get install package_name        <span class="comment">#安装/更新一个 deb 包</span></span><br><span class="line">apt-cdrom install package_name      <span class="comment">#从光盘安装/更新一个 deb 包</span></span><br><span class="line">apt-get update                      <span class="comment">#升级列表中的软件包</span></span><br><span class="line">apt-get upgrade                     <span class="comment">#升级所有已安装的软件</span></span><br><span class="line">apt-get remove package_name         <span class="comment">#从系统删除一个deb包</span></span><br><span class="line">apt-get check                       <span class="comment">#确认依赖的软件仓库正确</span></span><br><span class="line">apt-get clean                       <span class="comment">#从下载的软件包中清理缓存</span></span><br><span class="line">apt-cache search searched-package   <span class="comment">#返回包含所要搜索字符串的软件包名称</span></span><br></pre></td></tr></table></figure>

<h2 id="15-查看文件内容"><a href="#15-查看文件内容" class="headerlink" title="15.查看文件内容"></a>15.查看文件内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat file1                       <span class="comment">#从第一个字节开始正向查看文件的内容</span></span><br><span class="line">tac file1                       <span class="comment">#从最后一行开始反向查看一个文件的内容</span></span><br><span class="line">more file1                      <span class="comment">#查看一个长文件的内容</span></span><br><span class="line">less file1                      <span class="comment">#类似于 &#x27;more&#x27; 命令，但是它允许在文件中和正向操作一样的反向操作</span></span><br><span class="line">head -2 file1                   <span class="comment">#查看一个文件的前两行</span></span><br><span class="line">tail -2 file1                   <span class="comment">#查看一个文件的最后两行</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/messages       <span class="comment">#实时查看被添加到一个文件中的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="16-文本处理"><a href="#16-文本处理" class="headerlink" title="16.文本处理"></a>16.文本处理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat file1 file2                             <span class="comment">#查看俩个文件内容</span></span><br><span class="line">cat file1 | <span class="built_in">command</span>( sed, grep, awk, grep, etc...) &gt; result.txt  <span class="comment">#合并一个文件的详细说明文本，并将简介写入一个新文件中</span></span><br><span class="line">cat file1 | <span class="built_in">command</span>( sed, grep, awk, grep, etc...) &gt;&gt; result.txt <span class="comment">#合并一个文件的详细说明文本，并将简介写入一个已有的文件中</span></span><br><span class="line">grep Aug /var/<span class="built_in">log</span>/messages                  <span class="comment">#在文件 &#x27;/var/log/messages&#x27;中查找关键词&quot;Aug&quot;</span></span><br><span class="line">grep ^Aug /var/<span class="built_in">log</span>/messages                 <span class="comment">#在文件 &#x27;/var/log/messages&#x27;中查找以&quot;Aug&quot;开始的词汇</span></span><br><span class="line">grep [0-9] /var/<span class="built_in">log</span>/messages                <span class="comment">#选择 &#x27;/var/log/messages&#x27; 文件中所有包含数字的行</span></span><br><span class="line">grep Aug -R /var/<span class="built_in">log</span>/*                      <span class="comment">#在目录 &#x27;/var/log&#x27; 及随后的目录中搜索字符串&quot;Aug&quot;</span></span><br><span class="line">sed <span class="string">&#x27;s/stringa1/stringa2/g&#x27;</span>                 <span class="comment">#example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot;</span></span><br><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> example.txt                     <span class="comment">#从example.txt文件中删除所有空白行</span></span><br><span class="line">sed <span class="string">&#x27;/ *#/d; /^$/d&#x27;</span>                         <span class="comment">#example.txt 从example.txt文件中删除所有注释和空白行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;esempio&#x27;</span> | tr <span class="string">&#x27;[:lower:]&#x27;</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="comment">#合并上下单元格内容</span></span><br><span class="line">sed -e <span class="string">&#x27;1d&#x27;</span> result.txt                      <span class="comment">#从文件example.txt 中排除第一行</span></span><br><span class="line">sed -n <span class="string">&#x27;/stringa1/p&#x27;</span>                        <span class="comment">#查看只包含词汇 &quot;string1&quot;的行</span></span><br><span class="line">sed -e <span class="string">&#x27;s/ *$//&#x27;</span> example.txt                <span class="comment">#删除每一行最后的空白字符</span></span><br><span class="line">sed -e <span class="string">&#x27;s/stringa1//g&#x27;</span> example.txt          <span class="comment">#从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部</span></span><br><span class="line">sed -n <span class="string">&#x27;1,5p;5q&#x27;</span> example.txt                <span class="comment">#查看从第一行到第5行内容</span></span><br><span class="line">sed -n <span class="string">&#x27;5p;5q&#x27;</span> example.txt                  <span class="comment">#查看第5行</span></span><br><span class="line">sed -e <span class="string">&#x27;s/00*/0/g&#x27;</span> example.txt              <span class="comment">#用单个零替换多个零</span></span><br><span class="line">cat -n file1                                <span class="comment">#标示文件的行数</span></span><br><span class="line">cat example.txt | awk <span class="string">&#x27;NR%2==1&#x27;</span>             <span class="comment">#删除example.txt文件中的所有偶数行</span></span><br><span class="line"><span class="built_in">echo</span> a b c | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>               <span class="comment">#查看一行第一栏</span></span><br><span class="line"><span class="built_in">echo</span> a b c | awk <span class="string">&#x27;&#123;print $1,$3&#125;&#x27;</span>            <span class="comment">#查看一行的第一和第三栏</span></span><br><span class="line">paste file1 file2                           <span class="comment">#合并两个文件或两栏的内容</span></span><br><span class="line">paste -d <span class="string">&#x27;+&#x27;</span> file1 file2                    <span class="comment">#合并两个文件或两栏的内容，中间用&quot;+&quot;区分</span></span><br><span class="line">sort file1 file2                            <span class="comment">#排序两个文件的内容</span></span><br><span class="line">sort file1 file2 | uniq                     <span class="comment">#取出两个文件的并集(重复的行只保留一份)</span></span><br><span class="line">sort file1 file2 | uniq -u                  <span class="comment">#删除交集，留下其他的行</span></span><br><span class="line">sort file1 file2 | uniq -d                  <span class="comment">#取出两个文件的交集(只留下同时存在于两个文件中的文件)</span></span><br><span class="line">comm -1 file1 file2                         <span class="comment">#比较两个文件的内容只删除 &#x27;file1&#x27; 所包含的内容</span></span><br><span class="line">comm -2 file1 file2                         <span class="comment">#比较两个文件的内容只删除 &#x27;file2&#x27; 所包含的内容</span></span><br><span class="line">comm -3 file1 file2                         <span class="comment">#比较两个文件的内容只删除两个文件共有的部分</span></span><br></pre></td></tr></table></figure>

<h2 id="17-字符设置和文件格式转换"><a href="#17-字符设置和文件格式转换" class="headerlink" title="17.字符设置和文件格式转换"></a>17.字符设置和文件格式转换</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix filedos.txt fileunix.txt           <span class="comment">#将一个文本文件的格式从MSDOS转换成UNIX</span></span><br><span class="line">unix2dos fileunix.txt filedos.txt           <span class="comment">#将一个文本文件的格式从UNIX转换成MSDOS</span></span><br><span class="line">recode ..HTML &lt; page.txt &gt; page.html        <span class="comment">#将一个文本文件转换成html</span></span><br><span class="line">recode -l | more                            <span class="comment">#显示所有允许的转换格式</span></span><br></pre></td></tr></table></figure>

<h2 id="18-文件系统分析"><a href="#18-文件系统分析" class="headerlink" title="18.文件系统分析"></a>18.文件系统分析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">badblocks -v /dev/hda1              <span class="comment">#检查磁盘hda1上的坏磁块</span></span><br><span class="line">fsck /dev/hda1                      <span class="comment">#修复/检查hda1磁盘上linux文件系统的完整性</span></span><br><span class="line">fsck.ext2 /dev/hda1                 <span class="comment">#修复/检查hda1磁盘上ext2文件系统的完整性</span></span><br><span class="line">e2fsck /dev/hda1                    <span class="comment">#修复/检查hda1磁盘上ext2文件系统的完整性</span></span><br><span class="line">e2fsck -j /dev/hda1                 <span class="comment">#修复/检查hda1磁盘上ext3文件系统的完整性</span></span><br><span class="line">fsck.ext3 /dev/hda1                 <span class="comment">#修复/检查hda1磁盘上ext3文件系统的完整性</span></span><br><span class="line">fsck.vfat /dev/hda1                 <span class="comment">#修复/检查hda1磁盘上fat文件系统的完整性</span></span><br><span class="line">fsck.msdos /dev/hda1                <span class="comment">#修复/检查hda1磁盘上dos文件系统的完整性</span></span><br><span class="line">dosfsck /dev/hda1                   <span class="comment">#修复/检查hda1磁盘上dos文件系统的完整性</span></span><br></pre></td></tr></table></figure>

<h2 id="19-初始化一个文件系统"><a href="#19-初始化一个文件系统" class="headerlink" title="19.初始化一个文件系统"></a>19.初始化一个文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs /dev/hda1                  <span class="comment">#在hda1分区创建一个文件系统</span></span><br><span class="line">mke2fs /dev/hda1                <span class="comment">#在hda1分区创建一个linux ext2的文件系统</span></span><br><span class="line">mke2fs -j /dev/hda1             <span class="comment">#在hda1分区创建一个linux ext3(日志型)的文件系统</span></span><br><span class="line">mkfs -t vfat 32 -F /dev/hda1    <span class="comment">#创建一个 FAT32 文件系统</span></span><br><span class="line">fdformat -n /dev/fd0            <span class="comment">#格式化一个软盘</span></span><br><span class="line">mkswap /dev/hda3                <span class="comment">#创建一个swap文件系统</span></span><br></pre></td></tr></table></figure>

<h2 id="20-SWAP-文件系统"><a href="#20-SWAP-文件系统" class="headerlink" title="20.SWAP 文件系统"></a>20.SWAP 文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /dev/hda3            <span class="comment">#创建一个swap文件系统</span></span><br><span class="line">swapon /dev/hda3            <span class="comment">#启用一个新的swap文件系统</span></span><br><span class="line">swapon /dev/hda2 /dev/hdb3  <span class="comment">#启用两个swap分区</span></span><br></pre></td></tr></table></figure>

<h2 id="21-备份"><a href="#21-备份" class="headerlink" title="21.备份"></a>21.备份</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dump -0aj -f /tmp/home0.bak /home <span class="comment">#制作一个 &#x27;/home&#x27; 目录的完整备份</span></span><br><span class="line">dump -1aj -f /tmp/home0.bak /home <span class="comment">#制作一个 &#x27;/home&#x27; 目录的交互式备份</span></span><br><span class="line">restore -<span class="keyword">if</span> /tmp/home0.bak        <span class="comment">#还原一个交互式备份</span></span><br><span class="line">rsync -rogpav --delete /home /tmp <span class="comment">#同步两边的目录</span></span><br><span class="line">rsync -rogpav -e ssh --delete /home ip_address:/tmp <span class="comment">#通过SSH通道rsync</span></span><br><span class="line">rsync -az -e ssh --delete ip_addr:/home/public /home/<span class="built_in">local</span> <span class="comment">#通过ssh和压缩将一个远程目录同步到本地目录</span></span><br><span class="line">rsync -az -e ssh --delete /home/<span class="built_in">local</span> ip_addr:/home/public <span class="comment">#通过ssh和压缩将本地目录同步到远程目录</span></span><br><span class="line">dd bs=1M <span class="keyword">if</span>=/dev/hda | gzip | ssh user@ip_addr <span class="string">&#x27;dd of=hda.gz&#x27;</span> <span class="comment">#通过ssh在远程主机上执行一次备份本地磁盘的操作</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件</span><br><span class="line">tar -Puf backup.tar /home/user 执行一次对 <span class="string">&#x27;/home/user&#x27;</span> <span class="comment">#目录的交互式备份操作</span></span><br><span class="line">( <span class="built_in">cd</span> /tmp/<span class="built_in">local</span>/ &amp;&amp; tar c . ) | ssh -C user@ip_addr <span class="string">&#x27;cd /home/share/ &amp;&amp; tar x -p&#x27;</span> <span class="comment">#通过ssh在远程目录中复制一个目录内容</span></span><br><span class="line">( tar c /home ) | ssh -C user@ip_addr <span class="string">&#x27;cd /home/backup-home &amp;&amp; tar x -p&#x27;</span> <span class="comment">#通过ssh在远程目录中复制一个本地目录</span></span><br><span class="line">tar cf - . | (<span class="built_in">cd</span> /tmp/backup ; tar xf - ) <span class="comment">#本地将一个目录复制到另一个地方，保留原有权限及链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从一个目录查找并复制所有以 &#x27;.txt&#x27; 结尾的文件到另一个目录</span></span><br><span class="line">find /home/user1 -name <span class="string">&#x27;*.txt&#x27;</span> | xargs cp -av --target-directory=/home/backup/ --parents</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找所有以 &#x27;.log&#x27; 结尾的文件并做成一个bzip包</span></span><br><span class="line">find /var/<span class="built_in">log</span> -name <span class="string">&#x27;*.log&#x27;</span> | tar cv --files-from=- | bzip2 &gt; log.tar.bz2</span><br><span class="line">dd <span class="keyword">if</span>=/dev/hda of=/dev/fd0 bs=512 count=1 <span class="comment">#做一个将 MBR (Master Boot Record)内容复制到软盘的动作</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/fd0 of=/dev/hda bs=512 count=1 <span class="comment">#从已经保存到软盘的备份中恢复MBR内容</span></span><br></pre></td></tr></table></figure>

<h2 id="22-光盘"><a href="#22-光盘" class="headerlink" title="22.光盘"></a>22.光盘</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkisofs /dev/cdrom &gt; cd.iso                        <span class="comment">#在磁盘上创建一个光盘的iso镜像文件</span></span><br><span class="line">mkisofs /dev/cdrom | gzip &gt; cd_iso.gz              <span class="comment">#在磁盘上创建一个压缩了的光盘iso镜像文件</span></span><br><span class="line">mkisofs -J -allow-leading-dots -R -V <span class="string">&quot;Label CD&quot;</span> -iso-level 4 -o ./cd.iso data_cd <span class="comment">#创建一个目录的iso镜像文件</span></span><br><span class="line">cdrecord -v dev=/dev/cdrom cd.iso                  <span class="comment">#刻录一个ISO镜像文件</span></span><br><span class="line">gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom -     <span class="comment">#刻录一个压缩了的ISO镜像文件</span></span><br><span class="line">mount -o loop cd.iso /mnt/iso                      <span class="comment">#挂载一个ISO镜像文件</span></span><br><span class="line">cd-paranoia -B                                     <span class="comment">#从一个CD光盘转录音轨到 wav 文件中</span></span><br><span class="line">cd-paranoia -- <span class="string">&quot;-3&quot;</span>                                <span class="comment">#从一个CD光盘转录音轨到 wav 文件中（参数-3）</span></span><br><span class="line">cdrecord --scanbus                                 <span class="comment">#扫描总线以识别scsi通道</span></span><br><span class="line">cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force <span class="comment">#清空一个可复写的光盘内容</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/hdc | md5sum                            <span class="comment">#校验一个设备的md5sum编码，例如一张 CD</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux系统</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript高级程序设计》读书笔记</title>
    <url>/2019/03/28/qian-duan-zhi-shi-ti-xi/01.javascript/javascript-gao-ji-cheng-xu-she-ji-du-shu-bi-ji/</url>
    <content><![CDATA[<h2 id="第一章-JavaScript-简介"><a href="#第一章-JavaScript-简介" class="headerlink" title="第一章 JavaScript 简介"></a>第一章 JavaScript 简介</h2><h3 id="1-2-js-实现"><a href="#1-2-js-实现" class="headerlink" title="1.2 js 实现"></a>1.2 js 实现</h3><ol>
<li>一个完成的 js 实现由 3 个不同部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</li>
<li>常见的 Web 浏览器知识 ECMAScript 实现的<strong>宿主环境</strong>之一，其他环境包括 Node、Adobe Flash</li>
<li>DOM：是针对 XML 经过扩展用于 HTML 的程序编程 API</li>
<li>BOM：控制浏览器显示的页面以外部分</li>
</ol>
<h2 id="第二章-在-HTML-中使用-JavaScript"><a href="#第二章-在-HTML-中使用-JavaScript" class="headerlink" title="第二章 在 HTML 中使用 JavaScript"></a>第二章 在 HTML 中使用 JavaScript</h2><h3 id="2-1-lt-script-gt-标签"><a href="#2-1-lt-script-gt-标签" class="headerlink" title="2.1 &lt;script&gt;标签"></a>2.1 <code>&lt;script&gt;</code>标签</h3><p>下面两个属性可以控制 script 加载，它们不能严格保证执行顺序：</p>
<ol>
<li>async：不阻塞页面，下载并且执行脚本</li>
<li>defer：脚本延迟到文档被完全解析和显示后再执行。</li>
</ol>
<p>script 脚本中不要嵌入出现<code>&quot;&lt;/script&gt;&quot;</code> 字符串，会被错误识别为结束标签。正确写法是：<code>&quot;&lt;\/script&gt;&quot;</code>。</p>
<p>如果 script 标签中既有代码内容，并且也引入了外部脚本（src 属性）。浏览器只会执行外部脚本。</p>
<h3 id="2-2-可扩展超文本标记语言-XHTML"><a href="#2-2-可扩展超文本标记语言-XHTML" class="headerlink" title="2.2 可扩展超文本标记语言 XHTML"></a>2.2 可扩展超文本标记语言 XHTML</h3><p>XHTML 编写比 HTML 更严格，例如 <code>&gt;</code> 等符号都需要转义。为了保证 js 正常运行，用 <code>CDATA</code> 来包裹。</p>
<p>下面代码在不兼容 xml 的浏览器可以平稳退化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//&lt;![CDATA[</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span></span><br><span class="line">    if (a &lt; b) &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;a is less than b&quot;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//]]&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-lt-noscript-gt-元素"><a href="#2-4-lt-noscript-gt-元素" class="headerlink" title="2.4 &lt;noscript&gt; 元素"></a>2.4 <code>&lt;noscript&gt;</code> 元素</h3><p>对于不支持 js 的浏览器，此标签可平稳退化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请启用JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h3><p>针对 ES3 的不确定行为，ES5 增加了严格模式，它是“编译指示”，用来告知 Js 引擎切换到严格模式，需要在代码顶部添加：<code>&quot;use strict&quot;;</code></p>
<h3 id="3-2-关键字和保留字"><a href="#3-2-关键字和保留字" class="headerlink" title="3.2 关键字和保留字"></a>3.2 关键字和保留字</h3><p>保留字是之后可能被用作关键字的标识符。比如<code>super</code>，在 es6 中被用在了子类的构造函数中。</p>
<h3 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h3><p><code>var</code> 声明的变量存在声明提升，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>由于变量声明提升以及函数作用域，相当于以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>因此，输出结果是 <code>undefined</code></p>
<h3 id="3-4-类型"><a href="#3-4-类型" class="headerlink" title="3.4 类型"></a>3.4 类型</h3><h4 id="3-4-1-null-和-undefined"><a href="#3-4-1-null-和-undefined" class="headerlink" title="3.4.1 null 和 undefined"></a>3.4.1 null 和 undefined</h4><p><code>null</code> 和 <code>undefined</code> 不相同，区别如下：</p>
<ul>
<li>null：空对象指针，<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，常用于定义空变量</li>
<li>undefined：未定义，变量只声明时，默认赋值<code>undefined</code></li>
</ul>
<h4 id="3-4-2-8-和-16-进制"><a href="#3-4-2-8-和-16-进制" class="headerlink" title="3.4.2 8 和 16 进制"></a>3.4.2 8 和 16 进制</h4><p><code>number</code>类型：</p>
<ul>
<li>8 进制：0 开头，例如 070</li>
<li>16 进制：0x 开头，例如 0x1f</li>
<li>科学计数法：1ex，例如 1e2 = 100</li>
</ul>
<p>所有 8 和 16 进制值在运算时，都会被转化为 10 进制。</p>
<h4 id="3-4-3-特殊数字"><a href="#3-4-3-特殊数字" class="headerlink" title="3.4.3 特殊数字"></a>3.4.3 特殊数字</h4><p><code>Number.MIN_VALUE</code> 和 <code>Number.MAX_VALUE</code> 分别返回最小值和最大值。超出范围的会被转化为 <code>Infinity</code> 。</p>
<p>不合法的数，比如 1/0 ，会返回 <code>NaN</code>，需要用 <code>isNaN</code> 判断。对于对象，<code>isNaN</code> 先调用 <code>valueOf</code> ，再掉用 <code>toString</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validNum = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(validNum)); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-字符串转数字"><a href="#3-4-4-字符串转数字" class="headerlink" title="3.4.4 字符串转数字"></a>3.4.4 字符串转数字</h4><p><code>parseInt</code> 应该在第二个参数指明进制。</p>
<h4 id="3-4-5-字符串"><a href="#3-4-5-字符串" class="headerlink" title="3.4.5 字符串"></a>3.4.5 字符串</h4><p>字符串变量的值是不可变的，当改变值时，会销毁之前的字符串，然后用包含新值的字符串填充变量。</p>
<p>调用数值的 <code>toString</code> 方法，给定参数代表进制。</p>
<p>特殊编码：</p>
<ul>
<li><code>\xnn</code>：以 16 进制代码 nn 表示字符</li>
<li><code>\unnnn</code>：以 16 进制代码 nnnn 表示 Unicode 字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\x41&quot;</span>); <span class="comment">// A</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\u03a3&quot;</span>); <span class="comment">// Σ</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-6-Object-类型"><a href="#3-4-6-Object-类型" class="headerlink" title="3.4.6 Object 类型"></a>3.4.6 Object 类型</h4><p>Object 实例都有以下属性：</p>
<ul>
<li>constructor: 指向创建对象的函数</li>
<li>hasOwnProperty</li>
<li>obj1.isPrototypeOf(obj2): obj1 是不是在 obj2 的原型链上</li>
<li>propertyIsEnumerable(propName): propName 能否用 for-in 枚举</li>
</ul>
<p>关于 <code>isPrototypeOf</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="built_in">console</span>.log(o.isPrototypeOf(demo)); <span class="comment">// output: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将o放在demo实例的原型链上</span></span><br><span class="line">demo.__proto__ = Demo.prototype = o;</span><br><span class="line"><span class="built_in">console</span>.log(o.isPrototypeOf(demo)); <span class="comment">// output: true</span></span><br></pre></td></tr></table></figure>

<p>对于 BOM、DOM 等宿主环境提供的对象，可能并不继承 Object，不具有以上通性。</p>
<h3 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h3><p>1、<strong>位操作</strong></p>
<ul>
<li><code>~</code>: 按位非。<code>~110 =&gt; 001</code></li>
<li><code>&amp;</code>: 按位与。</li>
<li><code>|</code>: 按位或。</li>
<li><code>^</code>: 异或操作。位数相同返回 0，不同返回 1。</li>
<li><code>&lt;&lt;</code>: 左移</li>
<li><code>&gt;&gt;</code>: 默认情况，有符号右移，保留符号位（符合正常逻辑）</li>
<li><code>&gt;&gt;&gt;</code>: 无符号右移，在移动时候忽略符号位。</li>
</ul>
<p>正因为移动时候忽略符号位，因此例如 -64 = 111111..11100000，负数的补码会被当做正数的二进制码。</p>
<p>2、<strong>布尔操作</strong></p>
<p>一般直接使用 <code>!!</code> 进行转化。</p>
<p>3、<strong>逗号操作符</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>,</span><br><span class="line">  num2 = <span class="number">2</span>,</span><br><span class="line">  num3 = <span class="number">3</span>; <span class="comment">// 多变量声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>); <span class="comment">// 从右边开始解析，返回 1</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// output: 1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-语句"><a href="#3-6-语句" class="headerlink" title="3.6 语句"></a>3.6 语句</h3><h4 id="3-6-5-for-in-语句"><a href="#3-6-5-for-in-语句" class="headerlink" title="3.6.5 for-in 语句"></a>3.6.5 for-in 语句</h4><p>精准迭代，枚举对象属性。但是效率很低，而且输出的属性名的顺序不确定。</p>
<p>在执行前，需要检测对象是否为 <code>null</code> 或者 <code>undefined</code>，否则 es3 会报错。</p>
<h4 id="3-6-6-label-语句"><a href="#3-6-6-label-语句" class="headerlink" title="3.6.6 label 语句"></a>3.6.6 label 语句</h4><p>与<code>break</code> 和 <code>continue</code> 联合使用，主要用于多层嵌套循环的流程控制。</p>
<p>配合 <code>break</code>，直接跳出指定的 <code>label</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// i, j为5的时候，结束循环</span></span><br><span class="line">      <span class="keyword">break</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    ++num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<p>配合 <code>continue</code>，直接跳出指定的 <code>label</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">5</span> &amp;&amp; j === <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    ++num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>

<p>开启调试后会发现，当 i 和 j 为 5 的时候，跳到了 outermost，并且保持了 i 和 j 的变量值。</p>
<p>外层循环导致 i 变为 6，j 清零。</p>
<h4 id="3-6-8-with-语句"><a href="#3-6-8-with-语句" class="headerlink" title="3.6.8 with 语句"></a>3.6.8 with 语句</h4><p>设置代码作用域到指定对象中，会导致性能下降。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h3><p><code>arguments</code> 是类数组对象，严格模式下不能重写或者重新定义其中的值。</p>
<p><code>arguments.callee</code> 指向函数自身，用于编写递归函数。</p>
<p><strong>注意</strong>：js 的函数没有重载。ts 可以重载，但是也只是多类型声明，不符合传统意义的函数重载。</p>
<h2 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><h3 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h3><h4 id="4-1-2-赋值"><a href="#4-1-2-赋值" class="headerlink" title="4.1.2 赋值"></a>4.1.2 赋值</h4><p>复制函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// obj1 保存的是副本，不过这个副本是指向实例的一个指针</span></span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 中所有函数的参数都是按值传递，对于复杂类型，副本就是指向它的指针。</p>
<h4 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a>4.1.4 检测类型</h4><p>基本数据类型：<code>typeof</code>；对象类型检测：<code>instanceof</code></p>
<h3 id="4-2-执行环境和作用域"><a href="#4-2-执行环境和作用域" class="headerlink" title="4.2 执行环境和作用域"></a>4.2 执行环境和作用域</h3><p>延长作用域链的情景：</p>
<ol>
<li><code>try-catch</code>中的<code>catch</code>：作用域链前端新增错误对象</li>
<li><code>with</code>：作用域链前端新增指定对象</li>
<li>函数闭包</li>
</ol>
<h3 id="4-3-垃圾回收-GC"><a href="#4-3-垃圾回收-GC" class="headerlink" title="4.3 垃圾回收(GC)"></a>4.3 垃圾回收(GC)</h3><h4 id="4-3-1-标记清除和引用计数"><a href="#4-3-1-标记清除和引用计数" class="headerlink" title="4.3.1 标记清除和引用计数"></a>4.3.1 标记清除和引用计数</h4><p>浏览器的实现有两种：</p>
<ol>
<li><strong>标记清除</strong>：所有变量打标记；去掉环境中变量的标记，以及被环境中变量引用变量的标记；之后，清除还有标记的变量。</li>
<li><strong>引用计数</strong>：跟踪每个变量引用次数，被引用的变量就加 1；如果此变量又取了另一个变量，减 1。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="number">1</span>; <span class="comment">// 引用0</span></span><br><span class="line"><span class="keyword">const</span> copy = value; <span class="comment">// 引用+1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  copy <span class="comment">// 引用 + 1</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.copy = <span class="literal">null</span>; <span class="comment">// 引用 -1</span></span><br><span class="line"><span class="comment">// 最后，引用次数为1</span></span><br></pre></td></tr></table></figure>

<p>引用计数无法处理“循环引用”的情况，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obja = &#123;&#125;,</span><br><span class="line">    objb = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  obja.prop = objb; <span class="comment">// objb的引用次数和obja的引用次数都+1</span></span><br><span class="line">  objb.prop = obja; <span class="comment">// objb的引用次数和obja的引用次数再+1</span></span><br><span class="line">  <span class="comment">// obja 和 obj2 的引用次数均是2</span></span><br><span class="line">  <span class="comment">// 变量永远不会被清除，造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-性能优化"><a href="#4-3-3-性能优化" class="headerlink" title="4.3.3 性能优化"></a>4.3.3 性能优化</h4><p>在<strong>优化性能问题</strong>上，IE6 根据固定的内存分配量来触发 gc。但是如果脚本中声明了很多变量，并且都没有被释放，那么一直会达到触发标准，gc 会高频率触发，效率低下。</p>
<p>es7 做出了改进：临界值是动态计算的。如果一次垃圾回收的内存量低于 15%，那么临界值会翻倍；如果高于 85%，重置临界值。</p>
<h4 id="4-3-4-管理内存"><a href="#4-3-4-管理内存" class="headerlink" title="4.3.4 管理内存"></a>4.3.4 管理内存</h4><p>解除引用：不使用的变量，设置为<code>null</code>。</p>
<p>解除引用不意味变量内存回收，而是让其脱离执行环境，方便下次 gc 回收。</p>
<h2 id="5-引用类型"><a href="#5-引用类型" class="headerlink" title="5. 引用类型"></a>5. 引用类型</h2><p>ECMAScript 是面向对象语言，但不是传统的面向对象。提供构造函数，专门对接传统对象编程。</p>
<h3 id="5-1-Object-类型"><a href="#5-1-Object-类型" class="headerlink" title="5.1 Object 类型"></a>5.1 Object 类型</h3><p><code>new Object()</code> 和 <code>&#123;&#125;</code> 声明等效。</p>
<h3 id="5-2-Array-类型"><a href="#5-2-Array-类型" class="headerlink" title="5.2 Array 类型"></a>5.2 Array 类型</h3><p>创建有<code>Array</code>和 <code>[]</code>2 种方式。</p>
<p><code>length</code> 是可读写的，置 0 可以清空数组。</p>
<h4 id="5-2-1-数组检测"><a href="#5-2-1-数组检测" class="headerlink" title="5.2.1 数组检测"></a>5.2.1 数组检测</h4><p>请用 <code>Array.isArray</code> 检测数组。<code>instanceof</code> 不适用于网页包含多个框架，2 个运行环境，从一个向另一个传入数组构造函数，严格意义上并不相等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; frames &#125; = <span class="built_in">window</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> length = frames.length;</span></span><br><span class="line">  xArray = frames[length - 1].Array;</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> xArray); <span class="comment">// false</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-栈和队列"><a href="#5-2-3-栈和队列" class="headerlink" title="5.2.3 栈和队列"></a>5.2.3 栈和队列</h4><ul>
<li>栈：<code>push</code> &amp;&amp; <code>pop</code></li>
<li>队列：<code>push</code> &amp;&amp; <code>shift</code></li>
</ul>
<h4 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h4><p>concat：参数会被自动展开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> colors2 = colors.concat(<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>slice(star, end): 切片，返回新数组。</p>
<p>splice(start, count, …items):</p>
<ul>
<li>删除：不需要第三个参数</li>
<li>插入：第二参数置 0</li>
<li>替换：第二个和第三个参数要用</li>
</ul>
<h3 id="5-3-Date-类型"><a href="#5-3-Date-类型" class="headerlink" title="5.3 Date 类型"></a>5.3 Date 类型</h3><p>Date.now() 和 new Date().gewNow() 等价。</p>
<p>Date.parse(string): 返回 string 代表的日期的毫秒数。<code>年/月/日</code>，请不要使用<code>-</code>连接！</p>
<p>Date 实例可以直接比较大小，因为<code>valueOf</code>返回毫秒数。</p>
<h3 id="5-4-RegExp-类型"><a href="#5-4-RegExp-类型" class="headerlink" title="5.4 RegExp 类型"></a>5.4 RegExp 类型</h3><p>不推荐 <code>new RegExp(string)</code> 来声明正则，因为 string 是字符串，元字符需要双重转义。比如<code>\n</code>，就是<code>\\n</code>。</p>
<p>每个实例拥有以下属性：</p>
<ul>
<li>global：g</li>
<li>ignoreCase: i</li>
<li>multiline: m</li>
<li><strong>lastIndex</strong>: 搜索下一匹配项的字符位置</li>
<li><strong>source</strong>: 正则的字符串表示</li>
</ul>
<h3 id="5-5-Function-类型"><a href="#5-5-Function-类型" class="headerlink" title="5.5 Function 类型"></a>5.5 Function 类型</h3><p>代码求值时，js 引擎会将声明函数提升到源码顶部。</p>
<p><code>arguments</code>上重要属性：</p>
<ul>
<li>length：参数长度</li>
<li>callee: 函数自身引用</li>
</ul>
<p>函数上重要属性：</p>
<ul>
<li>caller: 调用此函数的函数引用。全局访问返回 null</li>
<li>length：函数希望接受的参数个数（不算默认参数）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller === outer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); <span class="comment">// true</span></span><br><span class="line">inner.length; <span class="comment">// 2 - 1 = 1</span></span><br></pre></td></tr></table></figure>

<p>函数 prototype 属性无法枚举，不能用 for-in 枚举</p>
<ul>
<li>可以使用 <code>Object.getOwnPropertyNames</code> ，返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。</li>
<li>可以使用 <code>Reflect.ownKeys</code>，返回包括所有自身属性的属性名的数组</li>
</ul>
<h3 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h3><p>num.toFixed(位数)：自动舍入，返回字符串。</p>
<p>num.toExponential(位数)：转化为科学计数法，返回字符串。</p>
<p>String.fromCharCode(…charcodes): 将字符编码转化为字符串。</p>
<p>String.charCodeAt(index): 将 index 的字符转化为字符编码。</p>
<h3 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h3><p>随机整数生成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [start, end]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomInt</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> times = end - start + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * times + start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h2><p>ECMA-62 对象定义：无序属性集合，其属性可以包括基本值、对象和函数。</p>
<h3 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1 理解对象"></a>6.1 理解对象</h3><p>ECMA 有 2 种属性：数据属性和访问器属性。它们可以通过 <code>Object.getOwnPropertyDescriptor</code> 来读取。</p>
<p><strong>1.数据属性</strong></p>
<p>通过 <code>Object.defineProperty(对象, 属性名, &#123;属性: 值&#125;)</code> 来修改，可修改的属性是：configurable(是否可通过<code>delete</code>删除)、enumerable(能否 for-in 循环)、writable(能否修改)、value。</p>
<p>可以多次调用 api 修改上述属性，除了将 <code>configurable</code> 设置为 false。</p>
<p><strong>2.访问器属性</strong></p>
<p>访问器属性不包含数据值，也是通过 <code>Object.defineProperty(对象, 属性名, &#123;属性: 值&#125;)</code> 来修改。</p>
<p>可修改的属性是：configurable、enumerable、get、set。其中，只指定 get 不指定 set，那么就是不可写；反过来，不能读。</p>
<h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h3><h4 id="6-2-1-理解原型对象"><a href="#6-2-1-理解原型对象" class="headerlink" title="6.2.1 理解原型对象"></a>6.2.1 理解原型对象</h4><p>原型模式中，实例的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>，因此，<code>构造函数.prototype.isPrototypeOf(实例)</code>返回 true。</p>
<p>因为原型链有下端“屏蔽”上端的机制，可以通过逐步 <code>delete</code> 来暴露上端属性。</p>
<h4 id="6-2-2-原型与-in-操作符"><a href="#6-2-2-原型与-in-操作符" class="headerlink" title="6.2.2 原型与 in 操作符"></a>6.2.2 原型与 <code>in</code> 操作符</h4><p>如果对象可以访问给定属性，那么 <code>in</code> 返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person); <span class="comment">// output</span></span><br></pre></td></tr></table></figure>

<p>检测 <code>prototype</code> 是否位于 原型链上，而不位于实例上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPropertyInPrototype</span>(<span class="params">object, prototype</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// hasOwnProperty 是否位于实例上</span></span><br><span class="line">  <span class="keyword">return</span> prototype <span class="keyword">in</span> object &amp;&amp; !object.hasOwnProperty(prototype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-3-自定义原型"><a href="#6-2-3-自定义原型" class="headerlink" title="6.2.3 自定义原型"></a>6.2.3 自定义原型</h4><p>(构造)函数的<code>constructor</code> 属性是自身，所以重写<code>prototype</code>的时候，需要注意：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;dongyuanxin&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// Person.prototype.constructor 是不可枚举的</span></span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="6-2-4-动态原型"><a href="#6-2-4-动态原型" class="headerlink" title="6.2.4 动态原型"></a>6.2.4 动态原型</h4><p>为了对应 OO 编程习惯，prototype 上属性在访问时动态创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;person&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.sayHello !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hello, I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-6-稳妥构造函数"><a href="#6-2-6-稳妥构造函数" class="headerlink" title="6.2.6 稳妥构造函数"></a>6.2.6 稳妥构造函数</h4><p>经常使用，尤其是在对原生对象做拓展时候，而且不能影响原有原型链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PowerDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  date.format = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> year = addZeroStr(date.getFullYear()),</span><br><span class="line">      month = addZeroStr(date.getMonth() + <span class="number">1</span>),</span><br><span class="line">      day = addZeroStr(date.getDate()),</span><br><span class="line">      hour = addZeroStr(date.getHours()),</span><br><span class="line">      minute = addZeroStr(date.getMinutes()),</span><br><span class="line">      second = addZeroStr(date.getSeconds());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;year&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;day&#125;</span> <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minute&#125;</span>:<span class="subst">$&#123;second&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 可以new调用，因为return重置了返回值</span></span><br><span class="line">  <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h3><ul>
<li>接口继承：继承方法签名</li>
<li>实现继承：继承实际方法</li>
</ul>
<p>常见四种方法：<a href="http://localhost:8080/passages/2019-03-27-javascript-second/">JavaScript 基础知识梳理-下</a></p>
<h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h2><h3 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2 闭包"></a>7.2 闭包</h3><p>闭包是指：有权访问另一个函数作用域中的变量的函数。作用域得到了延长。</p>
<p>一个经典问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 result 中的函数，返回值均是 10。这是因为 <code>var</code> 不是块级作用域，闭包声明造成了内函数可以访问 <code>createFunction</code> 的作用域，并且在结束函数后，变量<code>i</code>的生命被延长了下来。例如，当调用 <code>result[0]</code> 的时候，就会访问并且返回 <code>createFunction</code> 中的 变量<code>i</code>的值。</p>
<p>如果将 <code>var</code> 换成 <code>let</code>，则不存在这个问题。虽然变量<code>i</code>生命被延长，也属于 <code>createFunction</code>作用域，但是<code>let</code>本身是“<strong>块级作用域</strong>”。也就是说，闭包中返回的<code>i</code>是当前循环下的<code>i</code>，没有发生污染。</p>
<h3 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3 模仿块级作用域"></a>7.3 模仿块级作用域</h3><p>下面写法内存占用低，标记清除的<code>gc</code>在函数运行完，检测到不被使用，会立即销毁作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="7-4-私有变量"><a href="#7-4-私有变量" class="headerlink" title="7.4 私有变量"></a>7.4 私有变量</h3><p>利用闭包，可以很巧妙地实现静态私有变量、私有函数方法等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span>; <span class="comment">// 静态私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name + <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h2><h3 id="8-1-window-对象"><a href="#8-1-window-对象" class="headerlink" title="8.1 window 对象"></a>8.1 window 对象</h3><p>双重角色：js 访问浏览器的 api + ECMAScript 规定的 global 对象。</p>
<h4 id="8-1-1-全局作用域"><a href="#8-1-1-全局作用域" class="headerlink" title="8.1.1 全局作用域"></a>8.1.1 全局作用域</h4><p>定义在全局的变量不能被 delete, 定义在 window 上的属性可以被 delete。</p>
<h4 id="8-1-2-窗口关系及框架"><a href="#8-1-2-窗口关系及框架" class="headerlink" title="8.1.2 窗口关系及框架"></a>8.1.2 窗口关系及框架</h4><p>对于 window 的<code>frames</code>，为了保证兼容性，请使用：<code>top.frames</code>。因为<code>top</code>是绝对的。</p>
<p>除了<code>top</code>外，还有<code>parent</code>，在没有任何框架情况下，<code>top === window</code>。</p>
<p>最后，还有<code>self</code>。在 sw 中，常用 self 访问 window 上的 api。</p>
<h4 id="8-1-3-窗口位置"><a href="#8-1-3-窗口位置" class="headerlink" title="8.1.3 窗口位置"></a>8.1.3 窗口位置</h4><p>跨浏览器取得窗口左边、上边的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> leftPos =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft === <span class="string">&quot;number&quot;</span> ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">let</span> topPos =</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop === <span class="string">&quot;number&quot;</span> ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>

<p>此外，还有<code>window.moveTo(x, y)</code> 和 <code>window.moveBy(offsetX, offsetY)</code>两个方法移动位置。但是默认是禁用的。</p>
<h4 id="8-1-4-窗口大小"><a href="#8-1-4-窗口大小" class="headerlink" title="8.1.4 窗口大小"></a>8.1.4 窗口大小</h4><p>窗口大小无法确定，但是可以跨浏览器获得页面视图大小：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">  pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode === <span class="string">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否是标准模式</span></span><br><span class="line">    pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 是否是混杂模式</span></span><br><span class="line">    pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">    pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还有<code>window.resizeTo(width, height)</code> 和 <code>window.resize(offsetWidth, offsetHeight)</code>调整大小。但是默认是禁用的。</p>
<h4 id="8-1-5-导航和打开窗口"><a href="#8-1-5-导航和打开窗口" class="headerlink" title="8.1.5 导航和打开窗口"></a>8.1.5 导航和打开窗口</h4><p><code>window.open(href, windowName, paramsString)</code>: 最后一个参数形如 <code>height=400,width=10</code>。</p>
<p>这里有同域限制，并且返回的指针指向新开窗口，可以使用以上被禁用的方法。</p>
<p>对于一些浏览器插件，会禁用弹出，兼容代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">&quot;http://baidu.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!wroxWin) &#123;</span><br><span class="line">    <span class="comment">// 打开失败</span></span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 插件禁止后，会报错</span></span><br><span class="line">  blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-7-系统对话框"><a href="#8-1-7-系统对话框" class="headerlink" title="8.1.7 系统对话框"></a>8.1.7 系统对话框</h4><p>它们是浏览器决定的，是同步和模态的。显示的时候，会终止代码执行。</p>
<h3 id="8-2-location-对象"><a href="#8-2-location-对象" class="headerlink" title="8.2 location 对象"></a>8.2 location 对象</h3><p>location.href(最常用) 和 window.location 本质都是调用 location.assign()。</p>
<p>除此之外，修改 location 上的其他属性，也可以改变当前加载的页面，比如 <code>location.hash=&#39;#setion&#39;</code></p>
<p>以上方法，会在浏览器中生成新的历史记录。使用<code>location.replace()</code>方法，不会在浏览器中生成历史记录。</p>
<p>location.reload(true)：强制重新加载。</p>
<h3 id="8-3-navigator-对象"><a href="#8-3-navigator-对象" class="headerlink" title="8.3 navigator 对象"></a>8.3 navigator 对象</h3><h4 id="8-3-1-检测插件"><a href="#8-3-1-检测插件" class="headerlink" title="8.3.1 检测插件"></a>8.3.1 检测插件</h4><p><code>navigator.plugins</code> 存放插件信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用检测方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name = <span class="string">&quot;&quot;</span></span>) </span>&#123;</span><br><span class="line">  name = name.toLocaleLowerCase();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (navigator.plugins[i].name.toLocaleLowerCase().indexOf(name) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但由于 IE 浏览器的兼容，最好针对不同浏览器封装不同的插件检测方法。</p>
<h4 id="8-3-2-注册处理程序"><a href="#8-3-2-注册处理程序" class="headerlink" title="8.3.2 注册处理程序"></a>8.3.2 注册处理程序</h4><p>google 支持 register​Protocol​Handler 自定义协议。比如打开<code>https://www.baidu.com</code>的控制台，在其中输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 理论上是这样，但是效果不好</span></span><br><span class="line">navigator.registerProtocolHandler(</span><br><span class="line">  <span class="string">&quot;web+baidu&quot;</span>,</span><br><span class="line">  <span class="string">&quot;https://www.baidu.com/s?wd=%s&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Baidu handler&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="8-5-history-对象"><a href="#8-5-history-对象" class="headerlink" title="8.5 history 对象"></a>8.5 history 对象</h3><p>history.go(): 任意跳转。数字代表前后跳转，字符串会自动找寻历史中最近的位置跳转。</p>
<p>history.length: 保存历史记录的数量。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础总结</title>
    <url>/2016/11/24/c-yu-yan/c-yu-yan-ji-chu-zong-jie/</url>
    <content><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>C语言的32个关键词：（由系统定义，不能重做其他定义）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>  <span class="keyword">break</span>  <span class="keyword">case</span>  <span class="keyword">char</span>  <span class="keyword">const</span>  </span><br><span class="line"><span class="keyword">continue</span>  <span class="keyword">default</span>  <span class="keyword">do</span>  <span class="keyword">double</span>  <span class="keyword">else</span> </span><br><span class="line"><span class="keyword">enum</span>  <span class="keyword">extern</span>  <span class="keyword">float</span>  <span class="keyword">for</span>  <span class="keyword">goto</span>  </span><br><span class="line"><span class="keyword">if</span>  <span class="keyword">int</span>  <span class="keyword">long</span>  <span class="keyword">register</span>  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">short</span>  <span class="keyword">signed</span>  <span class="keyword">sizeof</span>  <span class="keyword">static</span>  struct</span><br><span class="line"><span class="keyword">switch</span>  <span class="keyword">typedef</span>  <span class="keyword">unsigned</span>  <span class="keyword">unsigned</span>  </span><br><span class="line"><span class="keyword">union</span>  <span class="keyword">void</span>  <span class="keyword">volatile</span>  <span class="keyword">while</span>  </span><br></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型大概分为俩种：基本类型数据、复合类型数据</p>
<h3 id="基本类型数据"><a href="#基本类型数据" class="headerlink" title="基本类型数据"></a>基本类型数据</h3><p><strong>整数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">整型     —— int      　　　　－－４字节  </span><br><span class="line">短整型   —— short int	　　　——２字节</span><br><span class="line">长整型   —— long int	　　　——８字节    　　</span><br></pre></td></tr></table></figure>
<p><strong>浮点数【实数】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单精度浮点数 —— float    　　——４字节</span><br><span class="line">双精度浮点数 —— double　	　——８字节</span><br></pre></td></tr></table></figure>
<p><strong>字符</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">char                      　　——１字节</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="复合类型数据"><a href="#复合类型数据" class="headerlink" title="复合类型数据"></a>复合类型数据</h3><p>结构体<br>枚举<br>共用体（已淘汰）  </p>
<h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>变量的本质是内存中一段存储空间</p>
<h3 id="变量为什么必须初始化"><a href="#变量为什么必须初始化" class="headerlink" title="变量为什么必须初始化"></a>变量为什么必须初始化</h3><p>所谓初始化就是赋值的意思</p>
<h3 id="如何定义变量"><a href="#如何定义变量" class="headerlink" title="如何定义变量"></a>如何定义变量</h3><p>数据类型 变量名 = 要赋的值；<br>等价于<br>数据类型 变量名；<br>变量名 = 要赋的值；<br>举例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;   等价于  <span class="keyword">int</span> i ;   i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> i,  j ;   等价于  <span class="keyword">int</span> i ;   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> i,  j = <span class="number">3</span> ;   等价于  <span class="keyword">int</span> i ;   <span class="keyword">int</span> j ;   j = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>,   j = <span class="number">5</span> ;   等价于   <span class="keyword">int</span> i ,  j ;   i = <span class="number">5</span> ;  j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> i ,  j ;   i = j = <span class="number">5</span> ;等价于   <span class="keyword">int</span> i ,  j ;  i = <span class="number">5</span>;  j = <span class="number">5</span>;   </span><br></pre></td></tr></table></figure>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> total;</span><br><span class="line">total=(<span class="keyword">int</span>)<span class="number">10.9</span>+(<span class="keyword">int</span>)<span class="number">12.7</span>+(<span class="keyword">int</span>)<span class="number">11.8</span>;</span><br><span class="line"><span class="comment">//total=10+12+11=33</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点数的存错所带来的问题"><a href="#浮点数的存错所带来的问题" class="headerlink" title="浮点数的存错所带来的问题"></a>浮点数的存错所带来的问题</h3><p>float和 double都不能保证可以把所有实数都准确的保存在计算机中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> i = <span class="number">99.9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, i);   <span class="comment">//99.900002</span></span><br></pre></td></tr></table></figure>

<h3 id="什么是进制"><a href="#什么是进制" class="headerlink" title="什么是进制"></a>什么是进制</h3><p>十进制就是逢十进一(人类最习惯使用的是十进制)<br>二进制就是逢二进一<br>生活中用到进制的例子：<br>一周七天：         七进制<br>一年十二个月：     十二进制<br>一小时六十分钟：   六十进制<br>电脑中的数据:       二进制(我们的计算机只识别二进制)<br>为了实际需要 我们又建立了八进制和十六进制   </p>
<blockquote>
<p>C语言规定八进制前要加0（注意是零不是字母o），十六进制前要加0X或0x，十进制前什么都不加！<br>在汇编中：在数字后加字母B表示二进制数，加字母O表示八进制数，加字母D表示十进制，加字母H表示十六进制。</p>
</blockquote>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1011B</span>为二进制数<span class="number">1011</span>，也记为（<span class="number">1011</span>）<span class="number">2</span></span><br><span class="line"><span class="number">1357</span>O为八进制数<span class="number">1357</span>，也记为（<span class="number">1357</span>）<span class="number">8</span></span><br><span class="line"><span class="number">2049</span>D为十进制数<span class="number">2049</span>，也记为（<span class="number">2049</span>）<span class="number">10</span></span><br><span class="line"><span class="number">3F</span>B9H为十六进制数<span class="number">3F</span>B9，也记为（<span class="number">3F</span>B9）<span class="number">16</span></span><br></pre></td></tr></table></figure>

<h3 id="什么叫n进制"><a href="#什么叫n进制" class="headerlink" title="什么叫n进制"></a>什么叫n进制</h3><p>十进制<br>十个基数，逢10进一<br>基数：0 1 2 3 4 5 6 7 8 9<br>二进制<br>二个基数  逢二进一<br>基数： 0  1<br>八进制<br>8个基数  逢8进一<br>基数：   0 1 2 3 4 5 6 7<br>十六进制<br>16个基数 逢16进一<br>基数：  0 1 2 3 4 5 6 7 8 9 a b c d e f  或<br>0 1 2 3 4 5 6 7 8 9 A B C D E F  </p>
<h3 id="常量在c语言中如何表示的"><a href="#常量在c语言中如何表示的" class="headerlink" title="常量在c语言中如何表示的"></a>常量在c语言中如何表示的</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>十进制：    传统的写法<br>十六进制：  前面加0x或0X，是数字0加x<br>八进制：    前面加数字0 </p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>传统写法<br>float  x = 3.2;//传统<br>科学计数法<br>float  x = 3.2e3；//x的值是3200<br>float  x = 123.45e-2; //x的值是1.2345  </p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>单个字符用单引号括起来<br>‘A’表示字符A<br>‘AB’是错误的<br>“AB”是正确的<br>字符串用双引号括起来<br>“A”正确，因为”A”代表了 ‘A’  ‘\0’ 的组合   </p>
<h3 id="常量以什么样的二进制代码存储在计算机中"><a href="#常量以什么样的二进制代码存储在计算机中" class="headerlink" title="常量以什么样的二进制代码存储在计算机中"></a>常量以什么样的二进制代码存储在计算机中</h3><p>整数是以补码的形式转化为二进制代码存储在计算机中的<br>实数是以IEEE754标准转化为二进制代码储存在计算机中的<br>具体可参见末尾的 穿插在课堂中的零散知识笔记<br>字符的本质实际也是与整数的存储方式相同    </p>
<h3 id="什么是字节"><a href="#什么是字节" class="headerlink" title="什么是字节"></a>什么是字节</h3><p>字节就是存储数据的单位，并且是硬件所能访问的最小单位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>字节 = <span class="number">8</span>位</span><br><span class="line"><span class="number">1</span>K 	=  <span class="number">1024</span>字节</span><br><span class="line"><span class="number">1</span>M 	=  <span class="number">1024</span> K</span><br><span class="line"><span class="number">1</span>G 	=  <span class="number">1024</span> M</span><br><span class="line"><span class="number">1</span>T    =  <span class="number">1024</span>G</span><br></pre></td></tr></table></figure>
<p>买硬盘时的换算是以1000为单位的</p>
<h3 id="不同类型的数据之间相互赋值的问题"><a href="#不同类型的数据之间相互赋值的问题" class="headerlink" title="不同类型的数据之间相互赋值的问题"></a>不同类型的数据之间相互赋值的问题</h3><p>暂不考虑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i = <span class="number">45</span>;</span><br><span class="line"><span class="keyword">long</span>  j = <span class="number">102345</span>;</span><br><span class="line">i= j;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>,  i,  j);</span><br><span class="line"><span class="keyword">float</span> x = <span class="number">6.6</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="number">8.8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f %lf\n&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>
<h3 id="14、什么是ASCII"><a href="#14、什么是ASCII" class="headerlink" title="14、什么是ASCII"></a>14、什么是ASCII</h3><p>ASCII不是一个值，而是一种规定，ASCII规定了不同的字符是使用哪个整数值去表示,它规定了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span>  --  <span class="number">65</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span>  --  <span class="number">66</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>  --  <span class="number">97</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span>  --  <span class="number">98</span></span><br></pre></td></tr></table></figure>
<h3 id="字符的存储"><a href="#字符的存储" class="headerlink" title="字符的存储"></a>字符的存储</h3><p>字符本质上与整数的存储方式相同</p>
<h3 id="基本的输入和输出函数"><a href="#基本的输入和输出函数" class="headerlink" title="基本的输入和输出函数"></a>基本的输入和输出函数</h3><h4 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h4><p>将变量的内容输出到显示器上<br><strong>四种用法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">printf</span> (<span class="string">&quot;字符串\n&quot;</span>)</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span> (<span class="string">&quot;输出控制符&quot;</span>，输出参数)；</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span> (<span class="string">&quot;输出字符1  输出字符2 。。。。&quot;</span>， 输出参数<span class="number">1</span>， 输出参数<span class="number">2</span>， 。。。)；</span><br><span class="line">输出控制符和参数的个数必须一一对应</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;输出控制符  非输出控制符&quot;</span>， 输出参数)；</span><br></pre></td></tr></table></figure>
<p>输出控制符包含如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%d                    --  <span class="keyword">int</span> （十进制）</span><br><span class="line">%ld                    --   <span class="keyword">long</span> <span class="keyword">int</span></span><br><span class="line">%c                    --  <span class="keyword">char</span></span><br><span class="line">%f                    --  <span class="keyword">float</span></span><br><span class="line">%lf                    --  <span class="keyword">double</span></span><br><span class="line">%x(或者%X或者%#X)   --  <span class="keyword">int</span> 或 <span class="keyword">long</span> <span class="keyword">int</span> 或 <span class="keyword">short</span> <span class="keyword">int</span></span><br><span class="line">%o                    --  同上</span><br><span class="line">%s                    --  字符串</span><br></pre></td></tr></table></figure>
<p><strong>为什么需要输出控制符?</strong>     </p>
<ol>
<li> 01组成的代码可以表示数据也可以表示指令   </li>
<li> 如果01组成的代码表示的是数据的话，那么同样的01代码组合以不同的输出格式输出就会有不同的输出结果 </li>
</ol>
<h4 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h4><p><strong>两种用法：</strong><br>用法一：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;输入控制符&quot;</span>， 输入参数);   </span><br></pre></td></tr></table></figure>
<p>功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入已输入参数的值为地址的变量中。<br>用法二： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;非输入控制符 输入控制符&quot;</span>， 输入参数);   </span><br></pre></td></tr></table></figure>
<p>功能：将从键盘输入的字符转化为输入控制符所规定格式的数据，然后存入以输入参数的值为地址的变量中<br>非输入控制符必须原样输入   </p>
<p>如何使用scanf编写出高质量代码</p>
<ul>
<li><p>使用scanf之前最好先使用printf提示用户以什么样的方式来输入</p>
</li>
<li><p>Scanf中尽量不要使用非输入控制符，尤其是不要用\n</p>
</li>
<li><p>应该编写代码对用户的非法输入做适当的处理【非重点】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch=getchar()) != <span class="string">&#x27;\n&#x27;</span>）</span><br><span class="line">		<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li>
<li><p>算术运算符</p>
</li>
<li><p>关系运算符</p>
</li>
<li><p>逻辑运算符</p>
</li>
<li><p>位运算符</p>
</li>
<li><p>赋值运算符</p>
</li>
<li><p>杂项运算符</p>
</li>
</ul>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>五个关键符号：<code>+   -   *   /(除)   %(取余数)</code>     </p>
<ul>
<li>除法的运算结果和运算对象的数据类型有关，两个数都是int，则商就是int，若商有小数，则截取小数部分；</li>
<li>被除数和除数中只要有一个或两个都是浮点型数据，则商也是浮点型，不截取小数部分。</li>
<li>取余的运算对象必须是整数，结果是整除后的余数，其余数的符号与被除数相等。</li>
</ul>
<p>如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>/<span class="number">5</span> == <span class="number">3</span>   </span><br><span class="line"><span class="number">16</span>/<span class="number">5.0</span> == <span class="number">3.20000</span>    </span><br><span class="line"><span class="number">-13</span>/<span class="number">4</span> == <span class="number">-4</span>    </span><br><span class="line"><span class="number">-13</span>/<span class="number">-3</span> = <span class="number">4</span>    </span><br><span class="line"><span class="number">3</span>/<span class="number">5</span> = <span class="number">0</span>     </span><br><span class="line"><span class="number">5</span>/<span class="number">3</span> == <span class="number">1</span></span><br><span class="line">###</span><br><span class="line"><span class="number">13</span>%<span class="number">3</span> == <span class="number">1</span>    </span><br><span class="line"><span class="number">13</span>%<span class="number">-3</span> == <span class="number">1</span>    </span><br><span class="line"><span class="number">-13</span>%<span class="number">3</span> == <span class="number">-1</span></span><br><span class="line"><span class="number">-13</span>%<span class="number">23</span> == <span class="number">-13</span>    </span><br><span class="line"><span class="number">3</span>%<span class="number">5</span> == <span class="number">3</span> </span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>六个符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;(大于)    &gt;=(大于等于)    &lt;(小于)    &lt;=(小于等于)    !=(不等于)    ==(等于)</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算法"><a href="#逻辑运算法" class="headerlink" title="逻辑运算法"></a>逻辑运算法</h3><p>三个关键符号:!(非)    &amp;&amp;(并且)    ||(或)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">！真          假</span><br><span class="line">！假          真</span><br><span class="line"></span><br><span class="line">真&amp;&amp;真        真</span><br><span class="line">真&amp;&amp;假        假</span><br><span class="line">假&amp;&amp;真        假</span><br><span class="line"></span><br><span class="line">假&amp;&amp;假        假</span><br><span class="line"></span><br><span class="line">真||假         真</span><br><span class="line">假||真         真</span><br><span class="line">真||真         真</span><br><span class="line">假||假         假 </span><br></pre></td></tr></table></figure>
<h4 id="C语言对真假的处理"><a href="#C语言对真假的处理" class="headerlink" title="C语言对真假的处理"></a>C语言对真假的处理</h4><p>非零是真<br>零是假      </p>
<p>真用1表示<br>假用0表示      </p>
<p>&amp;&amp;左边的表达式为假  右边的表达式肯定不会执行<br>| |左边的表达式为真  右边的表达式肯定不会执行      </p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>五个符号<code>=    +=    *=    /=    -=</code></p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>&amp;(按位于)、| (按位或)、~(按位取反)、^(按位异或)、&lt;&lt;(按位左移)、&gt;&gt;(按位右移)</p>
<h4 id="按位于"><a href="#按位于" class="headerlink" title="按位于"></a>按位于</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&amp;<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>&amp;<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>&amp;<span class="number">7</span>=<span class="number">5</span>  <span class="number">21</span>&amp;<span class="number">7</span>=<span class="number">5</span></span><br><span class="line"><span class="number">5</span>&amp;<span class="number">1</span>=<span class="number">1</span>  <span class="number">5</span>&amp;<span class="number">10</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&amp;&amp; 逻辑与 也叫并且,注意&amp;&amp;与&amp; 的含义完全不同</p>
<h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>|<span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>|<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>|<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>|<span class="number">0</span> =<span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>|| 逻辑或与| 按位或含义不同</p>
</blockquote>
<h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>相同为零不同为1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>^<span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span>^<span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span>^<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span>^<span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="按位左移"><a href="#按位左移" class="headerlink" title="按位左移"></a>按位左移</h4><p>i&lt;&lt;3表示把i的所有二进制位左移3位，右边补零；左移n位相当于乘以2的n次方   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A）i = i*<span class="number">8</span></span><br><span class="line">B）i = i&lt;&lt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>请问上述两个语句，哪个语句执行的速度快。<br>答案： B快  </p>
<h4 id="按位右移"><a href="#按位右移" class="headerlink" title="按位右移"></a>按位右移</h4><p>I&gt;&gt;3表示把i的所有二进制位右移3位，左边一般是0，当然也可能补1。<br>右移n位相当于除以2的n次方，前提是数据不能丢失。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A）i = i/<span class="number">8</span></span><br><span class="line">B）i = i&gt;&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>请问上述两个语句，哪个语句执行的速度快。<br>答案： B快</p>
<h4 id="位运算的现实意义"><a href="#位运算的现实意义" class="headerlink" title="位运算的现实意义"></a>位运算的现实意义</h4><p>通过位运算符我们可以对数据的操作精确到每一位</p>
<h3 id="优先级别"><a href="#优先级别" class="headerlink" title="优先级别"></a>优先级别</h3><p>优先级：算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符。逻辑运算符中“逻辑非 !”除外</p>
<blockquote>
<p>还有一些自增 自减 三目运算符 逗号表达式在这就不过多阐述了</p>
</blockquote>
<h3 id="琐碎的运算符知识"><a href="#琐碎的运算符知识" class="headerlink" title="琐碎的运算符知识"></a>琐碎的运算符知识</h3><h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><p>自增【或者自减】<br>前自增   –   ++i<br>后自增   –   i++    </p>
<p><strong>相同：</strong> 最终都使i的值加1<br><strong>不同：</strong>前自增整体表达式的值是i加1之后的值；后自增整体表达式的值是i加1之前的值。区别在于一个后加，一个先加</p>
<p>自增的好处：代码更精练；自增的速度更快。</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A ? B : C</span><br><span class="line">等价于</span><br><span class="line">If  (A)</span><br><span class="line">B；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">C;</span><br></pre></td></tr></table></figure>
<h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p>格式：<code>（A, B, C, D）</code>     </p>
<p>功能：从左到右执行;最终表达式的值是最后一项的值</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制：程序代码执行的顺序。</p>
<p>流程控制的分类有俩种：</p>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>根据程序执行文本自上至下执行</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>定义：某些代码可执行，也可能不执行，有选择的执行某些代码</p>
<ol>
<li><p>if最简单的用法<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if （表达式）</span><br><span class="line">         语句</span><br></pre></td></tr></table></figure>
<p>解释：如果表达式为真，执行语句,如果表达式为假，语句不执行</p>
</li>
<li><p>if的范围问题（重点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)</span><br><span class="line">         语句A；</span><br><span class="line">         语句B；</span><br></pre></td></tr></table></figure>
<p>解释：if默认只能控制语句A的执行或不执行,if无法控制语句B的执行或不执行;或者讲： 语句B一定会执行</p>
</li>
<li><p>域范围</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> （表达式）</span><br><span class="line">&#123;</span><br><span class="line">   语句A；</span><br><span class="line">   语句B；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果表达式成立则语句A和语句B均会执行。</p>
<blockquote>
<p>由此可见：if默认只能控制一个语句的执行或不执行，如果想控制多个语句的执行或不执行就必须把这些语句用{}括起来。</p>
</blockquote>
</li>
</ol>
<h3 id="if…else-if的用法"><a href="#if…else-if的用法" class="headerlink" title="if…else if的用法"></a>if…else if的用法</h3><p>格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>  (表达式<span class="number">1</span>)</span><br><span class="line">   A;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>  (表达式<span class="number">2</span>)</span><br><span class="line">   B;</span><br><span class="line"><span class="keyword">if</span>  (表达式<span class="number">3</span>)</span><br><span class="line">   C;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   D;</span><br></pre></td></tr></table></figure>
<p>如果表达式1不成立则判断表达式2(若成立则执行语句B),若不成立则判断表达式3,如果全部都不成立,则执行D语句</p>
<h3 id="如何看懂一个程序"><a href="#如何看懂一个程序" class="headerlink" title="如何看懂一个程序"></a>如何看懂一个程序</h3><p>分三步：</p>
<ol>
<li>流程</li>
<li>每个语句的功能</li>
<li>试 数</li>
</ol>
<h3 id="如何学习一些需要算法的程序"><a href="#如何学习一些需要算法的程序" class="headerlink" title="如何学习一些需要算法的程序"></a>如何学习一些需要算法的程序</h3><ol>
<li>尝试自己去编程解决它但要意识到大部分人都是自己无法解决的，如果解决不了，这时不要气馁,如果十五分钟还想不出来，此时我建议您就可以看答案了</li>
<li>如果解决不了，就看答案,关键是把答案看懂，这个要花很大的精力，也是我们学习的重点,看懂一个程序要分三步：流程、每个语句的功能、试数</li>
<li>看懂之后尝试自己去修改程序，并且知道修改之后程序的不同输出结果的含义不建议看懂程序之后就立即自己敲程序</li>
<li>照着答案去敲</li>
<li>调试错误</li>
<li>不看答案，自己独立把答案敲出来</li>
<li>如果程序实在无法彻底理解，就把它背会，无法彻底理解的程序很少很少几乎没有</li>
</ol>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>定义：某些代码会被重复执行。</p>
<ul>
<li>for</li>
<li>while</li>
<li>do…while</li>
</ul>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="number">1</span>； <span class="number">2</span>； <span class="number">3</span>）  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">for</span> （<span class="number">4</span>； <span class="number">5</span>； <span class="number">6</span>）<span class="comment">//2</span></span><br><span class="line">      A;  <span class="comment">//3</span></span><br><span class="line">      B;  <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>整体式两个语句，1 2 3是一个语句4是第二个语句。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>for和while可以相互转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（<span class="number">1</span>； <span class="number">2</span>； <span class="number">3</span>）</span><br><span class="line">      A;</span><br><span class="line"></span><br><span class="line">##等价于</span><br><span class="line"><span class="number">1</span>；</span><br><span class="line">While（<span class="number">2</span>）</span><br><span class="line">&#123;</span><br><span class="line">      A；</span><br><span class="line">      <span class="number">3</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while和for可以相互转化,但for的逻辑性更强，更不容易出错，推荐多使用for。什么时候使用while，什么时候使用for<br>没法说，用多了自然而然就知道了。</p>
<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   语句A</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>无论while括号成立与否都会执行语句A。</p>
<h3 id="关键字break和continue："><a href="#关键字break和continue：" class="headerlink" title="关键字break和continue："></a>关键字break和continue：</h3><h4 id="break（很重要）"><a href="#break（很重要）" class="headerlink" title="break（很重要）"></a>break（很重要）</h4><p>break如果用于循环是用来终止循环<br>break如果用于switch,则是用于终止switch<br>break不能直接用于if,除非if属于循环内部的<br>在多层循环中，break只能终止距离它最近的那个循环    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;<span class="number">4</span>;++j)</span><br><span class="line">		<span class="keyword">break</span>;  <span class="comment">//break只能终止距离它最近的循环</span></span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;同志们好!\n&quot;</span>); <span class="comment">//依旧输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="continue（用的很少）"><a href="#continue（用的很少）" class="headerlink" title="continue（用的很少）"></a>continue（用的很少）</h4><p>用于跳过本次循环余下的语句，转去判断是否     </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	A;</span><br><span class="line">	B;</span><br><span class="line">	<span class="keyword">continue</span>;<span class="comment">//如果执行该语句，则执行完该语句后，会执行语句3，C和D都不会执行</span></span><br><span class="line">	C;</span><br><span class="line">	D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-为什么需要数组？"><a href="#1-为什么需要数组？" class="headerlink" title="1.为什么需要数组？"></a>1.为什么需要数组？</h3><p>为了解决大量同类型数据的存储和使用问题。<br>为了模拟现实世界<br>c语言不像其他语言存在对象(jvascript(let object=new Object()),java),所以需要数组去模拟。</p>
<h3 id="2-数组的分类"><a href="#2-数组的分类" class="headerlink" title="2.数组的分类"></a>2.数组的分类</h3><p>一维数组、二维数组、多维数组。</p>
<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>怎么定义一维数组?<br>为n个变量连续分配存储空间<br>所有的变量数据类型必须相同<br>所有变量所占的字节大小必须相等      </p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];   <span class="comment">//（如果是js则var a[5];则会报错,声明必须赋值）</span></span><br></pre></td></tr></table></figure>
<p>一维数组名不代表数组中所有的元素，<br>一维数组名代表数组第一个元素的地址</p>
<p>有关一维数组的操作<br>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//完全初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//不完全初始化，未被初始化的元素自动为零</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]; <span class="comment">//不初始化，所有元素是垃圾值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//清零</span></span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//错误,只有在定义数组的同时才可以整体赋值，其他情况下整体赋值都是错误的</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">a[<span class="number">5</span>] = <span class="number">100</span>;  <span class="comment">//错误,因为没有a[5]这个元素,最大只有a[4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//## 如果把a数组中的值全部复制给b数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">错误写法：</span><br><span class="line">b = a;  <span class="comment">// error</span></span><br><span class="line">正确的写法</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">   b[i] = a[i];</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">//总共是12元素看，可以当做3行四列看待</span></span><br></pre></td></tr></table></figure>
<p>这12个元素的名字依次是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]  a[<span class="number">0</span>][<span class="number">1</span>]  a[<span class="number">0</span>][<span class="number">2</span>]  a[<span class="number">0</span>][<span class="number">3</span>] </span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]  a[<span class="number">1</span>][<span class="number">1</span>]  a[<span class="number">1</span>][<span class="number">2</span>]  a[<span class="number">1</span>][<span class="number">3</span>]  </span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]  a[<span class="number">2</span>][<span class="number">1</span>]  a[<span class="number">2</span>][<span class="number">2</span>]  a[<span class="number">2</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>初始化俩种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">               &#123;<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">               &#123;<span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">               &#123;<span class="number">9</span>,  <span class="number">10</span>, <span class="number">11</span>,  <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>输出二维数组的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">4</span>; ++j)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%-5d  &quot;</span>, a[i][j]);<span class="comment">//-号表示左对齐，5表示占5个光标的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>是否存在多维数组?<br>不存在,因为内存是线性唯一的,ｎ维数组可以当做每一个元素是ｎ－１维数组的一维数组,比如：<code>int a[3][4];</code>,该数组是含有3个元素的一维数组,只不过每一个元素都是4行5列的二维数</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>为什么需要函数?</p>
<ul>
<li>避免了重复性操作</li>
<li>有利于程序的模块化</li>
</ul>
<p>什么叫做函数?</p>
<ul>
<li>逻辑上：能够完成特定功能的独立的代码单元</li>
<li>物理上：能够接受数据【当然也可以不接受数据】</li>
<li>能够对接收数据进行处理</li>
<li>能够将数据处理的结果返回【当然也可以不返回任何值 前面定义成void】<br>总结： 函数是个工具，它是为了解决大量类似问题而设计的,函数可以当做一个黑匣子</li>
</ul>
<p>如何定义函数?<br>格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数的返回值  函数的名字（函数的形参列表）</span><br><span class="line">&#123;</span><br><span class="line">   函数的执行体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hello lucas&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;guangzhou&quot;</span>;  <span class="comment">//第一：终止函数，第二：向主调函数返回字符类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回值的类型也称为函数的类型，因为如果函数名前的返回值的类型和函数执行体中的return表达式；中表达式的类型不同的话，则最终函数返回值的类型 以函数名前的返回值类型为准。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span>  <span class="comment">//只能返回整数类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10.5</span>; <span class="comment">//因为函数的返回值类型是int 所以最终f返回的是10而不是10.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h3><ul>
<li>有参函数 和 无参函数</li>
<li>有返回值函数 和 无返回值函数</li>
<li>库函数 和 用户自定义函数</li>
<li>值传递函数 和 地址传递函数</li>
<li>普通函数 和 主函数（main函数）</li>
</ul>
<blockquote>
<p>一个程序必须有且只能有一个主函数;主函数可以调用普通函数,普通函数不能调用主函数,普通函数可以相互调用;主函数是程序的入口，也是程序的出口</p>
</blockquote>
<h4 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h4><p><strong>函数调用和函数定义的顺序</strong></p>
<p><strong>如果函数调用写在了函数定义的前面，则必须加函数前置声明</strong></p>
<p>函数前置声明：</p>
<ol>
<li>告诉编译器即将可能出现的若干个字母代表的是一个函数</li>
<li>告诉编译器即将可能出现的若干个字母所代表的函数的形参和返回值的具体情况</li>
<li>函数声明是一个语句，末尾必须加分号</li>
<li>对库函数的声明是通过 #include &lt;库函数所在的文件的名字.h&gt;来实现</li>
</ol>
<p><strong>形参和实参:</strong> 个数相同  位置一一对应  数据类型必须相互兼容</p>
<blockquote>
<p>一个函数的功能尽量独立,单一;多学习， 多模仿牛人的代码;函数是C语言的基本单位，类是Java，C#，C++的基本单位</p>
</blockquote>
<h3 id="变量的作用域和存储方式"><a href="#变量的作用域和存储方式" class="headerlink" title="变量的作用域和存储方式"></a>变量的作用域和存储方式</h3><p>按作用域分：</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在所有函数外部定义的变量叫全局变量.<br>全局变量使用范围： 从定义位置开始到整个程序结束</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在一个函数内部定义的变量或者函数的形参都统称为局部变量,而且只能在本函数内部使用     </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">f</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  j = <span class="number">20</span>;  <span class="comment">//i和j都属于局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意的问题："><a href="#注意的问题：" class="headerlink" title="注意的问题："></a>注意的问题：</h4><p>全局变量和局部变量命名冲突的问题，在一个函数内部如果定义的局部变量的名字和全局变量名一样时，局部变量会屏蔽掉全局变量。</p>
<h3 id="按变量的存储方式"><a href="#按变量的存储方式" class="headerlink" title="按变量的存储方式"></a>按变量的存储方式</h3><ul>
<li>静态变量</li>
<li>自动变量</li>
<li>寄存器变量</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是c语言的灵魂</p>
<h3 id="指针的重要性"><a href="#指针的重要性" class="headerlink" title="指针的重要性"></a>指针的重要性</h3><ul>
<li>表示一些复杂的数据结构</li>
<li>快速传递数据，减少了内存的耗用【重点】</li>
<li>使函数返回一个以上的值【重点】</li>
<li>能直接访问硬件</li>
<li>能够方便的处理字符串</li>
<li>是理解面向对象语言中引用的基础</li>
</ul>
<h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><p>指针的定义<br>地址：是内存单元的编号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指针就是地址，地址就是指针</span><br><span class="line">指针就越是内存单元的编号</span><br><span class="line">指针变量是存放地址的变量</span><br><span class="line">指针和指针变量是两个不同的概念</span><br></pre></td></tr></table></figure>
<p>但是要注意：通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样,指针的本质就是一个操作受限的非负整数。</p>
<h3 id="指针的分类"><a href="#指针的分类" class="headerlink" title="指针的分类"></a>指针的分类</h3><h4 id="1-基本类型指针"><a href="#1-基本类型指针" class="headerlink" title="1.基本类型指针"></a>1.基本类型指针</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p;    <span class="comment">//p是变量的名字，int * 表示p变量存放的int类型变量的地址</span></span><br><span class="line"><span class="keyword">int</span> * p;    <span class="comment">//不表示定义了一个名字叫做*p的变量</span></span><br><span class="line"><span class="keyword">int</span> * p;    <span class="comment">//应该这样理解：p是变量名，p变量的数据类型是int *类型</span></span><br></pre></td></tr></table></figure>
<p>所谓<code>int *</code> 类型 实际就是存放int变量地址的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">p = &amp;i;</span><br><span class="line"></span><br><span class="line">j = *p; <span class="comment">//等价于 j = i;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d\n&quot;</span>,  i, j); <span class="comment">//3 3 </span></span><br></pre></td></tr></table></figure>
<ol>
<li>上面p保存了i的地址，因此p指向i</li>
<li>p不是i，i也不是p，更准确的说：修改p的值不影响i的值,修改i的值也不会影响p的值</li>
<li>如果一个指针变量指向了某个普通变量，则*指针变量就完全等同于普通变量</li>
</ol>
<p>例子：<br>        如果p是个指针变量。并且p存放了普通变量i的地址,则p指向了普通变量i，<em>p就完全等同于i；或者说：在所有出现</em>p的地方都可以替换成i,在所有出现i的地方都可以替换成*p。</p>
<p>*p 就是以p的内容为地址的变量</p>
<p><strong>经典指针程序_互换两个数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要互换p和q的值，则t必须是int *，不能是int，否则会出错</span></span><br><span class="line"><span class="comment">//如果要互换*p和*q的值，则t必须定义成int，不能定义成int *，否则语法会出错</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">huhuan</span><span class="params">(<span class="keyword">int</span> * p, <span class="keyword">int</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> t; </span><br><span class="line">   t = *p;  <span class="comment">//p是int *, *p是int</span></span><br><span class="line">	*p = *q;</span><br><span class="line">	*q = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	huhuan(&amp;a, &amp;b);   <span class="comment">//huhuan(*p,*q);是错误的,huhuan(a，b);也是错误的</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="的含义"><a href="#的含义" class="headerlink" title="*的含义"></a>*的含义</h4><ul>
<li>1.乘法</li>
<li>2.定义指针变量</li>
<li>3.int * p; //定义了一个名字叫p的变量，int  *表示只能存放int变量的地址指针运算符</li>
</ul>
<p>该运算符放在已经定义好的指针变量的前面,如果p是一个已经定义好的指针变量,则 *p表示 以p的内容为地址的变量。</p>
<p><strong>如何通过被调函数修改主调函数普通变量的值</strong></p>
<ul>
<li>1.实参必须为该普通变量的地址</li>
<li>2.形参必须为指针变量</li>
<li>3.在被调函数中通过*形参名 = ……的方式就可以修改主调函数相关变量的值</li>
</ul>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><h4 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h4><p>一维数组名是个指针常量它存放的是一维数组第一个元素的地址</p>
<p>下标和指针如果p是个指针变量，则p[i]永远等价于 *p(p+i)</p>
<p><strong>确定一个一维数组需要几个参数？</strong></p>
<blockquote>
<p>如果一个函数要处理一个一维数组，则需要接收该数组的哪些信息</p>
</blockquote>
<p>需要两个参数：</p>
<ul>
<li>数组第一个元素的地址 </li>
<li>数组的长度  </li>
</ul>
<blockquote>
<p>注:指针变量不能相加,不能相乘,也不能相除,如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量才可以相减。</p>
</blockquote>
<p><strong>一个指针变量到底占几个字节?【非重点】</strong><br><code>sizeof(数据类型)</code><br>功能：返回值就是该数据类型所占的字节数</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>) = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(变量名);</span><br></pre></td></tr></table></figure>
<p>功能：返回值是该变量所占的字节数    </p>
<ul>
<li>假设p指向char类型变量（1个字节）    </li>
<li>假设q指向int类型变量（4个字节）</li>
<li>假设r指向double类型变量（8个字节）   </li>
</ul>
<p><strong>p q r 本身所占的字节数是否一样？</strong><br><strong>答案：</strong> p q r 本身所占字节数是一样的</p>
<p><strong>总结：</strong> 一个指针变量，无论它指向的变量占几个字节,该指针变量本身只占四个字节,一个变量的地址是用该变量首字节的地址来表示</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="传统数组的缺点："><a href="#传统数组的缺点：" class="headerlink" title="传统数组的缺点："></a>传统数组的缺点：</h3><ul>
<li><p><strong>1.数组长度必须事现指定，且只能是常整数，不能是变量</strong><br>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a [<span class="number">5</span>]； <span class="comment">//OK</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">5</span>; <span class="keyword">int</span> a[len]; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>2.传统形式定义的数组，该数组的内存程序员无法手动释放</strong><br>数组一旦定义，系统就为该数组分配的存储空间就会一直存在，除非数组所在的函数运行结束;或者说：在一个函数运行期间，系统为该函数中数组所分配的空间会一直存在，直到该函数运行完毕时，数组的空间才会被系统释放。</p>
</li>
<li><p><strong>3.数组的长度不能在函数运行的过程中动态的扩充或缩小</strong><br>数组的长度一旦定义，其长度就不能再更改</p>
</li>
<li><p><strong>4.传统方式定义的数组不能跨函数使用</strong><br>A函数定义的数组，在A函数运行期间可以被其它函数使用，但A函数运行完毕之后，A函数中的数组将无法再被其他函数使用</p>
</li>
</ul>
<h3 id="为什么需要动态内存分配内存"><a href="#为什么需要动态内存分配内存" class="headerlink" title="为什么需要动态内存分配内存"></a>为什么需要动态内存分配内存</h3><p>动态数组很好的解决了传统数组的这4个缺陷,传统数组也叫静态数组。</p>
<h3 id="静态内存和动态内存的比较"><a href="#静态内存和动态内存的比较" class="headerlink" title="静态内存和动态内存的比较"></a>静态内存和动态内存的比较</h3><ul>
<li>静态内存是有系统自动分配，由系统自动释放     </li>
<li>静态内存是在栈中分配的     </li>
<li>动态内存是由程序员手动分配，手动释放</li>
<li>动态内存是在堆中分配的</li>
<li>跨函数使用内存的问题</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc(), calloc(), realloc() ,这三个函数都是向堆中申请的内存空间.这里只讲malloc()</p>
<ul>
<li>1).malloc()函数会向堆中申请一片连续的可用内存空间</li>
<li>2).若申请成功 ,,返回指向这片内存空间的指针 ,若失败 ,则会返回NULL, 所以我们在用malloc()函数开辟动态内存- 之后, 一定要判断函数返回值是否为NULL.</li>
<li>3).返回值的类型为void * 型, malloc()函数并不知道连续开辟的size个字节是存储什么类型数据的 ,所以需要我们自行决定 ,方法是在malloc()前加强制转 ,转化成我们所需类型 ,如: (int*)malloc(sizeof(int)*n).</li>
<li>4).如果size为0, 此行为是未定义的, 会发生未知错误, 取决于编译器<br>例子：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);  <span class="comment">//由用户输入获得内存分配</span></span><br><span class="line">p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//....需要进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
相当于创建了一个数组 p[n] ,这个n的值并不需要像定义一个普通数组一样必须是常量, 可以使程序运行时得出的, 或是用户输入的</li>
</ul>
<blockquote>
<p>内存操作函数还有calloc()、realloc()、free()，这里就不做过多阐述了,自行搜索<a href="https://blog.csdn.net/qq_41071068/article/details/90741413">C语言动态内存分配函数</a></p>
</blockquote>
<ul>
<li><p>1).malloc()和calloc()函数用法一样, 唯一的区别是calloc()会对所申请内存的每个字节初始化为0</p>
</li>
<li><p>2).malloc(), calloc(), realloc()申请的内存不再使用时 ,一定要用free()释放 ,否则会造成内存泄漏</p>
</li>
<li><p>3).p = realloc(ptr, size)函数返回值不为空时, 释放内存时不需写free(ptr) ,只需写free(p) </p>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><strong>为什么需要结构体?</strong><br>为了表示一些复杂的事物，而普通的基本类型无法满足实际要求。<br><strong>什么叫结构体?</strong><br>把一些基本类型数据组合在一起形成的一个新的复合数据类型，这个叫做结构体。<br><strong>如何定义结构体</strong>      </p>
<p>3种方式，推荐使用第一种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">float</span> score;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">float</span> score;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; st2；</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">float</span> score;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125; st3;</span><br></pre></td></tr></table></figure>
<p><strong>怎么使用结构体变量</strong>  </p>
<ol>
<li>赋值和初始化</li>
<li>定义的同时可以整体赋初值</li>
<li>如果定义完之后，则只能单个的赋初值</li>
</ol>
<p><strong>如何取出结构体变量中的每一个成员【重点】</strong>    </p>
<p>1.结构体变量名.成员名<br>2.指针变量名—&gt;成员名 （第二种方式更常用）</p>
<blockquote>
<p>指针变量名—&gt;成员名  在计算机内部会被转化成 （*指针变量名）.成员名的方式来执行<br>所以说这两种方式是等价的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">float</span> score;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">80</span>, <span class="number">66.6</span>, <span class="string">&#x27;F&#x27;</span>&#125;;<span class="comment">//初始化  定义的同时赋初值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span> =</span> &amp;st; <span class="comment">//&amp;st不能改成st</span></span><br><span class="line"></span><br><span class="line">	pst-&gt;age = <span class="number">88</span>;<span class="comment">//第二种方式</span></span><br><span class="line">	st.age = <span class="number">10</span>; <span class="comment">//第一种方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>pst—&gt;在计算机内部会被转换成 （*pst）.age, 没有什么为什么，这就是—&gt;的含义，这也是一种硬性规定</li>
<li>所以 pst—&gt;age等价于（*pst）.age也等价于st.age</li>
<li>我们之所以知道pst—&gt;age等价于st.age,是因为pst—&gt;age是被转化成了（*pst）.age来执行</li>
<li>pst—&gt;age 的含义：pst所指向的那个结构体变量中的age这个成员</li>
</ol>
<p><strong>结构体变量和结构体变量指针作为函数参数传递的问题</strong><br>推荐使用结构体指针变量作为函数参数来传递</p>
<blockquote>
<p>结构体变量不能相加，不能相减，也不能互相乘除,但结构体变量可以相互赋值</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">&#125;;<span class="comment">//分号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>, <span class="title">st2</span>;</span></span><br><span class="line">st1+st2  st1*st2  st1/st2 都是错误的</span><br><span class="line">st1 = st2  或者 st2 = st1 都是正确的</span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>什么是枚举？</strong><br>把一个事物所有可能的取值一一列举出来</p>
<p><strong>枚举的优缺点</strong></p>
<ul>
<li>代码更安全</li>
<li>书写麻烦</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*红色、黄色、绿色、蓝色,黑色*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span>red,yellor,green,blue,black&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> user_color;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n请输入颜色&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;user_color);</span><br><span class="line">        <span class="keyword">switch</span>(user_color)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> red: <span class="built_in">printf</span>(<span class="string">&quot;\n你输入的是红色\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> yellor: <span class="built_in">printf</span>(<span class="string">&quot;\n你输入的是黄色\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> green: <span class="built_in">printf</span>(<span class="string">&quot;\n你输入的是绿色\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> blue: <span class="built_in">printf</span>(<span class="string">&quot;\n你输入的是蓝色\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> black: <span class="built_in">printf</span>(<span class="string">&quot;\n你输入的是黑色\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="专题："><a href="#专题：" class="headerlink" title="专题："></a>专题：</h2><p>一、有符号数的编码规则</p>
<ul>
<li><p>原码：最高位为符号位，其余各位为数值本身的绝对值。</p>
</li>
<li><p>反码：正数的反码与原码相同；负数的反码，符号位为1，其余位对原码取反。</p>
</li>
<li><p>补码：正数的补码与原码相同；负数的补码，符号位为1，其余位对原码取反加1</p>
</li>
</ul>
<p>比如1字节数据(8位)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>的原码为 <span class="number">00000001</span>    (<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>的反码为 <span class="number">00000001</span>    (<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>的补码为 <span class="number">00000001</span>     (<span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>的原码为 <span class="number">10000001</span>    (<span class="number">0x81</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>的反码为 <span class="number">11111110</span>    (<span class="number">0xFE</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>的补码为 <span class="number">11111111</span>    (<span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>的原码为 <span class="number">00000111</span>    (<span class="number">0x07</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>的反码为 <span class="number">00000111</span>    (<span class="number">0x07</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>的补码为 <span class="number">00000111</span>    (<span class="number">0x07</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-7</span>的原码为 <span class="number">10000111</span>  (<span class="number">0x87</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-7</span>的反码为 <span class="number">11111000</span>   (<span class="number">0xF8</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">-7</span>的补码为 <span class="number">11111001</span>   (<span class="number">0xF9</span>)</span><br></pre></td></tr></table></figure>

<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>也叫 符号-绝对值码<br>最高位0表示正 1表示负，其余二进制位是该数字的绝对值的二进制位</p>
<p><strong>特性</strong><br>原码简单易懂<br>加减运算复杂<br>存在加减乘除四种运算，增加了cpu的复杂度<br>零的表示不唯一    </p>
<p>求原码：X≥0，则符号位为0，其余照抄；X≤0，则符号位为1，其余照抄</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">【例<span class="number">1</span>】X=+<span class="number">1001001</span> [X]原 = <span class="number">01001001</span></span><br><span class="line">【例<span class="number">2</span>】X=<span class="number">-1001001</span> [X]原 = <span class="number">11001001</span></span><br></pre></td></tr></table></figure>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码运算不便，也没有在计算机中应用</p>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>原码取反加一</p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="已知十进制求二进制"><a href="#已知十进制求二进制" class="headerlink" title="已知十进制求二进制"></a>已知十进制求二进制</h3><h4 id="正整数转二进制"><a href="#正整数转二进制" class="headerlink" title="正整数转二进制"></a>正整数转二进制</h4><p>除2取余，直至商为零，余数倒序排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,x=<span class="number">0</span>,a[<span class="number">100</span>];</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;请输入转换的数:\n&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">while</span>(n)</span><br><span class="line">   &#123;</span><br><span class="line">      a[x++]=n%<span class="number">2</span>;</span><br><span class="line">      n/=<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   --x;</span><br><span class="line">   <span class="keyword">while</span>(x&gt;=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[x--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负整数转二进制"><a href="#负整数转二进制" class="headerlink" title="负整数转二进制"></a>负整数转二进制</h4><p>先求与该负数线对应的正整数的补码，然后将所有位取反，末尾加1，不够位数时，左边补1</p>
<p>假设有一个 int 类型的数，值为5，那么，我们知道它在计算机中表示为：</p>
<p><code>00000000 00000000 00000000 00000101</code>     </p>
<p>5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。</p>
<p>现在想知道，-5在计算机中如何表示？<br><strong>答：</strong> 在计算机中，负数以原码的补码形式表达。</p>
<h4 id="零转二进制"><a href="#零转二进制" class="headerlink" title="零转二进制"></a>零转二进制</h4><p>全是零</p>
<h3 id="二进制转XX"><a href="#二进制转XX" class="headerlink" title="二进制转XX"></a>二进制转XX</h3><h4 id="二进制求十进制"><a href="#二进制求十进制" class="headerlink" title="二进制求十进制"></a>二进制求十进制</h4><p>如果首位是0，则表明是正整数，按普通方法来求</p>
<p>如果首位是1，则表明是负整数,将所有位取反，末尾加1，所得数字就是该负数的绝对值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">int</span> bin;<span class="comment">//定义一个长整型变量</span></span><br><span class="line">   <span class="keyword">int</span> lln=<span class="number">1</span>,dec=<span class="number">0</span> ;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;bin);</span><br><span class="line">   <span class="keyword">while</span> (bin)</span><br><span class="line">   &#123;</span><br><span class="line">      dec+=bin%<span class="number">10</span>*lln;</span><br><span class="line">      lln*=<span class="number">2</span>;</span><br><span class="line">      bin/=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dec);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二进制转换十六进制"><a href="#二进制转换十六进制" class="headerlink" title="二进制转换十六进制"></a>二进制转换十六进制</h4><p>C语言中，二进制的4位数据表示1位的十六进制数字 如：10010101 ——&gt; 1001 0101——&gt;0x95</p>
<h3 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> a;<span class="comment">//需要转换的数字</span></span><br><span class="line"> 	<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;a);</span><br><span class="line">   <span class="keyword">int</span> yiwei=<span class="number">0xF</span>;<span class="comment">//用以移位的数字</span></span><br><span class="line">   <span class="keyword">int</span> numbers=<span class="number">0</span>;<span class="comment">//记录移位多次</span></span><br><span class="line">   <span class="keyword">int</span> tmp=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> buffer[<span class="number">11</span>]=&#123;<span class="string">&#x27;0&#x27;</span>&#125;;<span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">   buffer[<span class="number">1</span>]=<span class="string">&#x27;x&#x27;</span>;<span class="comment">//buffer[2]=&#x27;0&#x27;;</span></span><br><span class="line">   buffer[<span class="number">10</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//给最后一个补充\0</span></span><br><span class="line">   <span class="keyword">do</span><span class="comment">//移位到最后高位都是1，因此最后会是一个负数</span></span><br><span class="line">   &#123;</span><br><span class="line">         tmp=a&amp;yiwei; <span class="comment">//取出四位当做十六进制的一位</span></span><br><span class="line">      </span><br><span class="line">         tmp&gt;&gt;=numbers*<span class="number">4</span>;<span class="comment">//要还原取出来的这个数字，如果不是在低位取得就需要这样操作</span></span><br><span class="line">      </span><br><span class="line">         <span class="keyword">if</span>(tmp&gt;=<span class="number">10</span>&amp;&amp;tmp&lt;<span class="number">16</span>)</span><br><span class="line">            buffer[<span class="number">10</span><span class="number">-1</span>-index]=tmp<span class="number">-10</span>+<span class="string">&#x27;a&#x27;</span>;<span class="comment">//因为从最低位取的，因此赋值从数组最后面开始赋</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;<span class="number">10</span>&amp;&amp;tmp&gt;=<span class="number">0</span>)</span><br><span class="line">            buffer[<span class="number">10</span><span class="number">-1</span>-index]=<span class="string">&#x27;0&#x27;</span>+tmp;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(yiwei&lt;&lt;<span class="number">4</span>&lt;<span class="number">0</span>)<span class="comment">//这里判断是不是已经到了最高位了，如果是最高位，最高的前三位是数字，最后一位是符号</span></span><br><span class="line">            yiwei=yiwei&lt;&lt;<span class="number">3</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         yiwei&lt;&lt;=<span class="number">4</span>;<span class="comment">//把这个数字向后移四位，用以取下一个四位</span></span><br><span class="line">         </span><br><span class="line">         index++;</span><br><span class="line">         numbers++;</span><br><span class="line">   &#125;<span class="keyword">while</span>(yiwei&gt;<span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十六进制转字符串"><a href="#十六进制转字符串" class="headerlink" title="十六进制转字符串"></a>十六进制转字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hex2Byte</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* source, <span class="keyword">unsigned</span> <span class="keyword">char</span>* dest, <span class="keyword">int</span> sourceLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> highByte, lowByte;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sourceLen; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        highByte = <span class="built_in">toupper</span>(source[i]);</span><br><span class="line">        lowByte  = <span class="built_in">toupper</span>(source[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (highByte &gt; <span class="number">0x39</span>)  </span><br><span class="line">            highByte -= <span class="number">0x37</span>; <span class="comment">//&#x27;A&#x27;-&gt;10 &#x27;F&#x27;-&gt;15</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            highByte -= <span class="number">0x30</span>; <span class="comment">//&#x27;1&#x27;-&gt;1 &#x27;9&#x27;-&gt;9</span></span><br><span class="line">        <span class="keyword">if</span> (lowByte &gt; <span class="number">0x39</span>)</span><br><span class="line">            lowByte -= <span class="number">0x37</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lowByte -= <span class="number">0x30</span>;</span><br><span class="line">        dest[i / <span class="number">2</span>] = (highByte &lt;&lt; <span class="number">4</span>) | lowByte;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> src[<span class="number">20</span>]=<span class="string">&quot;466c6f776572\0&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Hex2Byte(src,buf,<span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">strlen</span>(buf)); <span class="comment">//打印一下生成十六进制字符串的长度</span></span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:6 Flower</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="算法概论"><a href="#算法概论" class="headerlink" title="算法概论"></a>算法概论</h2><h3 id="通俗定义"><a href="#通俗定义" class="headerlink" title="通俗定义"></a>通俗定义</h3><p>解题的方法和步骤    </p>
<h3 id="狭义定义"><a href="#狭义定义" class="headerlink" title="狭义定义"></a>狭义定义</h3><p>对存储数据的操作    </p>
<p>对不同的存储结果，要完成某一个功能所执行的操作是不一样的。</p>
<p>比如：要输出数组中所有的元素的操作和要输出链表中所有元素的操作肯定是不一样的</p>
<p>这说明：算法是依附于存储结构的不同的存储结构，所执行的算法是不一样的</p>
<h3 id="广义定义"><a href="#广义定义" class="headerlink" title="广义定义"></a>广义定义</h3><p>广义的算法也叫泛型,无论数据是如何存储的，对数据的操作都是一样的</p>
<h3 id="我们至少可以通过两种结构来存储数据"><a href="#我们至少可以通过两种结构来存储数据" class="headerlink" title="我们至少可以通过两种结构来存储数据"></a>我们至少可以通过两种结构来存储数据</h3><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p><code>优点</code>：存取速度快<br><code>缺点</code>：需要一个连续的很大是内存,插入和删除元素的效率很低    </p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p><code>优点</code>：插入删除元素效率高,不需要一个连续的很大的内存<br><code>缺点</code>：查找某个位置的元素效率低</p>
<p>专业术语：<br><strong>1.头结点</strong><br>头结点的数据类型和首结点的类型一模一样头结点是首结点前面的那个结点,头结点并不存放有效数据,设置头结点的目的是为了方便对链表的操作。</p>
<p><strong>2.头指针</strong><br>存放头结点地址的指针变量   </p>
<p><strong>3.首节点</strong><br>存放第一个有效数据的结点   </p>
<p><strong>4.尾节点</strong><br>存放最后一个有效数据的结点</p>
<blockquote>
<p>确定一个链表需要一个参数头指针</p>
</blockquote>
]]></content>
      <categories>
        <category>基础学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript问题</title>
    <url>/2018/07/09/mian-shi-bao-dian/02.javascript-wen-ti/</url>
    <content><![CDATA[<p>这里列一些我在面试时最常问到的，都是老生常谈的问题:</p>
<pre><code>什么是闭包？
什么是面向对象？
JS如何实现类，对象之间的继承？
什么是冒泡和捕获以及事件委托？
JS有哪些数据类型？
Null和Undefined的区别？
判断时if是false的值？
isNaN（）的作用？
JS对象中的Array对象和String对象的各种方法　
this关键字在不同环境下的指向　　　
JS的作用域
setTimeout和setInterval
了解CSS3或HTML5吗，都用过哪些</code></pre>
<p>精通原生 JS 闭包，异步编程，原型继承，类型数组，事件代理，原生 ajax。</p>
<p>都用过哪些计算机基础：<br>主要是计算机网络、算法、数据结构方面的知识，这一块儿是我最薄弱的，而运气好的是面试官问的也较少，更多的是询问排序查找相关的一些，经验不足就不多说。</p>
<p>技能延伸：前面两者技术的基础上对技能的延伸能增加获得 offer 的机会，比如了解模板引擎、熟悉比较火的前端框架或前端技术（JQuery、Bootstrap、Zepto、Node，Angular.JS），并且研究过源码、对 svn 或 git 等版本控制软件的操作、 长期更新博客、 在 github 上有所贡献等，这些都是绝对的加分点，这些并不是说都要做，如果能选中其中一两项有所成果应该是能加分的。　　<br>因为面试已经隔得太久，最近也比较懒，能想起的大概就这么多，有想到的再上来更新吧。</p>
<h2 id="请问JS中的基本数据类型有几种？"><a href="#请问JS中的基本数据类型有几种？" class="headerlink" title="请问JS中的基本数据类型有几种？"></a>请问JS中的基本数据类型有几种？</h2><p>七种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean</span><br><span class="line">Null</span><br><span class="line">Undefined</span><br><span class="line">Number</span><br><span class="line">String</span><br><span class="line">Symbol	(es6新增)</span><br><span class="line">BigInt	(es10新增)</span><br></pre></td></tr></table></figure>



<h2 id="结果是什么？"><a href="#结果是什么？" class="headerlink" title="[] == ![] 结果是什么？"></a>[] == ![] 结果是什么？</h2><p>类型转换都是先 <code>valueOf</code> 再 <code>toString</code>;</p>
<p>右边</p>
<ol>
<li>由于 <code>!</code> 优先级比 <code>==</code> 高，先执行 <code>!</code></li>
<li><code>![]</code> 得到 false</li>
<li>进行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">相等性判断</a></li>
<li><code>false</code> 转化为数字 <code>0</code></li>
</ol>
<p>左边</p>
<ol>
<li> 执行 <code>[].valueOf()</code> 原始值 还是 []</li>
<li>执行 [].toString() 得到 ‘’  #[].toString() == 0 //true</li>
<li><code>&#39;&#39;</code> 转化为数字 <code>0</code></li>
</ol>
<p>所以：<code>0 == 0</code> ，答案是 <code>true</code></p>
<p>验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1 == !arr2) <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line">arr1.toString = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1 == !arr2) </span><br><span class="line"><span class="comment">// -&gt; 111</span></span><br><span class="line"><span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<h2 id="‘1’-‘2’-‘3’-map-parseInt"><a href="#‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt)"></a>[‘1’, ‘2’, ‘3’].map(parseInt)</h2><p>map语法: <code>Array.prototype.map(callback[, thisArg])</code></p>
<p>callback包括三个值：value(遍历值),  index(下标),  arr(数组本身)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">// [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实在使用map时，map的callback的第二个参数index引索值就成为parseeInt的radix值。[‘1’, ‘2’, ‘3’].map(parseInt)在遍历的过程。其实是经历了下面的过程。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>);	<span class="comment">//数组下标的值就是parseInt的第二参数</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>parseInt(‘1’, 0)：radix的值为0，判断字符串发现介于1~9，用10进制转换，结果为1.</p>
</li>
<li><p>parseInt(‘2’, 1)：radix的值为1，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>
</li>
<li><p>parseInt(‘3’, 2): radix的值为2，这就意味着字符串将被解析成字节数，也就是仅仅包含数值0和1。parseInt的规范指出，它仅尝试分析第一个字符的左侧。这个字符串的第一个字符是“3”，它并不是基础基数2的一个有效数字。所以这个子字符串将被解析为空。如果子字符串被解析成空了，函数将返回为NaN。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;10&#x27;</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">// [1, NaN, 1, 3, 4]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="string">&#x27;13&#x27;</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">// [1, NaN, 1, 1, 7]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>‘1 2 4 6 5 3’.replace(/\d/g, parseInt)     // “1 NaN NaN NaN 5 3”</p>
</blockquote>
<h2 id="如何让-a-1-amp-amp-a-2-条件成立？"><a href="#如何让-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="如何让 (a == 1 &amp;&amp; a ]== 2)条件成立？"></a>如何让 (a == 1 &amp;&amp; a ]== 2)条件成立？</h2><p>依然是类型转换逻辑：基础类型通过 <code>valueOf</code> 进行隐式转换</p>
<p>更改 <code>valueOf</code> 方法就可以实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">let</span> a = &#123;</span><br><span class="line">       value: <span class="number">0</span>,</span><br><span class="line">       valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.value++;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>); <span class="comment">//true #每次执行==就运行一次valueOf方法</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">3</span> &amp;&amp; a == <span class="number">4</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>什么是回调地狱(函数作为参数层层嵌套)</p>
<p>什么是回调函数(一个函数作为参数需要依赖另一个函数执行调用)</p>
<p>简单地说: 一个回调函数，就是在另外一个函数（通常是异步的）执行完之后再执行的函数，因而被命名为——回调。</p>
<p>更进一步地说: 在 JavaScript 中，函数是对象。正因如此，一个函数可以被其他函数作为参数（传入），也能被其他函数作为返回值返回。这种函数（译者注：起码要满足如下条件之一：1.接受一个或多个函数作为参数，2.将一个函数作为返回值返回）被称为高阶函数。任何函数，只要它作为参数传入且随后被调用，都可称之为回调函数。</p>
<p>如何解决回调地狱？</p>
<p>保持你的代码简短(给函数取有意义的名字,见名知意,而非匿名函数,写成一大坨)</p>
<p>模块化(函数封装,打包，每个功能独立,可以单独的定义一个 js 文件 Vue,react 中通过 import 导入就是一种体现)</p>
<p>处理每一个错误</p>
<p>创建模块时的一些经验法则</p>
<p>承诺/生成器/ES6 等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">T.get(<span class="string">&quot;search/tweets&quot;</span>, params, <span class="function"><span class="keyword">function</span>(<span class="params">err, data, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//最后一个则是一个匿名的回调函数。</span></span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    <span class="comment">// This is where the magic will happen</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里，回调函数是十分重要的，因为我们需要等待服务器返回数据后，才能继续执行余下代码。我们并不知道我们请求 API 后，服务器是否成功地返回数据。因此，当我们通过 GET 请求请求 search/tweets 后，会等待服务器返回信息。一旦推特（的服务器）返回相应数据，我们的回调函数将会执行。</p>
<h2 id="强耦合和弱耦合"><a href="#强耦合和弱耦合" class="headerlink" title="强耦合和弱耦合"></a>强耦合和弱耦合</h2><p>耦合分析通常分两种方法：强耦合（或称紧耦合）和弱耦合（或称松耦合）</p>
<p>软件设计中的“耦合”指，两个功能函数之间的依赖程度。</p>
<p>比如，你设计的一个程序，需要你编写 10 个功能函数来实现。如果这 10 个功能中，有 9 个功能都要调取第 10 个功能函数 X10，那么，当你在修改 X10 时，你就要考虑修改完成后，是否会对其它 9 个功能函数有影响，为了查看是否有不好影响，你就要对其它 9 个功能函数，一个一个进行测试。所以，为了避免产生这种后期修改的劳动量。就提倡【松耦合】，就是，功能函数之间，尽量依赖程度不要太高。否则，修改完一个底层函数后，会对多个上层函数，进行大量的测试。<br>【松耦合】的方法，一般是底层函数，功能尽量单一，尽量避免修改底层函数。功能相近的函数，可以设计 2 个以上，不要为了减少代码量，把一个函数的功能设计的太多。</p>
<h2 id="说说你对闭包的理解"><a href="#说说你对闭包的理解" class="headerlink" title="说说你对闭包的理解"></a>说说你对闭包的理解</h2><p>闭包是 Javascript 语言特有的”链式作用域”结构（chain scope）变量的作用域有三种：全局作用域和局部作用域以及块作用域(ES6)。，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>闭包：JavaScript 高级程序设计里写闭包是有权访问另一个函数作用域中的变量的函数，使作用域得到了延长。我们有时候在函数外部需要得到函数内的局部变量。而闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p><strong>闭包的优点：</strong></p>
<ul>
<li>是闭包封住了变量作用域，有效地防止了全局污染</li>
<li>可以读取其他函数内部的变量,让这些变量的值始终保持在内存中,不会随着函数的结束而自动销毁。</li>
<li>可以很巧妙地实现静态私有变量、私有函数方法等</li>
<li>匿名自执行函数可以减少内存消耗</li>
</ul>
<p><strong>闭包的缺点：</strong> 由于闭包会使得函数中的变量都被保存在内存中,所以存在内存泄漏的风险</p>
<ul>
<li>被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为 null；</li>
</ul>
<p>其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>在浏览器端可以通过强制刷新解决，对用户体验影响不大</li>
<li>在服务端，由于 node 的内存限制和累积效应，可能会造成进程退出甚至服务器沓机</li>
</ul>
<p><strong>使用场景</strong> :函数内部变量只初始化一次</p>
<p>解决方法是显式对外暴露一个接口，专门用以清理变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.清除失败,因为每次先执行mockData()后才会执行闭包,所以每次都会在局部作用域创建常量mem*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有常量</span></span><br><span class="line">  <span class="keyword">const</span> mem = &#123; <span class="attr">name</span>: <span class="string">&quot;lucas&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    clear: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//把有权访问私有变量的公有方法称为特权方法</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mem[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="comment">// 显式暴露清理接口</span></span><br><span class="line">    get: <span class="function"><span class="params">page</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (page <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[page];</span><br><span class="line">      &#125;</span><br><span class="line">      mem[page] = <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(mockData().get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//lucas</span></span><br><span class="line">mockData().clear(); <span class="comment">//清理变量</span></span><br><span class="line"><span class="built_in">console</span>.log(mockData().get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//lucas</span></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    lucas</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    lucas</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.成功清除但代码不复用*/</span></span><br><span class="line"><span class="keyword">const</span> mem = &#123; <span class="attr">name</span>: <span class="string">&quot;lucas&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;; <span class="comment">//卸载外面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这里执行多次&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    clear: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mem[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="comment">// 显式暴露清理接口</span></span><br><span class="line">    get: <span class="function"><span class="params">page</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (page <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[page];</span><br><span class="line">      &#125;</span><br><span class="line">      mem[page] = <span class="string">&quot;dwdwd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mockData().get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//lucas</span></span><br><span class="line">mockData().clear(); <span class="comment">//清理变量</span></span><br><span class="line"><span class="built_in">console</span>.log(mockData().get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    lucas</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    这里执行多次</span></span><br><span class="line"><span class="comment">    undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.最好写法*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mem = &#123; <span class="attr">name</span>: <span class="string">&quot;lucas&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;执行一次&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    clear: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mem[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="comment">// 显式暴露清理接口</span></span><br><span class="line">    get: <span class="function"><span class="params">page</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (page <span class="keyword">in</span> mem) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[page];</span><br><span class="line">      &#125;</span><br><span class="line">      mem[page] = <span class="string">&quot;dwdwd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = mockData(); <span class="comment">//也可以mockData()()执行闭包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result.get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//lucas</span></span><br><span class="line">result.clear(); <span class="comment">//清理变量</span></span><br><span class="line"><span class="built_in">console</span>.log(result.get(<span class="string">&quot;name&quot;</span>)); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行一次</span></span><br><span class="line"><span class="comment">    lucas</span></span><br><span class="line"><span class="comment">    undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>例如”变量只初始化一次”这样的需求可以使用下面的例子</p>
<p><strong>销毁闭包产生的变量，实现递增例子 1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过匿名函数可以实现闭包,简称匿名闭包函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params">varr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = varr || <span class="number">0</span>; <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//这样写称为闭包特权方法</span></span><br><span class="line">      <span class="keyword">return</span> ++n;</span><br><span class="line">    &#125;,</span><br><span class="line">    clearVariable: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      n = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="number">20</span>); <span class="comment">//由于匿名立即执行函数只会执行一次,所以这里实参数只能传一次(若需要传多次请参考例子2)</span></span><br><span class="line">foo.add(); <span class="comment">//21</span></span><br><span class="line">foo.add(); <span class="comment">//22</span></span><br><span class="line">foo.add(); <span class="comment">//23</span></span><br><span class="line">foo.clearVariable(); <span class="comment">//n变量被销毁</span></span><br><span class="line">foo.add(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>销毁闭包产生的变量，实现递增例子 2</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写法1*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = initial || <span class="number">0</span>; <span class="comment">//变量只会初始化一次</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    inc: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x++;</span><br><span class="line">    &#125;,</span><br><span class="line">    clear: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      x = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2.inc(); <span class="comment">// 11</span></span><br><span class="line">c2.inc(); <span class="comment">// 12</span></span><br><span class="line">c2.inc(); <span class="comment">// 13</span></span><br><span class="line">c2.clear(); <span class="comment">//x变量被销毁</span></span><br><span class="line">c2.inc(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2:这样写不方便销毁变量*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = initial || <span class="number">0</span>; <span class="comment">//变量只会初始化一次</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add; <span class="comment">//也可以返回执行函数后的内容add()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</span><br><span class="line">c2(); <span class="comment">//11</span></span><br><span class="line">c2(); <span class="comment">//12</span></span><br><span class="line">c2(); <span class="comment">//13</span></span><br><span class="line">c2() = <span class="literal">null</span>; <span class="comment">//清除函数也清除了变量</span></span><br><span class="line">c2(); <span class="comment">//报错不存在函数</span></span><br><span class="line"><span class="keyword">var</span> c2 = create_counter(<span class="number">20</span>);</span><br><span class="line">c2(); <span class="comment">//21</span></span><br><span class="line">c2 = <span class="literal">null</span>; <span class="comment">//释放对闭包的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；</span></span><br><span class="line"><span class="comment">//如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</span></span><br></pre></td></tr></table></figure>

<p><strong>销毁闭包产生的变量，实现递增例子 3</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.n++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.n; <span class="comment">//闭包产生的变量需手动清除</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.clear = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.n = <span class="literal">null</span>); <span class="comment">//销毁函数内部的变量,避免内存泄漏</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Class();</span><br><span class="line">obj.func(); <span class="comment">//1</span></span><br><span class="line">obj.func(); <span class="comment">//2</span></span><br><span class="line">obj.func(); <span class="comment">//3</span></span><br><span class="line">obj.clear(); <span class="comment">//n变量被销毁</span></span><br><span class="line">obj.func(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>后者的可扩展性更好. 当需要实现对一个变量的不同操作时, 后一种可以只需要再定义一个不同的函数(也就是简单线性扩展), 而前一种(闭包)则需要完全重写。</p>
<p>如果仅仅是做一个简单的计数器，大可不用这样麻烦。下面这简短的代码就能轻松实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匿名闭包函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面的 function 都可以称之为闭包（匿名闭包函数）。</p>
<p>闭包其实还有很多实用场景,比如,我们想在页面上添加一些可以调整字号的按钮</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSizer</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style.fontSize = size + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = makeSizer(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> size14 = makeSizer(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> size16 = makeSizer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实现私有属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例子1*/</span></span><br><span class="line"><span class="keyword">var</span> db = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个隐藏的object, 这个object持有一些数据</span></span><br><span class="line">  <span class="comment">// 从外部是不能访问这个object的</span></span><br><span class="line">  <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 创建一个函数, 这个函数提供一些访问data的数据的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125; <span class="comment">// get</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (data[key] = val);</span><br><span class="line">    &#125; <span class="comment">// set</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 我们可以调用这个匿名方法</span></span><br><span class="line">  <span class="comment">// 返回这个内部函数，它是一个闭包</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">db(<span class="string">&quot;x&quot;</span>); <span class="comment">// 返回 undefined</span></span><br><span class="line">db(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>); <span class="comment">// 设置data[&#x27;x&#x27;]为1</span></span><br><span class="line">db(<span class="string">&quot;x&quot;</span>); <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// 我们不可能访问data这个object本身</span></span><br><span class="line"><span class="comment">// 但是我们可以设置它的成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例子2*/</span></span><br><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> secret = <span class="string">&quot;11111111&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    getSecret: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> secret;</span><br><span class="line">    &#125;,</span><br><span class="line">    setSecret: <span class="function"><span class="keyword">function</span>(<span class="params">new_secret</span>) </span>&#123;</span><br><span class="line">      secret = new_secret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">alert(foo.secret); <span class="comment">//undefined不可访问</span></span><br><span class="line">alert(foo.getSecret()); <span class="comment">//11111111</span></span><br><span class="line">foo.setSecret(<span class="string">&quot;22222222&quot;</span>); <span class="comment">//set</span></span><br><span class="line">alert(foo.getSecret()); <span class="comment">//22222222</span></span><br></pre></td></tr></table></figure>

<p><strong>实现私有方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例子1*/</span></span><br><span class="line"><span class="keyword">var</span> book = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> page = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.auther = <span class="string">&quot;dava&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.price = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">this</span>._page = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(page); <span class="comment">//想访问page属性，那就得依靠闭包了</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> book();</span><br><span class="line">a.auther; <span class="comment">//&quot;dava&quot;</span></span><br><span class="line">a.price; <span class="comment">//200</span></span><br><span class="line">a.page; <span class="comment">//undefined,page变量不指向实例</span></span><br><span class="line">a._page(); <span class="comment">//100  //私有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然也可以使用上面递增例子1~3方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*例子2*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是一个公有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I&#x27;m public a function !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//只需利用 javascript闭包的特性</span></span><br><span class="line">  <span class="comment">//b 是一个私有方法，我们用下划线代表b是一个私有方法</span></span><br><span class="line">  <span class="built_in">this</span>._b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;I&#x27;m private b function !&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//在生命这个类对象的时候调用一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样，我们就实现了一个只会被调用一次的私有方法</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo._b();</span><br></pre></td></tr></table></figure>

<p><strong>使用对象实现私有属性和私有方法</strong><br>在 createNew()方法中，只要不是定义在 cat 对象上的方法和属性，都是私有的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">  createNew: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cat = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sound = <span class="string">&quot;喵喵喵&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cat.makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(sound);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上例的内部变量sound，外部无法读取，只有通过cat的公有方法makeSound()来读取。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = Cat.createNew();</span><br><span class="line"></span><br><span class="line">alert(cat1.sound); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">alert(cat1.makeSound()); <span class="comment">//喵喵喵   //只能这样读取私有属性</span></span><br></pre></td></tr></table></figure>

<p><strong>闭包的另一个用处，是封装对象的私有属性和私有方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p><strong>实际开发中闭包的应用</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//闭包实际应用中主要用于封装变量，收敛权限</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFirstLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">list.indexOf(id) &gt;= <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.push(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstLoad = isFirstLoad();</span><br><span class="line">firstLoad(<span class="number">10</span>);  <span class="comment">//true;</span></span><br><span class="line">firstLoad(<span class="number">20</span>);  <span class="comment">//true;</span></span><br><span class="line">firstLoad(<span class="number">10</span>);  <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>



<p><strong>来一道有关闭包的面试题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>); <span class="comment">// undefined</span></span><br><span class="line">a.fun(<span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line">a.fun(<span class="number">2</span>); <span class="comment">// 0</span></span><br><span class="line">a.fun(<span class="number">3</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>)</span><br><span class="line">  .fun(<span class="number">1</span>)</span><br><span class="line">  .fun(<span class="number">2</span>)</span><br><span class="line">  .fun(<span class="number">3</span>); <span class="comment">// undefined \n 0 \n 1 \n 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>); <span class="comment">//undefined \n 0</span></span><br><span class="line">c.fun(<span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line">c.fun(<span class="number">3</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么-js-会有闭包？"><a href="#为什么-js-会有闭包？" class="headerlink" title="为什么 js 会有闭包？"></a>为什么 js 会有闭包？</h2><p>当别人问你为什么会有闭包这东西的时候，其实是在问，闭包的形成机制。</p>
<p>当我们调用一个闭包函数时(比如上面的 getInnerDate 函数)，因为函数执行时，其上下文有个 Scope 属性，该属性作为一个作用域链包含有该函数被定义时所有外层的变量对象的引用，所以定义了闭包的函数虽然销毁了，但是其变量对象依然被绑定在函数 inner 上，保留在内存中。</p>
<p>事实上，只要代码保持对 getInnerDate 函数的引用，函数自身的[[scope]]属性就绑定着闭包的活动对象。</p>
<p>但要留意的是，基于 js 的垃圾回收机制，outer 的变量对象里，只有仍被引用的变量会继续保存在内存中：</p>
<p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；</p>
<p>如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>
<h2 id="this-关键字的理解"><a href="#this-关键字的理解" class="headerlink" title="this 关键字的理解"></a>this 关键字的理解</h2><p>this 是 JavaScript 语言的一个关键字。</p>
<p>它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。</p>
<p>那么，this 的值是什么呢？</p>
<p>函数的不同使用场合，this 有不同的值。总的来说，this 就是函数运行时所在的环境对象。下面分四种情况，详细讨论 this 的用法。</p>
<p>情况一：纯粹的函数调用（指向全局对象）<br>情况二：作为对象方法的调用（指向这个上级对象）<br>情况三: 作为构造函数调用（指这个实例对象）<br>情况四: apply 调用（指向 apply()第一个参数,若 apply()参数为空时，默认调用全局对象）,call、apply 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p>
<p>还有 es6 箭头函数： 它本身没有 this，会沿着作用域向上寻找，直到 global / window</p>
<h2 id="说说你对前端模块化的理解"><a href="#说说你对前端模块化的理解" class="headerlink" title="说说你对前端模块化的理解"></a>说说你对前端模块化的理解</h2><h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>在 js 出现的时候，js 一般只是用来实现一些简单的交互，后来 js 开始得到重视，用来实现越来越复杂的功能，而为了维护的方便，我们也把不同功能的 js 抽取出来当做一个 js 文件，但是当项目变的复杂的时候，一个 html 页面可能需要加载好多个 js 文件，而这个时候就会出现各种命名冲突，如果 js 也可以像 java 一样，把不同功能的文件放在不同的 package 中，需要引用某个函数或功能的时候，import 下相关的包，这样可以很好的解决命名冲突等各种问题，但是 js 中没有模块的概念，又怎么实现模块化呢</p>
<p>模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的 AMD 规范，CMD 规范</p>
<p>前端逻辑越来越复杂，就出现了许多问题：全局变量，函数名冲突，依赖关系不好处理。</p>
<p>模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案，一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块，但是模块开发需要遵循一定的规范，否则就都乱套了，因此，才有了后来大家熟悉的 AMD 规范，CMD 规范。</p>
<p>ES6 考虑了模块化，使用 import 和 export，但是目前浏览器还不支持，这个标准也只是个雏形。</p>
<p>模块的定义:<br>所谓的模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数</p>
<p>为什么要使用模块化:</p>
<ol>
<li><p>可维护性</p>
</li>
<li><p>命名空间</p>
</li>
<li><p>可复用性</p>
</li>
<li><p>每个文件是一个模块，有自己的作用域</p>
</li>
<li><p>再模块内部 module 变量代表模块本身</p>
</li>
<li><p>module.exports 属性代表模块对外接口</p>
</li>
</ol>
<p>模块化规范</p>
<pre><code>CommonJS
AMD
UMD
CMD
Module(es6)</code></pre>
<h2 id="web-安全攻击手段有哪些？以及如何防范？"><a href="#web-安全攻击手段有哪些？以及如何防范？" class="headerlink" title="web 安全攻击手段有哪些？以及如何防范？"></a>web 安全攻击手段有哪些？以及如何防范？</h2><p>常见的有 xss, csrf, sql 注入</p>
<h3 id="xss-cross-site-scripting-跨站脚本攻击"><a href="#xss-cross-site-scripting-跨站脚本攻击" class="headerlink" title="xss(cross site scripting) 跨站脚本攻击"></a>xss(cross site scripting) 跨站脚本攻击</h3><p>定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行<br>XSS 攻击分为 3 类：存储型（持久型）、反射型（非持久型）、基于 DOM</p>
<p>如何防范:</p>
<pre><code>设置HttpOnly以避免cookie劫持的危险
过滤，对诸如`&lt;script&gt;、&lt;img&gt;、&lt;a&gt;`等标签进行过滤
编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码
限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御</code></pre>
<h3 id="csrf-cross-site-request-forgery-跨站请求伪造"><a href="#csrf-cross-site-request-forgery-跨站请求伪造" class="headerlink" title="csrf(cross site request forgery) 跨站请求伪造"></a>csrf(cross site request forgery) 跨站请求伪造</h3><p>定义: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式</p>
<p>如何防范:</p>
<pre><code>验证 HTTP Referer 字段
请求地址中添加 token 并验证
HTTP 头中自定义属性并验证</code></pre>
<h3 id="sql-注入-SQL-injection"><a href="#sql-注入-SQL-injection" class="headerlink" title="sql 注入(SQL injection)"></a>sql 注入(SQL injection)</h3><p>定义: 在未授权情况下，非法访问数据库信息</p>
<p>如何防范:</p>
<pre><code>杜绝用户提交的参数入库并且执行
在代码层，不准出现sql语句
在web输入参数处，对所有的参数做sql转义
上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试</code></pre>
<h2 id="let-和-var-区别"><a href="#let-和-var-区别" class="headerlink" title="let 和 var 区别"></a>let 和 var 区别</h2><p>1.函数作用域 vs 块级作用域 2.变量提升 VS 暂时性死区 3.不允许重复声明变量 4.全局变量 vs 全局对象的属性 (不能使用 this.和 window 取值)</p>
<h2 id="Node-的优缺点？"><a href="#Node-的优缺点？" class="headerlink" title="Node 的优缺点？"></a>Node 的优缺点？</h2><pre><code>1.node是基于事件驱动和无堵塞模式的，因此适合在并发请求
2.node构建代理服务器相比较其他技术语言的要好的多，
3.node和前端的代码都是用javascript写的，这是非常好的
4.node是一个全新的开源项目，相比较其他语言有些不稳定
5.第三方库没有其他语言的多</code></pre>
<h2 id="什么是事件驱动？"><a href="#什么是事件驱动？" class="headerlink" title="什么是事件驱动？"></a>什么是事件驱动？</h2><p>一个触发动作引起的操作（例如点击按钮后弹出一个对话框）</p>
<h2 id="总结基本数据类型和引用数据类型区别"><a href="#总结基本数据类型和引用数据类型区别" class="headerlink" title="总结基本数据类型和引用数据类型区别"></a>总结基本数据类型和引用数据类型区别</h2><p>1、声明变量时内存分配不同</p>
<p>*原始类型：在栈中，因为占据空间是固定的，可以将他们存在较小的内存中-栈中，这样便于迅速查询变量的值</p>
<p>*引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址。</p>
<p>这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响</p>
<p>1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的 value 而已。</p>
<p>2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，</p>
<h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h2><p>函数节流与函数防抖是我们解决频繁触发 DOM 事件的两种常用解决方案</p>
<p>原理：当达到了一定的时间间隔就会执行一次；可以理解为是缩减执行频率</p>
<p>举个栗子：还是以 scroll 滚动事件来说吧，滚动事件是及其消耗浏览器性能的，不停触发。以我在项目中碰到的问题，移动端通过 scroll 实现分页，不断滚动，我们不希望不断发送请求，只有当达到某个条件，比如，距离手机窗口底部 150px 才发送一个请求，接下来就是展示新页面的请求，不停滚动，如此反复；这个时候就得用到函数节流。</p>
<h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖 debounce"></a>函数防抖 debounce</h2><p>原理：将若干函数调用合成为一次，并在给定时间过去之后，或者连续事件完全触发完成之后，调用一次(仅仅只会调用一次！！！！！！！！！！)。</p>
<p>每次调用 debounce 函数都会将前一次的 timer 清空，确保只执行一次</p>
<p>举个栗子：滚动 scroll 事件，不停滑动滚轮会连续触发多次滚动事件，从而调用绑定的回调函数，我们希望当我们停止滚动的时，才触发一次回调，这时可以使用函数防抖。</p>
<h2 id="alphabet-滑动逻辑"><a href="#alphabet-滑动逻辑" class="headerlink" title="alphabet 滑动逻辑"></a>alphabet 滑动逻辑</h2><p>上下滑动时，取字母位置逻辑：</p>
<p>获取 A 字母距离顶部高度</p>
<p>滑动时，取当前位置距离顶部高度</p>
<p>计算差值，得到当前手指位置与 A 字母顶部差值</p>
<p>除以每个字母高度，得出当前字母，触发 change 事件给外部</p>
<h2 id="什么是基于事件驱动的回调？"><a href="#什么是基于事件驱动的回调？" class="headerlink" title="什么是基于事件驱动的回调？"></a>什么是基于事件驱动的回调？</h2><p>为了某个事件注册了回调函数，但是这个回调函数不是马上执行，只有当事件发生的时候，才会调用回调函数，这种函数执行的方式叫做事件驱动~这种注册回调就是基于事件驱动的回调，如果这些回调和异步 I/O(数据写入、读取)操作有关，可以看作是基于回调的异步 I/O，<br>只不过这种回调在 nodejs 中是有事件来驱动的</p>
<h2 id="js-类型"><a href="#js-类型" class="headerlink" title="js 类型"></a>js 类型</h2><p>基本数据类型有(又称简单类型):String,Number,Boolean,Null,Undefined,Symbol<br>引用类型(又称复杂类型):function,Array,Object</p>
<h2 id="例举-3-种强制类型转换和-2-种隐式类型转换"><a href="#例举-3-种强制类型转换和-2-种隐式类型转换" class="headerlink" title="例举 3 种强制类型转换和 2 种隐式类型转换"></a>例举 3 种强制类型转换和 2 种隐式类型转换</h2><p>parseInt,parseFloat,Number</p>
<p>== , ===</p>
<h2 id="数组常用增删操作"><a href="#数组常用增删操作" class="headerlink" title="数组常用增删操作"></a>数组常用增删操作</h2><pre><code>pop ==&gt;删除最后一个数组
push ==&gt;在数组最后增加一个数组
unshift ==&gt;在数组第一个增加一个数组
shift ==&gt; 删除第一个数组
splice(index,endDelete,replaceString)</code></pre>
<h2 id="js-模式有哪些？"><a href="#js-模式有哪些？" class="headerlink" title="js 模式有哪些？"></a>js 模式有哪些？</h2><pre><code>标准模式又称严格模式，是以排版和JS运作模式都是以浏览器支持的最高标准来运行
兼容模式又称宽松模式，页面以宽松的向后兼容的方式显示，防止老版本浏览器不能运行</code></pre>
<h2 id="cookie-localStorage-sessionStorage-的区别？"><a href="#cookie-localStorage-sessionStorage-的区别？" class="headerlink" title="cookie localStorage sessionStorage 的区别？"></a>cookie localStorage sessionStorage 的区别？</h2><pre><code>1.cookie 每次都在服务器和客户端来回传递，而后俩者不会
2.后俩者存储空间更大
3.后俩者支持的api接口更多更丰富
4.后俩者都有各自独立的存储空间
5.cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的,而本地存储可以。
6.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</code></pre>
<h2 id="什么是回调？"><a href="#什么是回调？" class="headerlink" title="什么是回调？"></a>什么是回调？</h2><p>回调是异步编程时的基础，将后续逻辑封装成起始函数的参数，逐层嵌套。<br>回调函数是闭包的简单使用，也就是说它能访问到其外层定义的变量。</p>
<h2 id="0-1-0-2-等于？"><a href="#0-1-0-2-等于？" class="headerlink" title="0.1+0.2 等于？"></a>0.1+0.2 等于？</h2><p>ES6 在 Number 对象上面，新增一个极小的常量 Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>由于 JavaScript 采用 IEEE 754 标准，<strong>数值存储为 64 位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）</strong>。如果数值的精度超过这个限度，第 54 位及后面的位就会被丢弃。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的 1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false  是IEEE754标准的问题</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>; <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span>; <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解决了上面的误差浮点数检查函数</p>
<p>0.1 加上 0.2！=0.3 是因为将 0.1 转换成为二进制加上 0.2 的二进制会是 53 位但是二进制的最大位数是 52 取近似值。导致的</p>
<blockquote>
<p>别忘了：JS的精确度区间 约为正负 <code>2^53</code>，超出限制会截断。</p>
</blockquote>
<h2 id="创建实例对象的四种方法"><a href="#创建实例对象的四种方法" class="headerlink" title="创建实例对象的四种方法"></a>创建实例对象的四种方法</h2><p>引自<code>&lt;JavaScript 高级程序设计(第三版)&gt;</code>中译本 第6.2.3节, 原型模式.</p>
<p>也就是JavaScript的prototype是仅函数拥有, 而对象也拥有prototype是源于其constructor属性所拥有的prototype.</p>
<h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;root&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__.mod=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;mod&#x27;</span>)&#125;;  <span class="comment">//不等价于obj.mod=function()&#123;console.log(&#x27;mod&#x27;)&#125;</span></span><br><span class="line">obj.mod()  <span class="comment">//报错调用</span></span><br><span class="line">obj.__proto__.mod() <span class="comment">//正确调用</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Object构造函数创建"><a href="#2-Object构造函数创建" class="headerlink" title="2.Object构造函数创建"></a>2.Object构造函数创建</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj1.name=<span class="string">&#x27;root&#x27;</span></span><br><span class="line"></span><br><span class="line">obj1.__proto__.mod=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;mod&#x27;</span>)&#125; <span class="comment">//不等价于obj.mod=function()&#123;console.log(&#x27;mod&#x27;)&#125;</span></span><br><span class="line">obj1.__proto__.mod();  <span class="comment">//mod</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用工厂模式创建对象"><a href="#3-使用工厂模式创建对象" class="headerlink" title="3.使用工厂模式创建对象"></a>3.使用工厂模式创建对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> o.name = name;</span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person1.__proto__.mod=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;mod&#x27;</span>)&#125;  <span class="comment">//不等价于obj.mod=function()&#123;console.log(&#x27;mod&#x27;)&#125;</span></span><br><span class="line">person1.__proto__.mod();  <span class="comment">//mod</span></span><br></pre></td></tr></table></figure>
<h3 id="4-使用构造函数创建对象"><a href="#4-使用构造函数创建对象" class="headerlink" title="4.使用构造函数创建对象"></a>4.使用构造函数创建对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Person.prototype.mod=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;mod&#x27;</span>)&#125;  </span><br><span class="line">person1.mod();  <span class="comment">//mod</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了方法4有prototype属性,其他三种均只有<code>__proto__</code>属性,他们都是可以添加方法以及属性的</p>
</blockquote>
<h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>使用new关键字实例化的过程：</p>
<pre><code>例如：let prince = new Prince();

创建一个空的简单JavaScript对象（即&#123;&#125;）；
链接该对象（即设置该对象的构造函数）到另一个对象 ；
将步骤1新创建的对象作为this的上下文 ；
如果该函数没有返回对象，则返回this。

1.第一步，创建一个空对象。如var prince=&#123;&#125;
2.第二步，将构造函数Prince()中的this指向新创建的对象prince。(任何普通函数都具有prototype属性)(只有对象才会有this)
3.第三步，将prince的_proto_属性指向Prince函数的prototype，创建对象和原型间关系 (var prince=&#123;&#125;实例对象是__proto__属性)
4.第四步，执行构造函数Prince()内的代码。  

我们可以把他们假想为:
let prince=&#123;
      Prince:function()&#123;  //this指向新创建的对象prince
                        //这里面写的所有prototype添加的方法都在里面
                        //通过Prince.prototype.mod=function()&#123;&#125;创建的方法,prinice对象也能访问
      &#125;
&#125;

为了验证我上面的想法,我使用实例化后的对象增加方法如：prince.add=function()&#123;&#125;
在控制台中验证：
let prince=&#123;
      Prince:function()&#123;  //this指向新创建的对象prince
                        //这里面写的所有prototype添加的方法都在里面
                        //通过Prince.prototype.mod=function()&#123;&#125;创建的方法,prinice对象也能访问
      &#125;,
    add:function()&#123;&#125;
&#125;;

//上面Prince构造函数显示为__proto__属性Object对象(其实还要在下一层,这里不多写了,自行脑补下面的代码)
这就是为什么prince.__proto__ === Prince.prototype  //true
这也是为什么prince.__proto__.add === prince.prototype.add  //true
再看下我下面写的例子：
let obj1 = &#123;&#125;;  //实例化,得到__proto__属性
function test1(name)&#123;  this.name = name; console.log(&#39;Im is test1&#39;) &#125;
test1.prototype.mod1 = function()&#123; console.log(&#39;Im is mod1&#39;) &#125;
obj1.__proto__ = test1.prototype; //仔细看上面的第三步骤：将prince的_proto_属性指向Prince函数的prototype

obj1.mod1();  //Im is mod1 #到这里你可能会想,我使用let b = new test1(&#39;root&#39;); //还会输出test1函数里面的值Im is test1 以及&#123;name: &quot;root&quot;&#125;

到这里再回看上面new运算符的第四步骤，还执行了构造函数Prince()内的代码。 </code></pre>
<blockquote>
<p>任何普通函数都具有prototype属性,<code>func.prototype.med=function()&#123;&#125;</code> //但直接通过<code>func.med()</code>调用会报错，因为函数没有通过new实例化,但可以通过<code>func.prototype</code>查看新增的方法</p>
</blockquote>
<blockquote>
<p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，</p>
</blockquote>
<pre><code>    1.普通函数 :
    （1） 调用 fun()
    （2）调用函数，不会创建新对象
    （3）函数内部this指向调用它的对象，没有指明调用对象，指向window
    （4）普通函数大多以小写字母开头
    （5）没有返回值

    2.构造函数 :
    （1） 调用 f = new fun()； 使用new操作符
    （2）调用函数需要创建实例对象
    （3）函数内部this指向创建的对象 f
    （4）构造函数都应该以大写字母开头
    （5）有默认的返回值，即新创建的实例对象</code></pre>
<blockquote>
<p>详细链接<a href="https://blog.csdn.net/u013789656/article/details/80942385">https://blog.csdn.net/u013789656/article/details/80942385</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*非实例化函数的prototype属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a1</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Im is a1&#x27;</span>)&#125;</span><br><span class="line">a1.prototype.mod1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Im is mod1&#x27;</span>)&#125; <span class="comment">//测试a1.mod1=function()&#123;&#125;也可以</span></span><br><span class="line">a1.mod1();  <span class="comment">//error #若采用let obj1=Object.create(a1.prototype)则可以通过obj1.mod()访问</span></span><br><span class="line">a1.prototype.mod1();  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Im is mod1	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1.prototype.constructor === a1) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只有new运算符后的才是真正的prototype原型,普通函数的不是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*实例化函数的prototype属性*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a2</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Im is a2&#x27;</span>)&#125;</span><br><span class="line">a2.prototype.mod2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;mod2&#x27;</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> b=<span class="keyword">new</span> a2();  <span class="comment">//a函数在b的原型链里</span></span><br><span class="line">b.mod2();       <span class="comment">//若不用new实例化,则不存在prototype属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Im is a2</span></span><br><span class="line"><span class="comment">    Im is mod2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ === a2.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();  <span class="comment">//也可以let obj1 = &#123;&#125;;实例化对象</span></span><br><span class="line">obj1.__proto__.gett=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;root&#x27;</span>)&#125;	<span class="comment">//添加方法</span></span><br><span class="line">obj1.gett() 	<span class="comment">//root #由于__proto__不是标准属性,建议少用</span></span><br><span class="line"></span><br><span class="line">obj1.prototype.gett=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;root&#x27;</span>)&#125;;  <span class="comment">//error #普通对象不具有prototype对象,只有new 构造函数才有</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>prototype 属性使您有能力向对象添加属性和方法。</p>
</blockquote>
<p>当代码 new Foo(…) 执行时，会发生以下事情：</p>
<pre><code>1. 一个继承自 Foo.prototype 的新对象被创建。

2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。

3. 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</code></pre>
<h2 id="实现原生new运算符"><a href="#实现原生new运算符" class="headerlink" title="实现原生new运算符"></a>实现原生new运算符</h2><ol>
<li>创了一个新对象;</li>
<li>this指向构造函数;</li>
<li>构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象</li>
<li>手动封装一个new运算符<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new2 = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//步骤1:创建新的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(func.prototype);<span class="comment">//创建新对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤2:将构造函数func()中的this指向新创建的对象o。</span></span><br><span class="line">    <span class="keyword">var</span> k = func.call(o);<span class="comment">//改变this指向，把结果付给k, #创建对象和原型间关系</span></span><br><span class="line">    <span class="keyword">if</span> (k &amp;&amp; k <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;<span class="comment">//判断k的类型是不是对象</span></span><br><span class="line">        <span class="keyword">return</span> k;<span class="comment">//是，返回k</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o;<span class="comment">//不是返回则返回构造函数的执行结果 #基本上执行此行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">new2(func); <span class="comment">//func是个函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>语法:Object.create(proto, [propertiesObject])//方法创建一个新对象,使用现有的对象来提供新创建的对象的proto。</p>
</blockquote>
</li>
</ol>
<h2 id="异步加载-JS-的方法有哪些"><a href="#异步加载-JS-的方法有哪些" class="headerlink" title="异步加载 JS 的方法有哪些"></a>异步加载 JS 的方法有哪些</h2><pre><code>1.defer:如果你的脚本不会改变文档的内容，可以在script标签中加入defer来加快处理文档的速度，因为浏览器知道它将能够安全的读取剩余的
的部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止
2.async：html5属性仅属于外部脚本，如果在IE中同时存在defer和async，那么defer优先级比较高，脚本将在页面完成时执行创建script标签，插入到DOM中</code></pre>
<p>一般来说，如果脚本之间没有依赖关系，就使用 async 属性，如果脚本之间有依赖关系，就使用 defer 属性。</p>
<p>如果同时使用 async 和 defer 属性，后者不起作用</p>
<h2 id="ES6-异步编程有哪些"><a href="#ES6-异步编程有哪些" class="headerlink" title="ES6 异步编程有哪些"></a>ES6 异步编程有哪些</h2><p>Promise , Generator ,Async</p>
<h2 id="解决-ajax-缓存问题有哪些"><a href="#解决-ajax-缓存问题有哪些" class="headerlink" title="解决 ajax 缓存问题有哪些"></a>解决 ajax 缓存问题有哪些</h2><pre><code>1.在ajax发送请求前加上anyAjaxObj.setRequestHeader(&quot;if-modified-since&quot;,0)
2.在ajax发送请求前加上anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)
3.在URL上加上随机数：“fresh=”+Math.random()
4.在URL上加上时间戳：“nowtime=”+new Date().getTime()</code></pre>
<h2 id="鼠标移动事件"><a href="#鼠标移动事件" class="headerlink" title="鼠标移动事件"></a>鼠标移动事件</h2><pre><code>不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件
只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件
不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件
只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件</code></pre>
<h2 id="JS-中如何将页面重定向到另一个页面？"><a href="#JS-中如何将页面重定向到另一个页面？" class="headerlink" title="JS 中如何将页面重定向到另一个页面？"></a>JS 中如何将页面重定向到另一个页面？</h2><p><strong>跳转页面</strong><br>使用 location.href：window.location.href =“<a href="https://www.onlineinterviewquestions.com/%E2%80%9D">https://www.onlineinterviewquestions.com/”</a><br>使用 location.replace： window.location.replace(“ <a href="https://www.onlineinterviewquestions.com/;&quot;">https://www.onlineinterviewquestions.com/;&quot;</a>);<br>使用 location.assign(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>);</p>
<p><strong>获取页面地址</strong><br>document.URL<br>windows.location.href</p>
<ol>
<li> 从输出结果上，document.URL 和 windows.location.href 没有区别。</li>
<li> 非要说区别的话，你只可以读取 document.URL 的值，不能修改它。windows.location.href 的值你即可以读取也可以修改。</li>
</ol>
<p><strong>刷新本页</strong><br>window.location.Reload()和 window.location.href=window.location.href; //都是刷新当前页面。<br>window.location.href 和 self.location.reload(); //也是刷新本页的意思;</p>
<h2 id="遍历循环有哪些"><a href="#遍历循环有哪些" class="headerlink" title="遍历循环有哪些"></a>遍历循环有哪些</h2><pre><code>forEach   //用于遍历数组,不改变原数组,但无返回值以及break。总是会将所有成员遍历完。
map       //用于遍历数组,不改变原数组,返回一个新数组,每个数组元素被调用一次func
filter    //用于遍历数组,不改变原数组,返回一个新数组,返回每次判断为true的下标对应的值
for in    //用于遍历对象,不改变原数组,默认返回的是key值,,
for循环   //用于遍历数组以及对象
while     //用于遍历数组以及对象
do while  //用于遍历数组以及对象,至少会执行一次操作

for of    //用于遍历数组以及iterator对象,返回iterator对象,ES6提供
some      //用于遍历数组,不会改变原始数组,一直运行直到回调函数返回 true,返回true时相当于在for循环里break,会提前终止循环
every     //用于遍历数组,不会改变原始数组,一直运行直到回调函数返回 false,返回false时相当于在for循环里break,会提前终止循环

reduce     //用于遍历数组,不会改变原始数组,返回计算结果,属于高阶函数
reduceRight //和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加

其他:(find,findIndex第一个true就终止并返回数组值和下标),some和every返回值都是布尔值。

map的return语句做判断只返回布尔值。

filter的returen语句做判断为true时则返回的是数组的值,filter必须有return语句,即便return &quot;hello&quot;;  最终也是返回item的值,而不是hello。</code></pre>
<p><strong>注意:</strong> <code>for of</code>循环可以使用的范围包括数组、<code>Set</code>和<code>Map</code>结构、某些类似数组的对象（比如<code>arguments</code>对象、<code>DOM NodeList</code>对象）、后文的<code>Generator</code>对象，以及字符串。有些数据结构是在现有数据结构的基础上，计算生成的。</p>
<p><strong>TIP:</strong> 若返回大量数据,返回 iterator 对象比返回数组性能上更优。</p>
<blockquote>
<p>数组 ages.filter(checkAdult) 和 ages.find(checkAdult); 前者是过滤 checkAdult 函数的全部数据,一般情况下 return 中都是判断<code>比较运算符(&gt;=、==、&lt;=、!=)</code>,后者只过滤第一条成功的,注:均不会改变原始数组,findIndex 找出第一个满足条件返回 true 的元素下标</p>
</blockquote>
<h2 id="数组去重的简洁写法"><a href="#数组去重的简洁写法" class="headerlink" title="数组去重的简洁写法"></a>数组去重的简洁写法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>])][</span><br><span class="line">  <span class="comment">//ES5</span></span><br><span class="line">  (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">].filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key === arr.indexOf(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="理解-JavaScript-面向对象编程"><a href="#理解-JavaScript-面向对象编程" class="headerlink" title="理解 JavaScript 面向对象编程"></a>理解 JavaScript 面向对象编程</h2><pre><code>面向对象的三大特点：继承、封装、多态

1、JS中通过prototype实现原型继承

2、JS对象可以通过对象冒充，实现多重继承

3、Object类是所有Js类的基类

4、通过function对对象进行封装

5、通过使用arguments实现参数重载

6、ES6语法糖可以直接定义类class,继承对象extends</code></pre>
<h2 id="写一个-function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#写一个-function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="写一个 function，清除字符串前后的空格。（兼容所有浏览器）"></a>写一个 function，清除字符串前后的空格。（兼容所有浏览器）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.trim) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">&quot;&quot;</span>).replace(<span class="regexp">/\s+$/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;\t\n test string &quot;</span>.trim();</span><br><span class="line"></span><br><span class="line">alert(str == <span class="string">&quot;test string&quot;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="Javascript-中-callee-和-caller-的作用？"><a href="#Javascript-中-callee-和-caller-的作用？" class="headerlink" title="Javascript 中 callee 和 caller 的作用？"></a>Javascript 中 callee 和 caller 的作用？</h2><p>caller 是返回一个对函数的引用，该函数调用了当前函数;</p>
<p>callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。</p>
<h2 id="在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？"></a>在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h2><p>答案：</p>
<p>伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用 getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。</p>
<h2 id="怎样理解阻塞非阻塞与同步异步的区别？"><a href="#怎样理解阻塞非阻塞与同步异步的区别？" class="headerlink" title="怎样理解阻塞非阻塞与同步异步的区别？"></a>怎样理解阻塞非阻塞与同步异步的区别？</h2><p>同步和异步，阻塞和非阻塞，是两组不同的概念，两个之间没有必然的联系。</p>
<ul>
<li>阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程是否需要等待</li>
<li>同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会堵塞；异步只需要 I/O 操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写,如 setTimeout。</li>
</ul>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步关注的是消息通信机制。</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<blockquote>
<p>典型的异步编程模型比如 Node.js</p>
</blockquote>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
<p><strong>阻塞调用：</strong>是指调用结果返回之前，当前线程会被挂起。一直处于等待消息通知，不能够执行其他业务，调用线程只有在得到结果之后才会返回。如 alert,confirm,prompt,JavaScript 在处理回调时也存在阻塞现象</p>
<p><strong>非阻塞调用：</strong>指在不能立刻得到结果之前，该调用不会阻塞当前线程，而会立刻返回。</p>
<p>阻塞非阻塞： 请求不能立即得到应答，需要等待，那就是阻塞；否则可以理解为非阻塞。</p>
<h2 id="undefined-与-null-的区别"><a href="#undefined-与-null-的区别" class="headerlink" title="undefined 与 null 的区别"></a>undefined 与 null 的区别</h2><p>null 和 undefined 基本是同义的，只有一些细微的差别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>; <span class="comment">// false,null是对象</span></span><br></pre></td></tr></table></figure>

<p><strong>null</strong>表示”没有对象”，即该处不应该有值。典型用法是：</p>
<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<p>（2） 作为对象原型链的终点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><strong>undefined</strong>表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
<p>（1）变量被声明了，但没有赋值时，就等于 undefined。</p>
<p>（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。</p>
<p>（3）对象没有赋值的属性，该属性的值为 undefined。</p>
<p>（4）函数没有返回值时，默认返回 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>个人觉得还是根据语义来区分吧，null 更多的表示引用语义而 undefined 更多的表示值语义，虽然在数值上接近。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
